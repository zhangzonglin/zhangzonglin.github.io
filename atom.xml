<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglinagain.xyz/"/>
  <updated>2021-02-22T18:13:49.784Z</updated>
  <id>http://blog.zhangzonglinagain.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkipList (跳跃表)的那点事儿</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</id>
    <published>2021-02-22T18:13:15.000Z</published>
    <updated>2021-02-22T18:13:49.784Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c" target="_blank" rel="noopener">SkipList 的那点事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-22T17:51:27.000Z</published>
    <updated>2021-02-22T17:51:56.236Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yw09041432/p/5908444.html" target="_blank" rel="noopener">七大查找算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yw09041432/p/5908444.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;七大查找算法&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/04/%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/04/%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-03T20:28:32.000Z</published>
    <updated>2021-02-03T20:29:59.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="https://www.kukuxiaai.com/blog/2019-07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/" target="_blank" rel="noopener">数据结构与算法-树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.kukuxiaai.com/blog/2019-07/%E6%95%B0%E6%8D%AE
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>intellij-idea的快捷键</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-12-23T10:35:22.000Z</published>
    <updated>2020-12-23T10:37:11.119Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">Intellij-idea的快捷键</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java中的乱码</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/</id>
    <published>2020-12-08T13:41:00.000Z</published>
    <updated>2020-12-08T13:59:50.602Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a>、<a href="https://blog.csdn.net/u010234516/article/details/52853214" target="_blank" rel="noopener">锟斤拷？UTF-8与GBK互转，为什么会乱码？</a></p><p>附图一张:</p><a id="more"></a><p><img src="/images/crazyCode.jpg" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入分析 Java 中的中文编码问题&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/u010234516/article/details/52853214&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;锟斤拷？UTF-8与GBK互转，为什么会乱码？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附图一张:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="乱码" scheme="http://blog.zhangzonglinagain.xyz/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>websocket --Token Authentication</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/06/07/websocket-Token-Authentication/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/06/07/websocket-Token-Authentication/</id>
    <published>2020-06-07T03:01:52.000Z</published>
    <updated>2020-06-07T04:38:03.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链接：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication" target="_blank" rel="noopener">STOMP–Token Authentication</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;链接：&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framewor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cors--springboot shiro 前后端分离跨域</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-05-18T14:55:00.000Z</published>
    <updated>2020-06-08T12:05:21.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。</p><a id="more"></a><h3 id="跨域的两种方案"><a href="#跨域的两种方案" class="headerlink" title="跨域的两种方案"></a>跨域的两种方案</h3><h4 id="沿用Cookie"><a href="#沿用Cookie" class="headerlink" title="沿用Cookie"></a>沿用Cookie</h4><p>沿用传统的cookie session方式，就需要前后端分别设置，可以让前端的request带上后端域名对应的cookie</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>客户端需要设置Ajax请求属性withCredentials 为true，让Ajax请求都带上Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">           url:url,</span><br><span class="line">           type:&quot;GET&quot;,</span><br><span class="line">           xhrFields:&#123;</span><br><span class="line">               withCredentials:true</span><br><span class="line">           &#125;,</span><br><span class="line">           success:function(res)&#123; </span><br><span class="line">               console.log(res);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>首先服务端在使用cors协议时需要设置响应消息头<em>Access-Control-Allow-Credentials<em>的值为</em>true*，即允许在ajax访问时携带cookie(如上，前端也要设置withCredentials为true)。另外为了安全，在cors标准里不允许Access-Control-Allow-Origin设置为</em>,而是必须指定明确的、与请求网页一致的域名，cookie也依然遵循“同源策略”，只有用目标服务器域名设置的cookie才会上传，而且使用document.cookie也无法读取目标服务器域名下的cookie。接下来我们来看看实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">]</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)     &#x2F;&#x2F; 此时，不允许为*</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">&#x2F;&#x2F;            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义http-header"><a href="#自定义http-header" class="headerlink" title="自定义http header"></a>自定义http header</h4><p>绕过cookie，自定义http header传输token(本项目token即sessionId)，这种方式适合前端不支持cookie的时候，具体设置在后文中。</p><h3 id="session管理"><a href="#session管理" class="headerlink" title="session管理"></a>session管理</h3><p>采用第二种方式，就需要绕过传统的sessionid传输方式：通过请求头里的cookie传输（浏览器的cookie是跟着域名走的）。客户端登录，服务端通过JSON返回sessionid，客户端保存，后续每次请求要在请求头中添加加token字段，服务端shiro根据请求头的token字段获取sessionid。<br>shiroConfiguration中的securityManager配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        manager.sessionManager &#x3D; sessionManager()</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun sessionManager(): SessionManager? &#123;</span><br><span class="line">        val mySessionManager &#x3D; MySessionManager()</span><br><span class="line">        mySessionManager.setSessionDAO(sessionDAO())</span><br><span class="line">        return mySessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是在MySessionManager里重写DefaultWebSessionManager的getSessionId方法和retrieveSession方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.apache.shiro.session.Session</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey</span><br><span class="line">import org.apache.shiro.web.servlet.ShiroHttpServletRequest</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line">import org.apache.shiro.web.util.WebUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import java.io.Serializable</span><br><span class="line">import java.lang.Boolean</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class MySessionManager : DefaultWebSessionManager&#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var log &#x3D; LoggerFactory.getLogger(this.javaClass.name)</span><br><span class="line">        private val AUTHORIZATION &#x3D; &quot;auth-token&quot;</span><br><span class="line">        private val HEADER_SESSION_ID_SOURCE &#x3D; &quot;header request&quot;</span><br><span class="line">        private val MY_SESSION_ATTRIBUTE &#x3D; &quot;MY_SESSION_ATTRIBUTE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override fun getSessionId(request: ServletRequest, response: ServletResponse?): Serializable? &#123;</span><br><span class="line">        val id &#x3D; WebUtils.toHttp(request).getHeader(AUTHORIZATION)</span><br><span class="line">        &#x2F;&#x2F;如果请求头中有 Authorization 字段， 则其值为sessionId</span><br><span class="line">        return if (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, HEADER_SESSION_ID_SOURCE)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE)</span><br><span class="line">            id</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;否则按默认规则从cookie取sessionId</span><br><span class="line">            super.getSessionId(request, response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(UnknownSessionException::class)</span><br><span class="line">    protected override fun retrieveSession(sessionKey: SessionKey?): Session? &#123;</span><br><span class="line">        val sessionId &#x3D; getSessionId(sessionKey) ?: return null</span><br><span class="line">        val request: ServletRequest &#x3D; WebUtils.getRequest(sessionKey)</span><br><span class="line">        return if (request.getAttribute(MY_SESSION_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">            log.debug(&quot;Get Session from request!&quot;)</span><br><span class="line">            request.getAttribute(MY_SESSION_ATTRIBUTE) as Session</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Get Session from redis!&quot;)</span><br><span class="line">            val s: Session &#x3D; retrieveSessionFromDataSource(sessionId)</span><br><span class="line">            if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;session ID was provided, meaning one is expected to be found, but we couldn&#39;t find one:</span><br><span class="line">                val msg &#x3D; &quot;Could not find session with ID [$sessionId]&quot;</span><br><span class="line">                throw UnknownSessionException(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            request.setAttribute(MY_SESSION_ATTRIBUTE, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>  对于简单请求，浏览器直接在ruquest头之中，增加一个Origin字段，相应地，服务器会在response头中添加Access-Control-Allow-Origin等字段，如此便是一次成功的跨域请求。</p><p><img src="/images/pasted-24.png" alt="upload successful"><br>只要同时满足以下两大条件，就属于简单请求。</p><p>请求方法是以下三种方法之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure><p>HTTP的头信息不超出以下几种字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight），预检的请求方法（Request Method）为OPTION。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义过滤器，针对请求头中有Origin字段的，response头中添加相应字段，针对OPITION请求,response返回200状态码。<br>新建CorsFilter类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.http.HttpStatus</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod</span><br><span class="line">import javax.servlet.*</span><br><span class="line">import javax.servlet.http.HttpServletRequest</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@WebFilter(urlPatterns &#x3D; arrayOf(&quot;&#x2F;*&quot;),filterName &#x3D; &quot;crosFilter&quot;)</span><br><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">            logger.info(&quot;处理跨域请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立WebFilterConfig类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean</span><br><span class="line">import org.springframework.context.annotation.Bean</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import javax.servlet.Filter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1：自定义过滤器，可以采取Filter加@WebFilter和启动类加@ServletComponentScan的方式，过滤器的执行顺序按照类名排序</span><br><span class="line"> * 故而采用如下FilterRegistrationBean的方式，可以自定义顺序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">class WebFilterConfig&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun crosResFilter(): FilterRegistrationBean&lt;*&gt;? &#123;</span><br><span class="line">        val filterRegistrationBean: FilterRegistrationBean&lt;Filter?&gt; &#x3D; FilterRegistrationBean&lt;Filter?&gt;()</span><br><span class="line">        val corsFilter &#x3D; CorsFilter()</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter)</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;) &#x2F;&#x2F;配置过滤规则</span><br><span class="line">        filterRegistrationBean.setName(&quot;corsFilter&quot;) &#x2F;&#x2F;设置过滤器名称</span><br><span class="line">        filterRegistrationBean.order &#x3D; 1 &#x2F;&#x2F;执行次序</span><br><span class="line">        return filterRegistrationBean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此便能愉快的跨域访问了。</p><h3 id="shiro跳转"><a href="#shiro跳转" class="headerlink" title="shiro跳转"></a>shiro跳转</h3><p>由于shiro对前后端分离支持不是很理想，如访问需认证的路径，若未登录会直接跳转至登录页面（默认是/login.jsp），这中情况我们需要直接返回未认证的JSON数据，由前端控制路由。<br>新建MyFormAuthenticationFilter，继承shiro的FormAuthenticationFilter（对应过滤authc的路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.JsonUtils</span><br><span class="line">import com.example.customer.util.constants.ErrorEnum</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line">class MyFormAuthenticationFilter : FormAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val log &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun onAccessDenied(request: ServletRequest?, response: ServletResponse?): Boolean &#123;</span><br><span class="line">        return if (isLoginRequest(request, response)) &#123;</span><br><span class="line">            if (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                executeLogin(request, response)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login page view.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;allow them to see the login page ;)</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var resp &#x3D; response as HttpServletResponse</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +</span><br><span class="line">                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不再跳转，直接返回Json信息</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.getWriter().write(JsonUtils.errorJson(ErrorEnum.E_401).toString())</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在shiro过滤链中，添加自定义过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class ShiroConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * shiro过滤器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun shiroFilter(manager: SecurityManager) : ShiroFilterFactoryBean&#123;</span><br><span class="line">        val factoryBean &#x3D; ShiroFilterFactoryBean()</span><br><span class="line">        &#x2F;&#x2F;设置securityManager</span><br><span class="line">        factoryBean.securityManager &#x3D; manager</span><br><span class="line">        &#x2F;&#x2F;自定义过滤器,修改认证失败跳转</span><br><span class="line">        val filters &#x3D; mutableMapOf&lt;String,Filter&gt;()</span><br><span class="line">        filters.put(&quot;myauthc&quot;,myFormAuthenticationFilter())</span><br><span class="line">        factoryBean.filters &#x3D;  filters</span><br><span class="line"></span><br><span class="line">        val filterChainDefinitionMap: MutableMap&lt;String, String&gt; &#x3D; LinkedHashMap()</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;static&#x2F;**&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 静态资源匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;doLogin&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;logout&quot;] &#x3D; &quot;logout&quot; &#x2F;&#x2F; 用户退出，只需配置logout即可实现该功能</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;**&quot;] &#x3D; &quot;myauthc&quot; &#x2F;&#x2F; 其他路径均需要身份认证，一般位于最下面，优先级最低</span><br><span class="line">        &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面</span><br><span class="line">        &#x2F;&#x2F;身份认证失败，不直接Shiro跳转至默认登录页，而是跳转至未认证接口，返回Json数据，前后端分离中登录界面跳转应由前端路由控制</span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F; factoryBean.setLoginUrl(&quot;&#x2F;login&#x2F;unauth&quot;);</span><br><span class="line">        &#x2F;&#x2F; 权限认证失败，跳转后续处理</span><br><span class="line"> &#x2F;&#x2F;       factoryBean.setUnauthorizedUrl(&quot;&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap)</span><br><span class="line"></span><br><span class="line">        return factoryBean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private fun myFormAuthenticationFilter(): MyFormAuthenticationFilter&#123;</span><br><span class="line">        return MyFormAuthenticationFilter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *securityManager配置</span><br><span class="line">     * 不指定名字的话，自动创建一个方法名第一个字母小写的bean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/shiro/"/>
    
      <category term="springboot" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/shiro/springboot/"/>
    
    
      <category term="cors" scheme="http://blog.zhangzonglinagain.xyz/tags/cors/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglinagain.xyz/tags/shiro/"/>
    
      <category term="spring boot" scheme="http://blog.zhangzonglinagain.xyz/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 构造函数</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-17T06:28:00.000Z</published>
    <updated>2020-05-17T06:51:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.cnblogs.com/Jetictors/p/7758828.html" target="_blank" rel="noopener">Kotlin——中级篇（一）：类（class）详解</a></strong>、<strong><a href="https://www.jianshu.com/p/5db34354d812" target="_blank" rel="noopener">kotlin之构造函数(constructor)</a></strong><br>1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。</p><p>2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派</p><a id="more"></a><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test constructor(num: Int)&#123;</span><br><span class="line">    constructor(num : Int, num2: Int) : this(num) &#123;</span><br><span class="line">        println(num + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：二级构造函数中的参数1(num)，是委托了主构造函数的参数num。</span><br></pre></td></tr></table></figure><p>3、在JVM上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。<br>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Jetictors/p/7758828.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin——中级篇（一）：类（class）详解&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/5db34354d812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin之构造函数(constructor)
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。&lt;/p&gt;
&lt;p&gt;2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>json web token(jwt)</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/05/02/json-web-token-jwt/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/05/02/json-web-token-jwt/</id>
    <published>2020-05-02T14:13:00.000Z</published>
    <updated>2020-05-02T14:18:28.928Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://learnku.com/articles/22616" target="_blank" rel="noopener">别再使用 JWT 作为 Session 系统！问题重重且很危险。</a></strong><br>结论：无状态 JWT Tokens 无法被单独地销毁或更新，取决于你如何存储，可能还会导致长度问题、安全隐患。有状态 JWT Tokens 在功能方面与 Session cookies 无异，但缺乏生产环境的验证、经过大量 Review 的实现，以及良好的客户端支持。<br>JWT 特别有效的使用例子通常是作为一次性的授权令牌。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://learnku.com/articles/22616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别再使用 JWT 作为 Session 系统！问题重重且很危险。
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
      <category term="jwt" scheme="http://blog.zhangzonglinagain.xyz/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之IP、MAC</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/</id>
    <published>2020-04-14T02:31:00.000Z</published>
    <updated>2020-04-14T02:34:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.wmathor.com/index.php/archives/1124/" target="_blank" rel="noopener">MAC 地址与 IP 地址</a></strong>、<strong><a href="https://zhuanlan.zhihu.com/p/82184208" target="_blank" rel="noopener">物理层 和 MAC 层</a></strong>、<strong><a href="https://www.jianshu.com/p/63fd0faa47da" target="_blank" rel="noopener">网络传输中的三张表，MAC地址表、ARP缓存表以及路由表详解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.wmathor.com/index.php/archives/1124/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MAC 地址与 IP 地址&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.zhangzonglinagain.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="MAC" scheme="http://blog.zhangzonglinagain.xyz/tags/MAC/"/>
    
      <category term="IP" scheme="http://blog.zhangzonglinagain.xyz/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>锁、synchronized、CAS、volatile</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/</id>
    <published>2020-04-06T10:42:00.000Z</published>
    <updated>2020-04-06T10:49:03.174Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></strong>、<strong><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></strong>、<strong><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/12129120.html" target="_blank" rel="noopener">从原子类和UNSAFE来理解JAVA内存模型，ATOMICINTEGER的INCREMENTANDGET方法和UNSAFE部分源码介绍，VALUEOFFSET偏移量的理解</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9396834.html" target="_blank" rel="noopener">JAVA内存模型中VOLATILE关键字的作用</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9399881.html" target="_blank" rel="noopener">JAVA内存模型，为啥线程要有自己的本地内存，CPU高速缓存</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不可不说的Java“锁”事&lt;/a&gt;&lt;/strong&gt;、&lt;strong
      
    
    </summary>
    
    
    
      <category term="lock" scheme="http://blog.zhangzonglinagain.xyz/tags/lock/"/>
    
      <category term="synchronized" scheme="http://blog.zhangzonglinagain.xyz/tags/synchronized/"/>
    
      <category term="CAS" scheme="http://blog.zhangzonglinagain.xyz/tags/CAS/"/>
    
      <category term="volatile" scheme="http://blog.zhangzonglinagain.xyz/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP之NAT</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/</id>
    <published>2020-03-27T10:12:00.000Z</published>
    <updated>2020-03-27T10:13:19.218Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.mobilezhao.com/?cat=3" target="_blank" rel="noopener">TCP/IP之NAT</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.mobilezhao.com/?cat=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP/IP之NAT&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="tcp/ip" scheme="http://blog.zhangzonglinagain.xyz/categories/tcp-ip/"/>
    
    
      <category term="nat" scheme="http://blog.zhangzonglinagain.xyz/tags/nat/"/>
    
  </entry>
  
  <entry>
    <title>补码原理的个人理解</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-03-20T07:25:00.000Z</published>
    <updated>2020-03-20T07:26:25.818Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/jiaobuchong/article/details/83188674" target="_blank" rel="noopener">补码原理的个人理解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/jiaobuchong/article/details/83188674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;补码原理的个人理解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://blog.zhangzonglinagain.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="补码" scheme="http://blog.zhangzonglinagain.xyz/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《Spring设计思想-事务篇》2.数据库隔离级别</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-03-12T09:32:48.000Z</published>
    <updated>2020-06-28T07:35:04.800Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">《Spring设计思想-事务篇》2.数据库隔离级别</a></strong>，<strong><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">深入分析事务的隔离级别</a></strong>，<strong><a href="https://www.hollischuang.com/archives/923" target="_blank" rel="noopener">MySQL中的共享锁与排他锁</a></strong></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。</p><a id="more"></a><p>事务的并发数和数据数据一致性这两个是两个相反的理想指标。而数据库研发的方向就是尽可能提高同时提高两个指标，尽可能减少之间的反作用影响。</p><p>SERIALIZABLE 序列化读，隔离级别最高，客户端以互斥的方式访问数据库资源，统一时间内，同一个资源只能被一个客户端访问，好像客户端在排队请求访问，所以称为序列化读。<br>REPEATABLE_READ 可重复读，可重复读能够保证，一个客户端在一个事务内，多次访问同一个资源时，返回结果是一样的，顾名思义，称为可重复读，这种隔离级别可能会造成幻读现象。<br>READ_COMMITTED 读已提交，即客户端在一个事务内，每次查询读取的数据都是从数据库读取最新的已提交的数据；这种隔离界别可能会造成不可重复读和幻读现象。<br>READ_UNCOMMITTED 读未提交，即客户端在一个事务内，可以读取到其他客户端事务的尚未提交的数据；这种隔离级别可能会造成脏读、不可重复读、幻读 现象。</p><p><img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/95319795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想-事务篇》2.数据库隔离级别
&lt;/a&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/943&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入分析事务的隔离级别&lt;/a&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;a href=&quot;https://www.hollischuang.com/archives/923&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL中的共享锁与排他锁&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《Spring设计思想》AOP设计基本原理</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-11T14:32:00.000Z</published>
    <updated>2020-03-11T14:34:40.664Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">《Spring设计思想》AOP设计基本原理</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/51095702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想》AOP设计基本原理
&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglinagain.xyz/tags/spring/"/>
    
      <category term="aop" scheme="http://blog.zhangzonglinagain.xyz/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/</id>
    <published>2020-03-11T06:07:04.000Z</published>
    <updated>2020-03-11T14:24:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/24589193&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java动态代理机制详解（JDK 和CGLIB，Java
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring 线程安全</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-03-09T06:46:00.000Z</published>
    <updated>2020-03-09T07:15:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/kismetv/p/8757260.html" target="_blank" rel="noopener"><strong>Spring中获取request的几种方法，及其线程安全性分析</strong></a>、<strong><a href="https://www.jianshu.com/p/e04491f3550f" target="_blank" rel="noopener">Spring 如何保证线程安全</a></strong>、<strong><a href="https://blog.csdn.net/cs408/article/details/48972653" target="_blank" rel="noopener">Spring中Singleton模式的线程安全</a></strong></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作</p><a id="more"></a><p>数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧。并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该栈帧并释放掉。</p><p>&emsp;注意：Java栈中的数据是线程私有的，一个线程是无法访问另一个线程的Java栈的数据。这也就是为什么多线程编程时，两个相同线程执行同一方法时，对方法内的局部变量是不需要数据同步的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/8757260.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Spring中获取request的几种方法，及其线程安全性分析&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/e04491f3550f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 如何保证线程安全
&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/cs408/article/details/48972653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring中Singleton模式的线程安全
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;备注&quot;&gt;&lt;a href=&quot;#备注&quot; class=&quot;headerlink&quot; title=&quot;备注&quot;&gt;&lt;/a&gt;备注&lt;/h3&gt;&lt;p&gt;&amp;emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglinagain.xyz/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>jvm-invokeinterface</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/09/vm-invokeinterface/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/09/vm-invokeinterface/</id>
    <published>2020-03-09T05:57:00.000Z</published>
    <updated>2020-03-09T06:01:48.588Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://blog.csdn.net/kang389110772/article/details/50723127" target="_blank" rel="noopener">Spring为什么Autowired注入的是接口</a>、</p><p><a href="https://github.com/1993hzh/thoughts/issues/5" target="_blank" rel="noopener">浅析JVM中invokevirtual与invokeinterface的区别 #5</a>、</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.3" target="_blank" rel="noopener">Java Virtual Machine Specification</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/kang389110772/article/details/50723127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring为什么Autowired注入的是接口
&lt;/a&gt;、&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
      <category term="jvm" scheme="http://blog.zhangzonglinagain.xyz/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java底层机制（堆/栈/方法区/GC/类加载）</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-08T13:21:00.000Z</published>
    <updated>2020-03-11T09:15:36.601Z</updated>
    
    <content type="html"><![CDATA[<p>转载:<strong><a href="https://www.jianshu.com/p/ae97b692614e?from=timeline" target="_blank" rel="noopener">java底层机制</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载:&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/ae97b692614e?from=timeline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java底层机制&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring boot注解基本了解</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/03/06/java-annotation/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/03/06/java-annotation/</id>
    <published>2020-03-06T03:38:00.000Z</published>
    <updated>2020-03-06T03:43:08.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里放两篇对Java注解的文章，以备后面查询。<a href="https://www.jianshu.com/p/d74ed7374841" target="_blank" rel="noopener"><strong>Spring Boot 注解—基本知识</strong></a>以及<a href="https://www.cnblogs.com/liaojie970/p/7879917.html" target="_blank" rel="noopener"><strong>Java注释@interface的用法</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里放两篇对Java注解的文章，以备后面查询。&lt;a href=&quot;https://www.jianshu.com/p/d74ed7374841
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglinagain.xyz/categories/java/"/>
    
    
      <category term="annotation" scheme="http://blog.zhangzonglinagain.xyz/tags/annotation/"/>
    
  </entry>
  
</feed>
