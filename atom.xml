<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglinagain.xyz/"/>
  <updated>2021-04-02T13:48:16.913Z</updated>
  <id>http://blog.zhangzonglinagain.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux 后台运行、输出重定向</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2021-04-02T13:05:47.000Z</published>
    <updated>2021-04-02T13:48:16.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux termianl中，命令脚本的后台运行以及输出的重定向，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &gt; my.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &amp;&gt; my.log &amp;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>当启动一个服务后，希望命令在后台运行时，可以通过在命令末尾增加 &amp; ，例如：./test.sh &amp;，执行上述命令后，脚本开始在后台运行，并且命令行回显为 [1] 12532 ,这里的 1表示后台进程的编号，可以通过命令 fg 1 把进程切换回前台运行。</p><p>此时，虽然命令已经后台运行了，我们可以在控制台输入其他命令，但是脚本每秒打印的 x 会不断的输出到控制台，影响我们其他命令的执行，这时，我也需要用输出重定向把命令的执行结果输出的文件中。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>一个程序执行后，系统会生成三个句柄，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0&#x3D;stdin（标准输入）</span><br><span class="line">1&#x3D;stdout（标准输出）</span><br><span class="line">2&#x3D;stderr（错误输出）</span><br></pre></td></tr></table></figure><p>默认情况下，三个句柄都指向当前会话的命令行控制台。命令转到后台执行后，stdin关闭，stdout和stderr还是指向控制台。</p><p>通过在命令后使用输出重定向符 &gt; 实现对输出的重定向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout重定向到当前目录的run.log文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout和stderr都重定向到run.log，其中 2&gt;&amp;1 表示把stderr重定向到stdout。另外，其中&gt; run.log表示标准输出重定向到文件run.log中且是<strong>覆盖重写，如果想要追加方式写入，则是&gt;&gt; run.log</strong>。</p><p>Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。 </p><p>如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-) </p><p>另外+: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &amp;&gt; make_log</span><br></pre></td></tr></table></figure><p>意思是把标准输出和错误输出都重定向, <em>command&gt;out</em> 只重定向标准输出!!!!! </p><p><em>&gt;log</em> 表示把标准输出重新定向到文件log中 </p><p><em>&amp;&gt; log</em> 表示把标准输出和错误输出都定向到文件log中，相当于 <em>&gt;log 2&gt;&amp;1</em></p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>通过 &amp; 虽然可以把命令以后台进程的方式执行，但是如果SSH会话中断退出，和此会话相关的所有进程都会终止。<br>如果我们是登录服务器去启动一个服务程序，总不能启动后一直把SSH会话开着，而且会话到期会自动终止。</p><p>这是，我们可以使用 nohup（no hung up）来执行进程，此命令确保会话挂断后，命令可以继续运行。以nohup运行的命令，系统默认自动把stdout和stderr重定向到当前目录的nohup.out文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;run.py &amp;</span><br></pre></td></tr></table></figure><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><p>&amp;：已后台进程执行命令，但是会话关闭后，进程会结束。</p><p>nohup：确保进程不挂断的执行，但是没有后台执行的功能，所以一般nohup和&amp;需要配合一起使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;linux termianl中，命令脚本的后台运行以及输出的重定向，如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;gt; my.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;amp;&amp;gt; my.log &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu 开机启动管理</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-03-20T16:26:23.000Z</published>
    <updated>2021-03-20T16:31:48.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu自启服务管理命令</p><a id="more"></a><p>查看开机启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --type&#x3D;service|grep enabled</span><br></pre></td></tr></table></figure><p>以蓝牙为例，查询蓝牙服务是否开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled bluetooth.service</span><br></pre></td></tr></table></figure><p>如果是enable开机自启动<br>如果是disable不开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable bluetooth.service #开机运行服务</span><br><span class="line"></span><br><span class="line">systemctl disable bluetooth.service #取消开机运行</span><br><span class="line"></span><br><span class="line">sudo systemctl disable  bluetooth.service#关闭蓝牙服务</span><br><span class="line"></span><br><span class="line">systemctl start bluetooth.service #启动服务</span><br><span class="line"></span><br><span class="line">systemctl stop bluetooth.service #停止服务</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth.service #重启服务</span><br><span class="line"></span><br><span class="line">systemctl reload bluetooth.service #重新加载服务配置文件</span><br><span class="line"></span><br><span class="line">systemctl status bluetooth.service #查询服务运行状态</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu自启服务管理命令&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA激活</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/</id>
    <published>2021-03-20T07:01:39.000Z</published>
    <updated>2021-03-20T07:03:11.678Z</updated>
    
    <content type="html"><![CDATA[<p>可用方法：<a href="https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3" target="_blank" rel="noopener">IntelliJ IDEA 2020.3.3激活破解教程（亲测激活至 2099 年，长期更新）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可用方法：&lt;a href=&quot;https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA 2020.3.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ssh 密码登录脚本</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</id>
    <published>2021-03-18T19:37:00.000Z</published>
    <updated>2021-03-18T20:09:33.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脚本密码登录服务器</p><a id="more"></a><p>1、安装expect<br>使用以下代码检测expect是否已经安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;usr&#x2F;bin | grep expect</span><br></pre></td></tr></table></figure><p>如果显示为空，则使用以下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure><p>2、 制作脚本<br>合适位置建个sh文件，脚本中写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh root@127.0.0.1 -p 22</span><br><span class="line">expect &quot;*Are you sure you want to continue connecting (yes&#x2F;no)?&quot;</span><br><span class="line">send &quot;yes\r&quot;</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;脚本密码登录服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 打开win10 txt中文乱码</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2021-03-18T19:05:00.000Z</published>
    <updated>2021-03-18T19:15:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。</p><a id="more"></a><p>1、原因<br>ubuntu系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件）则vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），最终显示文件为乱码。</p><p>2、解决办法<br>在<em>/home/user/*下修改</em>.vimrc*文件（系统新装，默认情况下尚未创建）。 编辑 ~/.vimrc 文件（ 添加如下几行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set fileencodings&#x3D;utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding&#x3D;utf-8</span><br><span class="line">set encoding&#x3D;utf-8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下使用微信、QQ等</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/new/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/new/</id>
    <published>2021-03-17T19:32:00.000Z</published>
    <updated>2021-03-18T01:38:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。</p><a id="more"></a><p>网上教程多如牛毛，但不是坑，就是坑，找了个自己能用的，记录下备用<br>1、安装docker docker-compose，网上教程一大把，自己搜<br>2、执行如下命令<br>首先要允许所有用户访问X11服务,运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></table></figure><p>拉取镜像（注意docker设置国内镜像地址，用科大的就行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bestwu&#x2F;wechat</span><br></pre></td></tr></table></figure><p>在你指定的文件夹下创建 docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">  wechat:</span><br><span class="line">    image: bestwu&#x2F;wechat</span><br><span class="line">    container_name: wechat</span><br><span class="line">    devices:</span><br><span class="line">      - &#x2F;dev&#x2F;snd</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;tmp&#x2F;.X11-unix:&#x2F;tmp&#x2F;.X11-unix</span><br><span class="line">      - $PWD&#x2F;WeChatFiles:&#x2F;WeChatFiles</span><br><span class="line">    environment:</span><br><span class="line">      - DISPLAY&#x3D;unix$DISPLAY</span><br><span class="line">      - QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">      - GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - AUDIO_GID&#x3D;26 # 可选 默认63（在终端用getent group video | cut -d: -f3查） 主机audio gid 解决声音设备访问权限问题</span><br><span class="line">      - GID&#x3D;1000 # 可选 默认1000 主机当前用户 gid 解决挂载目录访问权限问题</span><br><span class="line">      - UID&#x3D;1000 # 可选 默认1000 主机当前用户 uid 解决挂载目录访问权限问题</span><br><span class="line">    ipc: host</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="wechat" scheme="http://blog.zhangzonglinagain.xyz/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自动挂载其他盘</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/</id>
    <published>2021-03-17T19:12:29.000Z</published>
    <updated>2021-03-17T19:13:00.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p><a id="more"></a><p>1、查询挂载硬盘UUID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p><p>2、打开文件/etc/fstab文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>在文档末尾添加相应磁盘的信息。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p><p>3、重启生效</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu terminal 打开后的默认位置和大小</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/</id>
    <published>2021-03-17T17:28:00.000Z</published>
    <updated>2021-03-17T19:12:15.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。</p><a id="more"></a><p>网传的一般有两种，一种是自定义快捷键，一种是修改<em>/usr/share/applications/gnome-terminal.desktop</em>。第二种效果只是修改了“通过菜单栏或鼠标点击进入终端时的位置”，用<em>Ctrl+Alt+T</em>进入时，没有效果，所以本文选择第一种，步骤如下：</p><p>1、打开一个终端，把它调整到自己想要的大小和位置</p><p>2、在终端内执行xwininfo，鼠标变成十字，然后鼠标点击终端，出现终端窗口的信息，注意最后一行： -geometry 80x24-4+168</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>3、依次进入Setting - Devices - keyboard，可以看到系统的所有快捷键设置，包括<em>Launch terminal Ctrl+Alt+T</em>。拉到最下面，点击+号</p><p><img src="/images/pasted-31.png" alt="upload successful"></p><p>Name自己取，主要是Command,输入步骤2的大小坐标信息，  <em>gnome-terminal –geometry=80x24-4+168</em> ，Shortcut自定义即可，注意不要跟现存的快捷键冲突。我自己是用的Super+T。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="terminal" scheme="http://blog.zhangzonglinagain.xyz/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中vim的粘帖复制</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-16T17:13:00.000Z</published>
    <updated>2021-03-16T20:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。</p><a id="more"></a><h3 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h3><h4 id="默认剪贴板"><a href="#默认剪贴板" class="headerlink" title="默认剪贴板"></a>默认剪贴板</h4><p>vim会有一些存储空间来暂存内容，vim中将这些存储空间叫寄存器。此寄存器非我们硬件所说的寄存器，可以理解为是一种cache。例如我们在vim中y操作复制的内容，实际就是暂存到寄存器中。</p><p>如下，在vim中执使用:reg命令，可以查看各个寄存器的内容。<br><img src="/images/pasted-27.png" alt="upload successful"></p><p>其中有两个特殊的寄存器: “* 和 “+。前者关联系统选择缓冲区(Buffer)，后者关联系统剪切板(Clipboard)，关于系统剪切板的使用见下文。</p><h4 id="复制和粘贴到指定剪贴板"><a href="#复制和粘贴到指定剪贴板" class="headerlink" title="复制和粘贴到指定剪贴板"></a>复制和粘贴到指定剪贴板</h4><p>要把vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后（按Esc），按 *”Ny* 完成复制，其中N表示特定寄存器编号（注意是按一下双引号然后按粘贴板号最后按y），例如要把内容复制到系统剪切板，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+y</span><br></pre></td></tr></table></figure><p>就可以了。注意的是，上面是 双引号 + 加号寄存器 + y。通过这命令copy后就可以去浏览器Ctrl+v了。</p><p>如果从浏览器Ctrl+c后，要粘贴到vim中，则需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+p</span><br></pre></td></tr></table></figure><h3 id="系统剪切板及使用"><a href="#系统剪切板及使用" class="headerlink" title="系统剪切板及使用"></a>系统剪切板及使用</h3><h4 id="查看-Vim-是否支持系统剪切板"><a href="#查看-Vim-是否支持系统剪切板" class="headerlink" title="查看 Vim 是否支持系统剪切板"></a>查看 Vim 是否支持系统剪切板</h4><p>刚重装了系统，命令按了半天，跑到其他地方Ctrl+v，什么也没有，原来是系统剪切板不支持的锅。<br>在终端输入 <em>vim –version | grep clipboard</em>回车：<br><img src="/images/pasted-28.png" alt="upload successful"><br>如果 clipboard 前面都是 - 号，说目前还不支持系统剪切板功能，请继续看下一节，如果都是 + 号，略过此节。</p><h4 id="开启系统剪切板功能"><a href="#开启系统剪切板功能" class="headerlink" title="开启系统剪切板功能"></a>开启系统剪切板功能</h4><p>开启系统剪切板功能的方法也有很多，比较正统的应该是重新编译安装 Vim 源码，因为我怕麻烦（水平渣），所以选择简单的方法，即安装 vim-gnome。<br>一行指令即可搞定，在终端输入 <em>sudo apt install vim-gnome -y</em>回车。<br>此时再次使用上述的两个方法验证，发现 Vim 已经支持系统剪切板功能。</p><h3 id="vim内部复制、粘贴、剪切"><a href="#vim内部复制、粘贴、剪切" class="headerlink" title="vim内部复制、粘贴、剪切"></a>vim内部复制、粘贴、剪切</h3><h4 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h4><p>在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v+光标移动 （按字符选择）高亮选中所要的文本，然后进行各种操作（比如粘帖到系统剪切板“+y）。</span><br><span class="line">V （按行选择）</span><br><span class="line">v+选中的内容+c 更改选中的文字</span><br></pre></td></tr></table></figure><h4 id="复制：y-ank"><a href="#复制：y-ank" class="headerlink" title="复制：y(ank)"></a>复制：y(ank)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y 用v命令选中文本后，用y进行复制</span><br><span class="line">yy 复制当前行，然后用p进行粘贴</span><br><span class="line">5yy 复制从当前行开始的5行</span><br><span class="line">y_ 等同于yy</span><br><span class="line">Y 等同于yy</span><br><span class="line">yw 复制当前单词</span><br><span class="line">y$ 从当前位置复制到行尾</span><br><span class="line">y0 从当前位置复制到行首</span><br><span class="line">y^ 从当前位置复制到第一个非空白字符</span><br><span class="line">yG 从当前行复制到文件结束</span><br><span class="line">y20G 从当前行复制到第20行</span><br><span class="line">y?bar 复制至上一个出现bar的位置</span><br></pre></td></tr></table></figure><h4 id="粘贴：p-aste"><a href="#粘贴：p-aste" class="headerlink" title="粘贴：p(aste)"></a>粘贴：p(aste)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p(小写) 在光标位置之后粘贴</span><br><span class="line">P(大写) 在光标位置之前粘贴</span><br></pre></td></tr></table></figure><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v + 方向键(hjkl)选中内容 + d 剪切 + p粘贴</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="vim复制到系统剪贴板"><a href="#vim复制到系统剪贴板" class="headerlink" title="vim复制到系统剪贴板"></a>vim复制到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;*y</span><br><span class="line">&quot;+y</span><br><span class="line">&quot;+2yy – 复制两行</span><br><span class="line">&#123;Visual&#125;&quot;+y - copy the selected text into the system clipboard</span><br><span class="line">&quot;+y&#123;motion&#125; - copy the text specified by &#123;motion&#125; into the system clipboard</span><br><span class="line">:[range]yank + - copy the text specified by [range] into the system clipboard</span><br></pre></td></tr></table></figure><h5 id="vim剪切到系统剪贴板"><a href="#vim剪切到系统剪贴板" class="headerlink" title="vim剪切到系统剪贴板"></a>vim剪切到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;+dd – 剪切一行</span><br><span class="line">从系统剪贴板粘贴到vim</span><br><span class="line">&quot;*p</span><br><span class="line">&quot;+p</span><br><span class="line">Shift+Insert</span><br><span class="line">:put + - Ex command puts contents of system clipboard on a new line</span><br><span class="line">&lt;C-r&gt;+ - From insert mode (or commandline mode)</span><br><span class="line">&quot;+p比 Ctrl-v 命令更好，它可以更快更可靠地处理大块文本的粘贴，也能够避免粘贴大量文本时，发生每行行首的自动缩进累积，因为Ctrl-v是通过系统缓存的stream处理，一行一行地处理粘贴的文本。</span><br></pre></td></tr></table></figure><p>参考：<strong><a href="https://liushiming.cn/article/copy-and-paste-in-vim.html" target="_blank" rel="noopener">一文搞懂vim复制粘贴</a></strong>、<strong><a href="https://blog.csdn.net/jpch89/article/details/93915710" target="_blank" rel="noopener">打开 Ubuntu 18 中 Vim 的系统剪切板功能</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vim" scheme="http://blog.zhangzonglinagain.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>巧记linux常用命令中的递归参数-r(R)和-p</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/</id>
    <published>2021-03-08T18:38:00.000Z</published>
    <updated>2021-03-08T18:39:29.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/longyamiao/article/details/79782254" target="_blank" rel="noopener">巧记linux常用命令中的递归参数-r(R)和-p</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/longyamiao/article/details/79782254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;巧记linux常用命令中的递归参数-r(R)和-p&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux sort uniq命令</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/26/linux-sort-uniq%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/26/linux-sort-uniq%E5%91%BD%E4%BB%A4/</id>
    <published>2021-02-25T19:03:00.000Z</published>
    <updated>2021-02-25T19:03:51.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.linuxjournal.com/content/back-basics-sort-and-uniq" target="_blank" rel="noopener">Back to Basics: Sort and Uniq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.linuxjournal.com/content/back-basics-sort-and-uniq&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Back to Basics: Sort and Uniq&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux 查看登录历史 操作用户</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/26/linux-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E5%8E%86%E5%8F%B2-%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/26/linux-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E5%8E%86%E5%8F%B2-%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7/</id>
    <published>2021-02-25T18:31:00.000Z</published>
    <updated>2021-02-25T18:45:24.291Z</updated>
    
    <content type="html"><![CDATA[<p>linux 查看登录历史 操作用户</p><a id="more"></a><h2 id="linux查看用户登录，操作历史等"><a href="#linux查看用户登录，操作历史等" class="headerlink" title="linux查看用户登录，操作历史等"></a>linux查看用户登录，操作历史等</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">who 命令：显示当前当登录的用户的信息</span><br><span class="line">who -b命令：显示系统最近一次的启动时间</span><br><span class="line">w 命令：显示登录的用户及其当前执行的任务</span><br><span class="line">last 命令：显示当前与过去登录系统的用户的信息</span><br><span class="line">lastb 命令：显示所有登录系统失败的用户的信息</span><br><span class="line">lastlog 命令：显示用户最后一次登录的信息</span><br><span class="line">history 命令：查看操作历史</span><br><span class="line">history -c命令：清除操作历史</span><br><span class="line">pkill -kill -u test ： 强制test用户下线</span><br></pre></td></tr></table></figure><h2 id="linux清除系统日志、历史记录、登录信息"><a href="#linux清除系统日志、历史记录、登录信息" class="headerlink" title="linux清除系统日志、历史记录、登录信息"></a>linux清除系统日志、历史记录、登录信息</h2><h3 id="清楚日志"><a href="#清楚日志" class="headerlink" title="清楚日志"></a>清楚日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;wtmp &#x2F;&#x2F;清除用户登录记录</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;btmp &#x2F;&#x2F;清除尝试登录记录</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;lastlog &#x2F;&#x2F;清除最近登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;syslog &#x2F;&#x2F;记录系统日志的服务</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;xferlog</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;auth.log</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;user.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;adm&#x2F;sylog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;maillog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;openwebmail.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;mail.info</span><br><span class="line">echo&gt;&#x2F;var&#x2F;run&#x2F;utmp</span><br></pre></td></tr></table></figure><h3 id="清除操作过的命令记录"><a href="#清除操作过的命令记录" class="headerlink" title="清除操作过的命令记录"></a>清除操作过的命令记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; .bash_history &#x2F;&#x2F;清除保存的用户操作历史记录</span><br><span class="line">history -cw &#x2F;&#x2F;清除所有历史</span><br></pre></td></tr></table></figure><h3 id="Linux查看History记录加时间戳小技巧"><a href="#Linux查看History记录加时间戳小技巧" class="headerlink" title="Linux查看History记录加时间戳小技巧"></a>Linux查看History记录加时间戳小技巧</h3><p>熟悉bash的都一定知道使用history可以输出你曾经输入过的历史命令，例如  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@servyou_web ~]# history | more</span><br><span class="line">.&#x2F;test.sh</span><br><span class="line">vim test.sh</span><br><span class="line">.&#x2F;test.sh</span><br></pre></td></tr></table></figure><p>但是这里只显示了命令，并没有显示执行命令的时间，因为保存历史命令的~/.bash_history里并没有保存时间。</p><p>通过设置环境变量 export HISTTIMEFORMAT=”%F %T whoami “ 给history加上时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@servyou_web ~]# export HISTTIMEFORMAT&#x3D;&quot;%F %T whoami &quot;</span><br><span class="line">[root@servyou_web ~]# history | tail</span><br><span class="line">2011-06-22 19:17:29 root 15 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 16 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 17 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 18 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 19 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 20 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 21 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:22 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:28 root history | tail</span><br></pre></td></tr></table></figure><p>可以看到，历史命令的时间戳已经加上了，但是.bash_history里并没有加上这个时间戳。其实这个时间记录是保存在当前shell进程内存里的，如果你logout并且重新登录的话会发现你上次登录时执行的那些命令的时间戳都为同一个值，即当时logout时的时间。</p><p>尽管如此，对于加上screen的bash来说，这个时间戳仍然可以长时间有效的，毕竟只要你的server不重启，screen就不会退出，因而这些时间就能长时间保留。你也可以使用echo ‘export HISTTIMEFORMAT=”%F %T whoami “‘ &gt;&gt; /etc/profile 然后source一下就OK。</p><p><a href="https://blog.51cto.com/study2008/2301555" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux 查看登录历史 操作用户&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SkipList (跳跃表)的那点事儿</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</id>
    <published>2021-02-22T18:13:15.000Z</published>
    <updated>2021-02-22T18:13:49.784Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c" target="_blank" rel="noopener">SkipList 的那点事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-22T17:51:27.000Z</published>
    <updated>2021-02-22T17:51:56.236Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yw09041432/p/5908444.html" target="_blank" rel="noopener">七大查找算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yw09041432/p/5908444.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;七大查找算法&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/04/%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/04/%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-03T20:28:32.000Z</published>
    <updated>2021-02-03T20:29:59.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="https://www.kukuxiaai.com/blog/2019-07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/" target="_blank" rel="noopener">数据结构与算法-树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.kukuxiaai.com/blog/2019-07/%E6%95%B0%E6%8D%AE
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>intellij-idea的快捷键</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-12-23T10:35:22.000Z</published>
    <updated>2020-12-23T10:37:11.119Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">Intellij-idea的快捷键</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java中的乱码</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/</id>
    <published>2020-12-08T13:41:00.000Z</published>
    <updated>2020-12-08T13:59:50.602Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a>、<a href="https://blog.csdn.net/u010234516/article/details/52853214" target="_blank" rel="noopener">锟斤拷？UTF-8与GBK互转，为什么会乱码？</a></p><p>附图一张:</p><a id="more"></a><p><img src="/images/crazyCode.jpg" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入分析 Java 中的中文编码问题&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/u010234516/article/details/52853214&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;锟斤拷？UTF-8与GBK互转，为什么会乱码？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附图一张:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="乱码" scheme="http://blog.zhangzonglinagain.xyz/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>websocket --Token Authentication</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/06/07/websocket-Token-Authentication/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/06/07/websocket-Token-Authentication/</id>
    <published>2020-06-07T03:01:52.000Z</published>
    <updated>2020-06-07T04:38:03.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链接：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication" target="_blank" rel="noopener">STOMP–Token Authentication</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;链接：&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framewor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cors--springboot shiro 前后端分离跨域</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-05-18T14:55:00.000Z</published>
    <updated>2020-06-08T12:05:21.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。</p><a id="more"></a><h3 id="跨域的两种方案"><a href="#跨域的两种方案" class="headerlink" title="跨域的两种方案"></a>跨域的两种方案</h3><h4 id="沿用Cookie"><a href="#沿用Cookie" class="headerlink" title="沿用Cookie"></a>沿用Cookie</h4><p>沿用传统的cookie session方式，就需要前后端分别设置，可以让前端的request带上后端域名对应的cookie</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>客户端需要设置Ajax请求属性withCredentials 为true，让Ajax请求都带上Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">           url:url,</span><br><span class="line">           type:&quot;GET&quot;,</span><br><span class="line">           xhrFields:&#123;</span><br><span class="line">               withCredentials:true</span><br><span class="line">           &#125;,</span><br><span class="line">           success:function(res)&#123; </span><br><span class="line">               console.log(res);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>首先服务端在使用cors协议时需要设置响应消息头<em>Access-Control-Allow-Credentials<em>的值为</em>true*，即允许在ajax访问时携带cookie(如上，前端也要设置withCredentials为true)。另外为了安全，在cors标准里不允许Access-Control-Allow-Origin设置为</em>,而是必须指定明确的、与请求网页一致的域名，cookie也依然遵循“同源策略”，只有用目标服务器域名设置的cookie才会上传，而且使用document.cookie也无法读取目标服务器域名下的cookie。接下来我们来看看实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">]</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)     &#x2F;&#x2F; 此时，不允许为*</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">&#x2F;&#x2F;            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义http-header"><a href="#自定义http-header" class="headerlink" title="自定义http header"></a>自定义http header</h4><p>绕过cookie，自定义http header传输token(本项目token即sessionId)，这种方式适合前端不支持cookie的时候，具体设置在后文中。</p><h3 id="session管理"><a href="#session管理" class="headerlink" title="session管理"></a>session管理</h3><p>采用第二种方式，就需要绕过传统的sessionid传输方式：通过请求头里的cookie传输（浏览器的cookie是跟着域名走的）。客户端登录，服务端通过JSON返回sessionid，客户端保存，后续每次请求要在请求头中添加加token字段，服务端shiro根据请求头的token字段获取sessionid。<br>shiroConfiguration中的securityManager配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        manager.sessionManager &#x3D; sessionManager()</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun sessionManager(): SessionManager? &#123;</span><br><span class="line">        val mySessionManager &#x3D; MySessionManager()</span><br><span class="line">        mySessionManager.setSessionDAO(sessionDAO())</span><br><span class="line">        return mySessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是在MySessionManager里重写DefaultWebSessionManager的getSessionId方法和retrieveSession方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.apache.shiro.session.Session</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey</span><br><span class="line">import org.apache.shiro.web.servlet.ShiroHttpServletRequest</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line">import org.apache.shiro.web.util.WebUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import java.io.Serializable</span><br><span class="line">import java.lang.Boolean</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class MySessionManager : DefaultWebSessionManager&#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var log &#x3D; LoggerFactory.getLogger(this.javaClass.name)</span><br><span class="line">        private val AUTHORIZATION &#x3D; &quot;auth-token&quot;</span><br><span class="line">        private val HEADER_SESSION_ID_SOURCE &#x3D; &quot;header request&quot;</span><br><span class="line">        private val MY_SESSION_ATTRIBUTE &#x3D; &quot;MY_SESSION_ATTRIBUTE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override fun getSessionId(request: ServletRequest, response: ServletResponse?): Serializable? &#123;</span><br><span class="line">        val id &#x3D; WebUtils.toHttp(request).getHeader(AUTHORIZATION)</span><br><span class="line">        &#x2F;&#x2F;如果请求头中有 Authorization 字段， 则其值为sessionId</span><br><span class="line">        return if (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, HEADER_SESSION_ID_SOURCE)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE)</span><br><span class="line">            id</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;否则按默认规则从cookie取sessionId</span><br><span class="line">            super.getSessionId(request, response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(UnknownSessionException::class)</span><br><span class="line">    protected override fun retrieveSession(sessionKey: SessionKey?): Session? &#123;</span><br><span class="line">        val sessionId &#x3D; getSessionId(sessionKey) ?: return null</span><br><span class="line">        val request: ServletRequest &#x3D; WebUtils.getRequest(sessionKey)</span><br><span class="line">        return if (request.getAttribute(MY_SESSION_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">            log.debug(&quot;Get Session from request!&quot;)</span><br><span class="line">            request.getAttribute(MY_SESSION_ATTRIBUTE) as Session</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Get Session from redis!&quot;)</span><br><span class="line">            val s: Session &#x3D; retrieveSessionFromDataSource(sessionId)</span><br><span class="line">            if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;session ID was provided, meaning one is expected to be found, but we couldn&#39;t find one:</span><br><span class="line">                val msg &#x3D; &quot;Could not find session with ID [$sessionId]&quot;</span><br><span class="line">                throw UnknownSessionException(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            request.setAttribute(MY_SESSION_ATTRIBUTE, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>  对于简单请求，浏览器直接在ruquest头之中，增加一个Origin字段，相应地，服务器会在response头中添加Access-Control-Allow-Origin等字段，如此便是一次成功的跨域请求。</p><p><img src="/images/pasted-24.png" alt="upload successful"><br>只要同时满足以下两大条件，就属于简单请求。</p><p>请求方法是以下三种方法之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure><p>HTTP的头信息不超出以下几种字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight），预检的请求方法（Request Method）为OPTION。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义过滤器，针对请求头中有Origin字段的，response头中添加相应字段，针对OPITION请求,response返回200状态码。<br>新建CorsFilter类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.http.HttpStatus</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod</span><br><span class="line">import javax.servlet.*</span><br><span class="line">import javax.servlet.http.HttpServletRequest</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@WebFilter(urlPatterns &#x3D; arrayOf(&quot;&#x2F;*&quot;),filterName &#x3D; &quot;crosFilter&quot;)</span><br><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">            logger.info(&quot;处理跨域请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立WebFilterConfig类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean</span><br><span class="line">import org.springframework.context.annotation.Bean</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import javax.servlet.Filter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1：自定义过滤器，可以采取Filter加@WebFilter和启动类加@ServletComponentScan的方式，过滤器的执行顺序按照类名排序</span><br><span class="line"> * 故而采用如下FilterRegistrationBean的方式，可以自定义顺序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">class WebFilterConfig&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun crosResFilter(): FilterRegistrationBean&lt;*&gt;? &#123;</span><br><span class="line">        val filterRegistrationBean: FilterRegistrationBean&lt;Filter?&gt; &#x3D; FilterRegistrationBean&lt;Filter?&gt;()</span><br><span class="line">        val corsFilter &#x3D; CorsFilter()</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter)</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;) &#x2F;&#x2F;配置过滤规则</span><br><span class="line">        filterRegistrationBean.setName(&quot;corsFilter&quot;) &#x2F;&#x2F;设置过滤器名称</span><br><span class="line">        filterRegistrationBean.order &#x3D; 1 &#x2F;&#x2F;执行次序</span><br><span class="line">        return filterRegistrationBean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此便能愉快的跨域访问了。</p><h3 id="shiro跳转"><a href="#shiro跳转" class="headerlink" title="shiro跳转"></a>shiro跳转</h3><p>由于shiro对前后端分离支持不是很理想，如访问需认证的路径，若未登录会直接跳转至登录页面（默认是/login.jsp），这中情况我们需要直接返回未认证的JSON数据，由前端控制路由。<br>新建MyFormAuthenticationFilter，继承shiro的FormAuthenticationFilter（对应过滤authc的路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.JsonUtils</span><br><span class="line">import com.example.customer.util.constants.ErrorEnum</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line">class MyFormAuthenticationFilter : FormAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val log &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun onAccessDenied(request: ServletRequest?, response: ServletResponse?): Boolean &#123;</span><br><span class="line">        return if (isLoginRequest(request, response)) &#123;</span><br><span class="line">            if (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                executeLogin(request, response)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login page view.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;allow them to see the login page ;)</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var resp &#x3D; response as HttpServletResponse</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +</span><br><span class="line">                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不再跳转，直接返回Json信息</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.getWriter().write(JsonUtils.errorJson(ErrorEnum.E_401).toString())</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在shiro过滤链中，添加自定义过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class ShiroConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * shiro过滤器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun shiroFilter(manager: SecurityManager) : ShiroFilterFactoryBean&#123;</span><br><span class="line">        val factoryBean &#x3D; ShiroFilterFactoryBean()</span><br><span class="line">        &#x2F;&#x2F;设置securityManager</span><br><span class="line">        factoryBean.securityManager &#x3D; manager</span><br><span class="line">        &#x2F;&#x2F;自定义过滤器,修改认证失败跳转</span><br><span class="line">        val filters &#x3D; mutableMapOf&lt;String,Filter&gt;()</span><br><span class="line">        filters.put(&quot;myauthc&quot;,myFormAuthenticationFilter())</span><br><span class="line">        factoryBean.filters &#x3D;  filters</span><br><span class="line"></span><br><span class="line">        val filterChainDefinitionMap: MutableMap&lt;String, String&gt; &#x3D; LinkedHashMap()</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;static&#x2F;**&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 静态资源匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;doLogin&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;logout&quot;] &#x3D; &quot;logout&quot; &#x2F;&#x2F; 用户退出，只需配置logout即可实现该功能</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;**&quot;] &#x3D; &quot;myauthc&quot; &#x2F;&#x2F; 其他路径均需要身份认证，一般位于最下面，优先级最低</span><br><span class="line">        &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面</span><br><span class="line">        &#x2F;&#x2F;身份认证失败，不直接Shiro跳转至默认登录页，而是跳转至未认证接口，返回Json数据，前后端分离中登录界面跳转应由前端路由控制</span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F; factoryBean.setLoginUrl(&quot;&#x2F;login&#x2F;unauth&quot;);</span><br><span class="line">        &#x2F;&#x2F; 权限认证失败，跳转后续处理</span><br><span class="line"> &#x2F;&#x2F;       factoryBean.setUnauthorizedUrl(&quot;&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap)</span><br><span class="line"></span><br><span class="line">        return factoryBean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private fun myFormAuthenticationFilter(): MyFormAuthenticationFilter&#123;</span><br><span class="line">        return MyFormAuthenticationFilter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *securityManager配置</span><br><span class="line">     * 不指定名字的话，自动创建一个方法名第一个字母小写的bean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/shiro/"/>
    
      <category term="springboot" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/shiro/springboot/"/>
    
    
      <category term="cors" scheme="http://blog.zhangzonglinagain.xyz/tags/cors/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglinagain.xyz/tags/shiro/"/>
    
      <category term="spring boot" scheme="http://blog.zhangzonglinagain.xyz/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 构造函数</title>
    <link href="http://blog.zhangzonglinagain.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.zhangzonglinagain.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-17T06:28:00.000Z</published>
    <updated>2020-05-17T06:51:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.cnblogs.com/Jetictors/p/7758828.html" target="_blank" rel="noopener">Kotlin——中级篇（一）：类（class）详解</a></strong>、<strong><a href="https://www.jianshu.com/p/5db34354d812" target="_blank" rel="noopener">kotlin之构造函数(constructor)</a></strong><br>1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。</p><p>2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派</p><a id="more"></a><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test constructor(num: Int)&#123;</span><br><span class="line">    constructor(num : Int, num2: Int) : this(num) &#123;</span><br><span class="line">        println(num + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：二级构造函数中的参数1(num)，是委托了主构造函数的参数num。</span><br></pre></td></tr></table></figure><p>3、在JVM上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。<br>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Jetictors/p/7758828.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin——中级篇（一）：类（class）详解&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/5db34354d812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin之构造函数(constructor)
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。&lt;/p&gt;
&lt;p&gt;2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglinagain.xyz/tags/kotlin/"/>
    
  </entry>
  
</feed>
