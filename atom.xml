<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglinagain.xyz/"/>
  <updated>2021-04-19T17:01:55.765Z</updated>
  <id>http://blog.zhangzonglinagain.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu 桌面死机(重启gnome-shell)</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/19/ubuntu-%E6%A1%8C%E9%9D%A2%E6%AD%BB%E6%9C%BA/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/19/ubuntu-%E6%A1%8C%E9%9D%A2%E6%AD%BB%E6%9C%BA/</id>
    <published>2021-04-19T10:54:00.000Z</published>
    <updated>2021-04-19T17:01:55.765Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu有时桌面会卡死，鼠标点击失灵，解决方法：重启gnome-shell。<br>建议以下两种二选一：</p><ul><li><span style="color:red">alt + F2</span>  弹出的输入框里输入小写<span style="color:red">r</span> ，回车，如此重启gnome-shell桌面环境。</li><li><span style="color:red">ctrl + alt + F3</span> 切换到其它虚拟终端tty3(Ubuntu18.04 默认tty1是选择用户登录界面，tty2往往就是对应卡死的桌面位置，我们选择tty3进行操作)，输入用户密码登录，输入<span style="color:red">ps -ef|grep gnome-shell</span> ，找到tty2对应的gnome-shell pid（一般有两个，一个是tty1的，一个是tty2的），<span style="color:red">kill -9 pidNum</span> ，系统自动重启gnome-shell,最后<span style="color:red">crl + alt +F2</span> 切换至tty2,这种方法的优点是不会干扰其他正在运行的程序。<a id="more"></a>其他方法还有（未验证）：</li></ul><h3 id="How-to-restart-GUI-on-Ubuntu-20-04-step-by-step-instructions"><a href="#How-to-restart-GUI-on-Ubuntu-20-04-step-by-step-instructions" class="headerlink" title="How to restart GUI on Ubuntu 20.04 step by step instructions"></a>How to restart GUI on Ubuntu 20.04 step by step instructions</h3><p>Sometimes you many need to restart/reload GUI because you may have done some changes which require it. However, occasionally you are forced to restart GUI because it froze and you do not wish to restart the entire system. In any case you might find some of the bellow information helpful.</p><h4 id="The-first-method-is-the-least-destructing-however-it-might-not-provide-the-expected-result"><a href="#The-first-method-is-the-least-destructing-however-it-might-not-provide-the-expected-result" class="headerlink" title="The first method is the least destructing, however, it might not provide the expected result."></a>The first method is the least destructing, however, it might not provide the expected result.</h4><p>Enter a restart gui Command</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p>While logged in to your GNOME desktop press <span style="color:red">ALT + F2</span> key combination. Into the Enter a Command box type <span style="color:red">r </span> and press <span style="color:red">Enter</span> .</p><h4 id="Another-alternative-to-do-the-GUI-restart-trick-might-be-the-most-obvious-to-simply-re-login"><a href="#Another-alternative-to-do-the-GUI-restart-trick-might-be-the-most-obvious-to-simply-re-login" class="headerlink" title="Another alternative to do the GUI restart trick might be the most obvious to simply re-login."></a>Another alternative to do the GUI restart trick might be the most obvious to simply re-login.</h4><p><img src="/images/pasted-37.png" alt="upload successful"><br>Restart GUI by first Log Out and consequently Log In to your GUI desktop</p><h4 id="In-this-scenario-we-simply-restart-the-gnome-shell-as-non-privileged-user"><a href="#In-this-scenario-we-simply-restart-the-gnome-shell-as-non-privileged-user" class="headerlink" title="In this scenario we simply restart the gnome-shell as non-privileged user."></a>In this scenario we simply restart the gnome-shell as non-privileged user.</h4><p><img src="/images/pasted-38.png" alt="upload successful"><br>Open up terminal and enter the <span style="color:red">gnome-shell –replace </span>command.</p><h4 id="The-following-restart-GUI-solution-is-guaranteed-to-restart-your-desktop-even-if-your-GUI-froze-while-the-system-is-still-functioning-However-it-needs-administrative-sudo-privileges"><a href="#The-following-restart-GUI-solution-is-guaranteed-to-restart-your-desktop-even-if-your-GUI-froze-while-the-system-is-still-functioning-However-it-needs-administrative-sudo-privileges" class="headerlink" title="The following restart GUI solution is guaranteed to restart your desktop even if your GUI froze while the system is still functioning. However, it needs administrative sudo privileges."></a>The following restart GUI solution is guaranteed to restart your desktop even if your GUI froze while the system is still functioning. However, it needs administrative sudo privileges.</h4><p><img src="/images/pasted-39.png" alt="upload successful"><br>Either enter the <span style="color:red">sudo systemctl restart systemd-logind.service </span>command directly into the terminal while in GUI. However, if your GUI is frozen you may need to first change to TTY console using <span style="color:red">CTRL + ALT + F2</span>, login and execute command from there.</p><h4 id="In-this-method-we-will-restart-the-Display-Manager-which-will-consequently-also-restart-GNOME-shell"><a href="#In-this-method-we-will-restart-the-Display-Manager-which-will-consequently-also-restart-GNOME-shell" class="headerlink" title="In this method we will restart the Display Manager which will consequently also restart GNOME shell."></a>In this method we will restart the Display Manager which will consequently also restart GNOME shell.</h4><p><img src="/images/pasted-40.png" alt="upload successful"><br>Either from GUI and TTY console <span style="color:red">CTRL + ALT + F2</span> execute <span style="color:red">sudo systemctl restart gdm</span> command. However, if you have deployed LightDM display manager in that case execute<span style="color:red"> sudo systemctl restart lightdm</span> command.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ubuntu有时桌面会卡死，鼠标点击失灵，解决方法：重启gnome-shell。&lt;br&gt;建议以下两种二选一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;alt + F2&lt;/span&gt;  弹出的输入框里输入小写&lt;span style=&quot;color:red&quot;&gt;r&lt;/span&gt; ，回车，如此重启gnome-shell桌面环境。&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;ctrl + alt + F3&lt;/span&gt; 切换到其它虚拟终端tty3(Ubuntu18.04 默认tty1是选择用户登录界面，tty2往往就是对应卡死的桌面位置，我们选择tty3进行操作)，输入用户密码登录，输入&lt;span style=&quot;color:red&quot;&gt;ps -ef|grep gnome-shell&lt;/span&gt; ，找到tty2对应的gnome-shell pid（一般有两个，一个是tty1的，一个是tty2的），&lt;span style=&quot;color:red&quot;&gt;kill -9 pidNum&lt;/span&gt; ，系统自动重启gnome-shell,最后&lt;span style=&quot;color:red&quot;&gt;crl + alt +F2&lt;/span&gt; 切换至tty2,这种方法的优点是不会干扰其他正在运行的程序。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="gnome-shell" scheme="http://blog.zhangzonglinagain.xyz/tags/gnome-shell/"/>
    
  </entry>
  
  <entry>
    <title>markdown的html标签应用</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/19/markdown%E5%86%85%E5%AE%B9%E6%8A%98%E5%8F%A0/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/19/markdown%E5%86%85%E5%AE%B9%E6%8A%98%E5%8F%A0/</id>
    <published>2021-04-19T06:59:00.000Z</published>
    <updated>2021-04-19T07:38:15.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Markdown 是一种轻量级标记语言，非常适合网络书写。同时，Markdown支持嵌入html标签，我们就可以借此实现markdown不具有的某些功能，如代码折叠和文字样式等。</p><a id="more"></a><h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;</span><br><span class="line">  &lt;font color&#x3D;&quot;#0000ff&quot; &gt;点击时的区域标题：点击查看详细内容&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;&#x2F;summary&gt;</span><br><span class="line">  &lt;p&gt; - 测试 测试测试&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt;  title，value，callBack可以缺省  &lt;&#x2F;code&gt;  &lt;&#x2F;pre&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure><ul><li><p>summary：折叠语法展示的摘要</p></li><li><p>details：折叠语法标签</p></li><li><p>pre：以原有格式显示元素内的文字是已经格式化的文本。</p></li><li><p>blockcode：表示程序的代码块。</p></li><li><p>code：指定代码范例。</p></li></ul><p>效果如下：</p><details>  <summary><font color="#0000ff">点击时的区域标题：点击查看详细内容</font></summary>  <p> - 测试 测试测试</p>  <pre><code>  title，value，callBack可以缺省  </code>  </pre></details><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&#39;color:red&#39;&gt;This is red&lt;&#x2F;span&gt;   &#x2F;&#x2F;字体颜色</span><br><span class="line">&lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;&#x2F;rt&gt; &lt;&#x2F;ruby&gt; &#x2F;&#x2F; 特殊字</span><br><span class="line">&lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;F9&lt;&#x2F;kbd&gt;  &#x2F;&#x2F; 按键标识</span><br><span class="line">&lt;span style&#x3D;&quot;font-size:2rem; background:yellow;&quot;&gt;**Bigger**&lt;&#x2F;span&gt; &#x2F;&#x2F;字体大小和背景</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot; color&#x3D;&quot;red&quot; size&#x3D;&quot;6&quot;&gt;字体及字体颜色和大小&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;&quot;#0000ff&quot;&gt;字体颜色&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;p align&#x3D;&quot;left&quot;&gt;居左文本&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;center&quot;&gt;居中文本&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;right&quot;&gt;居右文本&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>使用span或者font标签，同时用style属性控制样式。</p><p>效果如下：<br><span style="color:red">This is red</span>   //字体颜色</p><p><ruby> 漢 <rt> ㄏㄢˋ </rt> </ruby> // 特殊字</p><p><kbd>Ctrl</kbd>+<kbd>F9</kbd>  // 按键标识</p><p><span style="font-size:2rem; background:yellow;"><strong>Bigger</strong></span> //字体大小和背景</p><p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font></p><p><font color="#0000ff">字体颜色</font></p><p align="left">居左文本</p><p align="center">居中文本</p><p align="right">居右文本</p><p>参考来源：<br><strong><a href="https://www.cnblogs.com/buwuliao/p/9578918.html" target="_blank" rel="noopener">【MarkDown】使用Html样式和折叠语法</a></strong>、<br><strong><a href="http://connorlin.github.io/2016/05/06/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93)/" target="_blank" rel="noopener">Markdown的常用语法(个人总结) | ConnorLin’s Blog </a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Markdown 是一种轻量级标记语言，非常适合网络书写。同时，Markdown支持嵌入html标签，我们就可以借此实现markdown不具有的某些功能，如代码折叠和文字样式等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://blog.zhangzonglinagain.xyz/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-19T06:49:00.000Z</published>
    <updated>2021-04-24T11:04:19.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux常用的命令，随时添加。</p><a id="more"></a><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>The type command is used to display information about the command type. It will show you how a given command would be interpreted if typed on the command line.<br>一般情况下，type命令被用于判断另外一个命令是否是内置命令，但是它实际上有更多的用法。  </p><ol><li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是：</p><blockquote><p>type ls 的输出是 ls 是 `ls –color=auto&#39; 的别名</p></blockquote><blockquote><p>type if 的输出是 if 是 shell 关键字</p></blockquote><blockquote><p>type type 的输出是 type 是 shell 内嵌</p></blockquote><blockquote><p>type frydsh 的输出是 bash: type: frydsh: 未找到</p></blockquote></li></ol><ol start="2"><li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是的另一种方法（适用于脚本编程）：</p><blockquote><p>type -t ls 的输出是 alias</p></blockquote><blockquote><p>type -t if 的输出是 keyword</p></blockquote><blockquote><p>type -t type 的输出是 builtin</p></blockquote><blockquote><p>type -t gedit 的输出是 file</p></blockquote><blockquote><p>type -t frydsh 没有输出</p></blockquote></li><li><p>显示一个名字的所有可能：</p><blockquote><p>type -a kill 的输出是 kill 是 shell 内嵌 和 kill 是 /bin/kill</p></blockquote><blockquote><p>type -at kill 的输出是 builtin 和 file</p></blockquote></li><li><p>查看一个命令的执行路径（如果它是外部命令的话）：</p><blockquote><p>type -p gedit 的输出是 /usr/bin/gedit</p></blockquote><blockquote><p>type -p kill 没有输出（因为kill是内置命令）</p></blockquote></li></ol><ol start="5"><li><p>强制搜索外部命令：</p><blockquote><p>type -P kill 的输出是 /bin/kill</p></blockquote></li></ol><h3 id="ll-amp-ls"><a href="#ll-amp-ls" class="headerlink" title="ll&amp;ls"></a>ll&amp;ls</h3><p>ll is aliased to &#39;ls -alF&#39;<br><img src="/images/pasted-35.png" alt="upload successful"></p><p>ls 几个重要参数：</p><ul><li>-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul><p>详细参数ls –help 查看。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><p>查看，其中-S sort by file size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -Sl 由大到小排序</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -Slr 从小到大排序</span><br></pre></td></tr></table></figure><p>-h，表示”–human-readable”，单位是k或者M ，比较容易看清楚结果。</p><p>显示子目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -R</span><br></pre></td></tr></table></figure><p>ls按时间排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -lt 从新到旧</span><br><span class="line">ls -lrt 从旧到新</span><br></pre></td></tr></table></figure><p>参考：<strong><u><a href="https://linux.cn/article-5109-1.html" target="_blank" rel="noopener">Linux中的15个基本‘ls’命令示例</a></u></strong></p><h3 id="xdg-open"><a href="#xdg-open" class="headerlink" title="xdg-open"></a>xdg-open</h3><p>有时需要从terminal打开doc pdf jpg等文件，可以用xdg-open命令。</p><p>xdg-open command in the Linux system is used to open a file or URL in the user’s preferred application.<br>The URL will be opened in the user’s preferred web browser if a URL is provided. The file will be opened in the preferred application for files of that type if a file is provided. xdg-open supports ftp, file, https and http URLs. This can be used inside a desktop session only. It is not recommended to use xdg-open as root. Here, the zero is an indication of success while non-zero show the failure.</p><p>Syntax:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdg-open &#123;file | URL&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-uniq"><a href="#sort-uniq" class="headerlink" title="sort uniq"></a>sort uniq</h3><p>字如其义：排序和去重</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>sort</strong> - sort lines of text files(对文本文件的行进行排序)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将它们按升序输出。</span><br></pre></td></tr></table></figure><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p><strong>OPTION:</strong></p><ul><li>-u,–unique :去重</li><li>-r,–reverse :降序排列，不加sort命令默认升序</li><li>-o, –output=FILE :将排序结果保存至文件中，也可使用重定向工具</li><li>-n, –numeric-sort :根据数值排序</li><li>-t, –field-separator=SEP :指定特定分隔符，默认以空格为分隔符。与cut -d一样一样的</li><li>-k, –key=KEYDEF :指定特定列做为排序，默认忽略开头空白字符。与cut -f一样一样的。</li><li>-M, –month-sort :根据月份进行排序，支持英文缩写格式:Jan</li><li>-b, –ignore-leading-blanks :忽略每一行前面的所有空白部分，从第一个可见字符开始比较</li><li>-f, –ignore-case :忽略大小写<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&#39;|&#39; &#39;&#123;print $2&#125;&#39; nginx_access.log | uniq -c  | sort -n -r | head -n 10   #查询访问次数前10的ip地址。uniq -c 表示统计各行在文件中出现的次数</span><br><span class="line">   2582 120.26.40.76</span><br><span class="line">    826 120.26.40.76</span><br><span class="line">    716 120.26.40.76</span><br><span class="line">    525 120.26.40.76</span><br><span class="line">    424 120.26.40.76</span><br><span class="line">    325 120.26.40.76</span><br><span class="line">    235 120.26.40.76</span><br><span class="line">    233 120.26.40.76</span><br><span class="line">    226 120.26.40.76</span><br><span class="line">    120 120.26.40.76</span><br></pre></td></tr></table></figure></li></ul><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p><strong>uniq</strong> - report or omit repeated lines(报告或省略重复的行)</p><p>描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq 命令删除文件中的重复行。uniq 命令读取由 InFile 参数指定的标准输入或文件。该命令首先比较相邻的行，然后除去第二行和该行的后续副本。重复的行一定相邻。（在发出 uniq 命令之前，请使用 sort 命令使所有重复行相邻。uniq命令这种方式估计是想节省系统资源）最后，uniq 命令将最终单独的行写到标准输出或由 OutFile 参数指定的文件。InFile 和 OutFile 参数必须指定不同的文件。</span><br></pre></td></tr></table></figure><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq [OPTION]... [InFile [OutFile]]</span><br></pre></td></tr></table></figure><p><strong>OPTION:</strong></p><ul><li>-c :在输出行前面加上每行在文件中出现的次数</li><li>-d :仅显示重复行</li><li>-u :仅显示不重复的行</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ cat fruit.txt </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">apple</span><br><span class="line">$ uniq fruit.txt  #可以看到apple不是邻近的，所以无法去重</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">apple</span><br><span class="line">$ uniq -d fruit.txt   </span><br><span class="line">$</span><br><span class="line">$ sort fruit.txt   #先排序，将相同的行安排在一起</span><br><span class="line">apple</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange    </span><br><span class="line">$ sort fruit.txt | uniq  #排序后，去重</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ awk -F&#39;|&#39; &#39;&#123;print $2&#125;&#39;nginx_access.log | sort -n  |uniq -c | sort -n | tail -n 10     #只有先sort后在uniq才能生效</span><br><span class="line">     28 122.192.13.58</span><br><span class="line">     31 183.212.188.57</span><br><span class="line">     31 223.104.4.82</span><br><span class="line">     35 223.104.4.61</span><br><span class="line">     36 112.20.81.240</span><br><span class="line">     71 183.209.48.38</span><br><span class="line">     86 122.96.43.243</span><br><span class="line">    216 183.208.16.53</span><br><span class="line">    616 49.77.231.174</span><br><span class="line">   6268 120.26.40.76</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>uniq必须得和sort一起使用才能够达到所需要的结果。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><strong><a href="https://www.linuxjournal.com/content/back-basics-sort-and-uniq" target="_blank" rel="noopener">Back to Basics: Sort and Uniq</a></strong></p><h3 id="tar-amp-gzip"><a href="#tar-amp-gzip" class="headerlink" title="tar&amp;gzip"></a>tar&amp;gzip</h3><p>Linux下常见的压缩包格式有5种:zip tar.gz tar.bz2 tar.xz tar.Z</p><p>其中tar是种打包格式,gz和bz2等后缀才是指代压缩方式:gzip和bzip2。</p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>The Linux “tar” stands for tape archive, which is used by large number of Linux/Unix system administrators to deal with tape drives backup. </p><p><strong>OPTION:</strong></p><ul><li>c – create a archive file.</li><li>x – extract a archive file.</li><li>v – show the progress of archive file.</li><li>f – filename + of archive file.</li><li>t – viewing content of archive file.</li><li>j  – filter archive through bzip2.</li><li>z – filter archive through gzip.</li><li>r – append or update files or directories to existing archive file.</li><li>W – Verify a archive file.</li><li>wildcards – Specify patterns in unix tar command.</li></ul><p>其中j,z参数代表在压缩时需要注意选择压缩格式。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. Create tar Archive File</span><br><span class="line"></span><br><span class="line"> tar -cvf tecmint-14-09-12.tar &#x2F;home&#x2F;tecmint&#x2F;</span><br><span class="line"> </span><br><span class="line">2. Create tar.gz Archive File</span><br><span class="line"></span><br><span class="line">tar cvzf MyImages-14-09-12.tar.gz &#x2F;home&#x2F;MyImages</span><br><span class="line"></span><br><span class="line">3. Create tar.bz2 Archive File</span><br><span class="line"></span><br><span class="line"> tar cvfj Phpfiles-org.tar.bz2 &#x2F;home&#x2F;php</span><br></pre></td></tr></table></figure><p>事实上, <span style="color:red">从1.15版本开始tar就可以自动识别压缩的格式</span>,故不需人为区分压缩格式就能正确解压或者查看里面的内容。如解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf filename.tar</span><br><span class="line">tar -xvf filename.tar.gz  </span><br><span class="line">tar -xvf filename.tar.bz2  </span><br><span class="line">tar -xvf filename.tar.xz  </span><br><span class="line">tar -xvf filename.tar.Z</span><br></pre></td></tr></table></figure><p>抑或查看打包内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf filename.tar</span><br><span class="line">tar -tvf filename.tar.gz  </span><br><span class="line">tar -tvf filename.tar.bz2  </span><br><span class="line">tar -tvf filename.tar.xz  </span><br><span class="line">tar -tvf filename.tar.Z</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>Gzip is one of the most popular compression algorithms that allow you to reduce the size of a file and keep the original file mode, ownership, and timestamp.</p><p>Gzip also refers to the .gz file format and the gzip utility which is used to compress and decompress files.</p><p>In this tutorial, we will show you how to use the gzip command.</p><h5 id="gzip-Command-Syntax"><a href="#gzip-Command-Syntax" class="headerlink" title="gzip Command Syntax"></a>gzip Command Syntax</h5><p>The general syntax for the gzip command is as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><p>Gzip compresses only single files and creates a compressed file for each given file. By convention, the name of a file compressed with Gzip should end with either .gz or .z.</p><p>If you want to compress multiple files or directory into one file, first you need to create a Tar archive and then compress the .tar file with Gzip. A file that ends in .tar.gz or .tgz is a Tar archive compressed with Gzip.</p><p>Gzip is most often used to compress text files, Tar archives, and web pages. <span style="color:red">Do not use Gzip to compress images, audio, PDF documents, and other binary files as they are already compressed</span>.</p><p><em>gzip</em> can compress only regular files. The <em>symbolic links</em> are ignored.</p><h5 id="Compressing-Files-with-gzip"><a href="#Compressing-Files-with-gzip" class="headerlink" title="Compressing Files with gzip"></a>Compressing Files with gzip</h5><p>To compress a single file invoke the gzip command followed by the filename:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip filename</span><br></pre></td></tr></table></figure><p>gzip will create a file filename.gz and delete the original file.</p><p>By default, gzip keeps the original file timestamp, mode, ownership, and name in the compressed file.</p><p>Keep the original file<br>If you want to keep the input (original) file, use the -k option:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -k filename</span><br></pre></td></tr></table></figure><p>Another option to keep the original file is to use the -c option which tells gzip to write on standard output and redirect the output to a file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -c filename &gt; filename.gz</span><br></pre></td></tr></table></figure><h5 id="Verbose-output"><a href="#Verbose-output" class="headerlink" title="Verbose output"></a>Verbose output</h5><p>Use the -v option if you want to see the percentage reduction and the names of the files that are being processed:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -v filename</span><br></pre></td></tr></table></figure><p>filename:      7.5% – replaced with filename.gz</p><h5 id="Compress-multiple-files"><a href="#Compress-multiple-files" class="headerlink" title="Compress multiple files"></a>Compress multiple files</h5><p>You can also pass multiple files as arguments to the command. For example, to compress the files named file1, file2, file3, you would run the following command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip file1 file2 file3</span><br></pre></td></tr></table></figure><p>The command above will create three compressed files, file1.gz, file2.gz, file3.gz.</p><h5 id="Compress-all-files-in-a-directory"><a href="#Compress-all-files-in-a-directory" class="headerlink" title="Compress all files in a directory"></a>Compress all files in a directory</h5><p>To compress all files in a given directory, use the -r option:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r directory</span><br></pre></td></tr></table></figure><p><em>gzip</em> will recursively traverse through the whole directory structure and compress all the files in the directory and it’s subdirectories.</p><h5 id="Change-the-compression-level"><a href="#Change-the-compression-level" class="headerlink" title="Change the compression level"></a>Change the compression level</h5><p>gzip allows you to specify a range of compression levels, from 1 to 9. -1 or –fast means fastest compression speed with minimal compression ratio, -9 or –best indicates the slowest compression speed with maximum compression ratio. The default compression level is -6.</p><p>For example, to get maximum compression, you would run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -9 filename</span><br></pre></td></tr></table></figure><p>Compression is a CPU-intensive task, the higher the compression level, the longer the process takes.</p><h5 id="Using-standard-input"><a href="#Using-standard-input" class="headerlink" title="Using standard input"></a>Using standard input</h5><p>To create a .gz file from the stdin, pipe the output of the command to gzip. For example, to create a Gzipped MySQL database backup you would run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump database_name | gzip -c &gt; database_name.sql.gz</span><br></pre></td></tr></table></figure><p>The output of the mysqldump command will be input for gzip.</p><h5 id="Decompressing-Files-with-gzip"><a href="#Decompressing-Files-with-gzip" class="headerlink" title="Decompressing Files with gzip"></a>Decompressing Files with gzip</h5><p>To decompress a .gz file , use the -d option:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d filename.gz</span><br></pre></td></tr></table></figure><p>Another command that you can use to decompress a Gzip file is gunzip . This command is basically an alias to gzip -d:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip filename.gz</span><br></pre></td></tr></table></figure><p>You might find it easier to remember gunzip than gzip -d.</p><h5 id="Keep-the-compressed-file"><a href="#Keep-the-compressed-file" class="headerlink" title="Keep the compressed file"></a>Keep the compressed file</h5><p>Same as when compressing a file, the -k option tells gzip to keep the input file, in this case, that is the compressed file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dk filename.gz</span><br></pre></td></tr></table></figure><h5 id="Decompress-multiple-files"><a href="#Decompress-multiple-files" class="headerlink" title="Decompress multiple files"></a>Decompress multiple files</h5><p>To decompress multiple files at once pass the filenames to gzip as arguments:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file1.gz file2.gz file3.gz</span><br></pre></td></tr></table></figure><h5 id="Decompress-all-files-in-a-directory"><a href="#Decompress-all-files-in-a-directory" class="headerlink" title="Decompress all files in a directory"></a>Decompress all files in a directory</h5><p>When used with -d and -r options, gzip decompresses all files in a given directory recursively:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dr directory</span><br></pre></td></tr></table></figure><h5 id="List-the-Compressed-File-Contents"><a href="#List-the-Compressed-File-Contents" class="headerlink" title="List the Compressed File Contents"></a>List the Compressed File Contents</h5><p>When used with the -l option, gzip shows statistics about the given compressed files:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l filename</span><br></pre></td></tr></table></figure><p>The output will include the uncompressed file name, the compressed and uncompressed size, and the compression ratio:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">       130                 107   7.5% filename</span><br></pre></td></tr></table></figure><p>To get more information, add the -v option:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip -lv filename</span><br><span class="line">method  crc     date  time           compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">defla a9b9e776 Sep  3 21:20                 130                 107   7.5% filename</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;linux常用的命令，随时添加。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux小技巧</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/16/linux%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/16/linux%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2021-04-16T07:17:00.000Z</published>
    <updated>2021-04-19T09:47:03.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux小技巧"><a href="#linux小技巧" class="headerlink" title="linux小技巧"></a>linux小技巧</h3><p>linux有用的小技巧，随时添加。</p><p>源链接：<strong><u><a href="https://mp.weixin.qq.com/s/KZcnlW4RRZowPUelsRQAGA" target="_blank" rel="noopener">15 个 Linux 实用技巧</a></u></strong></p><a id="more"></a><h3 id="命令不记录到history"><a href="#命令不记录到history" class="headerlink" title="命令不记录到history"></a>命令不记录到history</h3><p>我们在所要执行的命令前，加一个空格，那这条命令就不会被 history 保存到历史记录</p><p>有时候，执行的命令中包含敏感信息，这个小技巧就显得非常实用了，你也不会再因为忘记执行 history -c 而烦恼了。</p><h3 id="快速搜索历史命令"><a href="#快速搜索历史命令" class="headerlink" title="快速搜索历史命令"></a>快速搜索历史命令</h3><p>在 Linux 下经常会敲很多的命令，我们要怎么快速查找并执行历史命令呢？</p><p>通过上下键来翻看历史命令，No No No，可以通过执行 Ctrl + r，然后键入要所搜索的命令关键词，进行搜索，回车就可以执行，非常高效。</p><h3 id="历史命令使用技巧"><a href="#历史命令使用技巧" class="headerlink" title="历史命令使用技巧"></a>历史命令使用技巧</h3><p>分享几个历史命令的使用技巧，能够提高你的工作效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!!：重复执行上条命令；</span><br><span class="line">!N：重复执行 history 历史中第 N 条命令，N 可以通过 history 查看；</span><br><span class="line">!pw：重复执行最近一次，以pw开头的历史命令，这个非常有用，小编使用非常高频；</span><br><span class="line">!$：表示最近一次命令的最后一个参数；</span><br></pre></td></tr></table></figure><p>猜测大部分同学没用过 !$，这里简单举个例子，让你感受一下它的高效用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c</span><br><span class="line">$ mv !$ !$.bak</span><br><span class="line"># 相当于</span><br><span class="line">$ mv &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c.bak</span><br></pre></td></tr></table></figure><p>当前工作目录是 root，想把 main.c 改为 main.c.bak。正常情况你可能需要敲 2 遍包含 main.c 的长参数，当然你也可能会选择直接复制粘贴。</p><p>而我通过使用 !$ 变量，可以很轻松优雅的实现改名。</p><h3 id="优雅的删除、修改乱码名字的文件"><a href="#优雅的删除、修改乱码名字的文件" class="headerlink" title="优雅的删除、修改乱码名字的文件"></a>优雅的删除、修改乱码名字的文件</h3><p>在 Linux 系统中，会经常碰到名称乱码的文件。想要删除它，却无法通过键盘输入名字，有时候复制粘贴乱码名称，终端可能识别不了，该怎么办？</p><p>不用担心，下边来展示下 find 是如何优雅的解决问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls  -i</span><br><span class="line">138957 a.txt  138959 T.txt  132395 ڹ��.txt</span><br><span class="line"></span><br><span class="line">$ find . -inum 132395 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>命令中，-inum 指定的是文件的 inode 号，它是系统中每个文件对应的唯一编号，find 通过编号找到后，执行删除操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find -inum 节点号 -exec rm &#123;&#125; \; &#x2F;&#x2F;删除</span><br><span class="line">find -inum 节点号 -exec mv &#123;&#125; newname \; &#x2F;&#x2F;重命名</span><br><span class="line">find -inum 节点号 -exec cat &#123;&#125; \; &#x2F;&#x2F;查看内容</span><br></pre></td></tr></table></figure><h3 id="Linux上获取你的公网IP地址"><a href="#Linux上获取你的公网IP地址" class="headerlink" title="Linux上获取你的公网IP地址"></a>Linux上获取你的公网IP地址</h3><p>在办公或家庭环境，我们的虚拟机或服务器上配置的通常是内网 IP 地址，我们如何知道，在与外网通信时，我们的公网出口 IP 是神马呢？</p><p>这个在 Linux 上非常简单，一条命令搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl ip.sb</span><br><span class="line">$ curl ifconfig.me</span><br></pre></td></tr></table></figure><p>上述两条命令都可以</p><h3 id="动态实时查看日志"><a href="#动态实时查看日志" class="headerlink" title="动态实时查看日志"></a>动态实时查看日志</h3><p>通过 tail 命令 -f 选项，可以动态地监控日志文件的变化，非常实用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f test.log</span><br></pre></td></tr></table></figure><p>如果想在日志中出现 Failed 等信息时立刻停止 tail 监控，可以通过如下命令来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f test.log | sed &#39;&#x2F;Failed&#x2F; q&#39;</span><br></pre></td></tr></table></figure><h3 id="快速清空文件的方法"><a href="#快速清空文件的方法" class="headerlink" title="快速清空文件的方法"></a>快速清空文件的方法</h3><p>快速清空一个文件，有 N 种方法，我比较喜欢下边这种，因为它最短</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &gt; access.log</span><br></pre></td></tr></table></figure><p>不过瘾？好吧，我也顺便总结下，其它几种最常见的清空文件的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">: &gt; access.log</span><br><span class="line">true &gt; access.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; access.log</span><br><span class="line">echo -n &quot;&quot; &gt; access.log</span><br><span class="line">echo &gt; access.log</span><br><span class="line">truncate -s 0 access.log</span><br></pre></td></tr></table></figure><p>简单解释下， : 在 shell 中是一个内置命令，表示 no-op，大概就是空语句的意思，所以 : 的那个用法，就是执行命令后，什么都没有输出，将空内容覆盖到文件。</p><h3 id="快速生成大文件"><a href="#快速生成大文件" class="headerlink" title="快速生成大文件"></a>快速生成大文件</h3><p>有时候，在 Linux 上，我们需要一个大文件，用于测试上传或下载的速度，通过 dd 命令可以快速生成一个大文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file.img bs&#x3D;1M count&#x3D;1024</span><br></pre></td></tr></table></figure><p>上述命令，生成一个文件名为 file.img 大小为 1G 的文件。</p><h3 id="安全擦除硬盘数据"><a href="#安全擦除硬盘数据" class="headerlink" title="安全擦除硬盘数据"></a>安全擦除硬盘数据</h3><p>介绍一种擦除硬盘数据的方法，高效，安全。可以通过 dd 命令，轻松实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;urandom of&#x3D;&#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><p>使用 /dev/urandom 生成随机数据，将生成的数据写入 sda 硬盘中，相当于安全的擦除了硬盘数据。</p><h3 id="快速制作系统盘"><a href="#快速制作系统盘" class="headerlink" title="快速制作系统盘"></a>快速制作系统盘</h3><p>在 Linux 下制作系统盘，老毛桃神么工具都弱爆了，直接一条命令搞定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if&#x3D;ubuntu-server-amd64.iso of&#x3D;&#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><p>哈哈，是不是很爽，sdb 可以 U 盘，也可以是普通硬盘</p><h3 id="查看某个进程的运行时间"><a href="#查看某个进程的运行时间" class="headerlink" title="查看某个进程的运行时间"></a>查看某个进程的运行时间</h3><p>可能，大部分同学只会使用 ps aux，其实可以通过 -o 参数，指定只显示具体的某个字段，会得到更清晰的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -p 10167 -o etimes,etime</span><br><span class="line">ELAPSED     ELAPSED</span><br><span class="line">1712055 19-19:34:15</span><br></pre></td></tr></table></figure><p>通过 etime 获取该进程的运行时间，可以很直观地看到，进程运行了 19 天</p><p>同样，可以通过 -o 指定 rss 可以只获取该进程的内存信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -p 10167 -o rss</span><br><span class="line">  RSS</span><br><span class="line"> 2180</span><br></pre></td></tr></table></figure><h3 id="时间戳的快速转换"><a href="#时间戳的快速转换" class="headerlink" title="时间戳的快速转换"></a>时间戳的快速转换</h3><p>时间操作，对程序员来说就是家常便饭。有时候希望能够将时间戳，转换为日期时间，在 Linux 命令行上，也可以快速的进行转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d@1234567890 +&quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2009-02-14 07:31:30</span><br></pre></td></tr></table></figure><p>当然，也可以在命令行上，查看当前的时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date +%s</span><br><span class="line">1617514141</span><br></pre></td></tr></table></figure><h3 id="优雅的计算程序运行时间"><a href="#优雅的计算程序运行时间" class="headerlink" title="优雅的计算程序运行时间"></a>优雅的计算程序运行时间</h3><p>在 Linux 下，可以通过 time 命令，很容易获取程序的运行时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ time .&#x2F;test</span><br><span class="line">real    0m1.003s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.000s</span><br></pre></td></tr></table></figure><p>可以看到，程序的运行时间为: 1.003s。细心的同学，会看到 real 貌似不等于 user + sys，而且还远远大于，这是怎么回事呢？</p><p>先来解释下这三个参数的含义：</p><ul><li>real：表示的钟表时间，也就是从程序执行到结束花费的时间；</li><li>user：表示运行期间，cpu 在用户空间所消耗的时间；</li><li>sys：表示运行期间，cpu 在内核空间所消耗的时间；</li></ul><p>由于 user 和 sys 只统计 cpu 消耗的时间，程序运行期间会调用 sleep 发生阻塞，也可能会等待网络或磁盘 IO，都会消耗大量时间。因此对于类似情况，real 的值就会大于其它两项之和。</p><p>另外，也会遇到 real 远远小于 user + sys 的场景，这是什么鬼情况？</p><p>这个更好理解，如果程序在多个 cpu 上并行，那么 user 和 sys 统计时间是多个 cpu 时间，实际消耗时间 real 很可能就比其它两个之和要小了</p><h3 id="命令行查看ascii码"><a href="#命令行查看ascii码" class="headerlink" title="命令行查看ascii码"></a>命令行查看ascii码</h3><p>我们在开发过程中，通常需要查看 ascii 码，通过 Linux 命令行就可以轻松查看，而不用去 Google 或 Baidu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man ascii</span><br></pre></td></tr></table></figure><h3 id="如何批量下载网页资源"><a href="#如何批量下载网页资源" class="headerlink" title="如何批量下载网页资源"></a>如何批量下载网页资源</h3><p>有时，同事会通过网页的形式分享文件下载链接，在 Linux 系统，通过 wget 命令可以轻松下载，而不用写脚本或爬虫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -nd -np --accept&#x3D;pdf http:&#x2F;&#x2F;fast.dpdk.org&#x2F;doc&#x2F;pdf-guides&#x2F;</span><br><span class="line"># --accept：选项指定资源类型格式 pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;linux小技巧&quot;&gt;&lt;a href=&quot;#linux小技巧&quot; class=&quot;headerlink&quot; title=&quot;linux小技巧&quot;&gt;&lt;/a&gt;linux小技巧&lt;/h3&gt;&lt;p&gt;linux有用的小技巧，随时添加。&lt;/p&gt;
&lt;p&gt;源链接：&lt;strong&gt;&lt;u&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KZcnlW4RRZowPUelsRQAGA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;15 个 Linux 实用技巧&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu登录界面美化</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/14/ubuntu%E5%BC%80%E6%9C%BA%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/14/ubuntu%E5%BC%80%E6%9C%BA%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</id>
    <published>2021-04-13T18:03:00.000Z</published>
    <updated>2021-04-13T18:03:45.688Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://blog.csdn.net/vselfdom/article/details/88546349" target="_blank" rel="noopener">Ubuntu 18.04 用户登录界面优化</a></strong>，备用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/vselfdom/article/details/88546349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 18.04 用户登录界面优化&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Async/await</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/14/Async-await/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/14/Async-await/</id>
    <published>2021-04-13T17:05:00.000Z</published>
    <updated>2021-04-13T18:00:19.428Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javascript.info/async-await" target="_blank" rel="noopener">Async/await</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://javascript.info/async-await&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Async/await&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Using the Switch(true) Pattern in JavaScript</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/13/Using-the-Switch-true-Pattern-in-JavaScript-https-seanbarry-dev-posts-switch-true-pattern/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/13/Using-the-Switch-true-Pattern-in-JavaScript-https-seanbarry-dev-posts-switch-true-pattern/</id>
    <published>2021-04-12T17:19:00.000Z</published>
    <updated>2021-04-12T17:20:35.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://seanbarry.dev/posts/switch-true-pattern" target="_blank" rel="noopener">Using the Switch(true) Pattern in JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://seanbarry.dev/posts/switch-true-pattern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using the Switch(true) Pattern in JavaScript&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>centos 免密切换root</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/11/centos-switch-to-root-without-password/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/11/centos-switch-to-root-without-password/</id>
    <published>2021-04-10T17:29:00.000Z</published>
    <updated>2021-04-13T19:16:18.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>centos6上免密切换到root，原理、步骤。</p><a id="more"></a><h3 id="execute-ALL-sudo-commands-without-password"><a href="#execute-ALL-sudo-commands-without-password" class="headerlink" title="execute ALL sudo commands without password"></a>execute ALL sudo commands without password</h3><p>Type the following command as root user:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># visudo</span><br></pre></td></tr></table></figure><p>Or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br></pre></td></tr></table></figure><p>Append the following entry to run ALL command without a password for a user named marlena:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remo ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>Save and close the file in vim. It is also possible to grant access to the group name such as sysadm. Any member of sysadm group can run command without a password. The syntax is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>Of course, you can force the sysadm group to run only given commands such as /usr/sbin/reboot and systemctl:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: &#x2F;sbin&#x2F;reboot, systemctl</span><br></pre></td></tr></table></figure><p>参考：<strong><a href="https://www.cyberciti.biz/faq/how-to-sudo-without-password-on-centos-linux/" target="_blank" rel="noopener">How to sudo without password on CentOS Linux</a></strong></p><h3 id="switch-to-root-without-password"><a href="#switch-to-root-without-password" class="headerlink" title="switch to root without password"></a>switch to root without password</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lansetongxin2 &#x2F;]# vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>相应位置添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-34.png" alt="upload successful"><br>ps: By default on CentOS systems, members of the group wheel are granted with sudo access.</p><p>:wq 保存后，便可以免密切换到root(sudo su -)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[remo@lansetongxin2 ~]$ sudo su #最好使用sudo su -完全切换，su会加载不出来环境变量</span><br></pre></td></tr></table></figure><p>ps: su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令。</p><h3 id="root-ALL-ALL-ALL详解"><a href="#root-ALL-ALL-ALL详解" class="headerlink" title="root ALL=(ALL) ALL详解"></a>root ALL=(ALL) ALL详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>/etc/sudoers中的此行表示：root用户可以从所有终端执行，充当所有（任何）用户，并运行ALL（任何）命令。<br>第一部分是用户，第二部分是用户可以使用sudo命令的终端，第三部分是他可以充当哪些用户，最后一部分是使用时可以运行的命令sudo。</p><p>sudoers的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator ALL&#x3D; &#x2F;sbin&#x2F;poweroff</span><br></pre></td></tr></table></figure><p>以上命令，使用户操作员可以从任何终端，关闭命令电源。</p><p>您还可以为以下项创建别名：users - &gt; User_Alias，以其他用户身份运行命令 - &gt; Runas_Alias，主机 - &gt; Host_Alias 命令 - &gt; Cmnd_Alias</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User_Alias OPERATORS &#x3D; joe, mike, jude Runas_Alias OP &#x3D; root, operator Host_Alias OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0 Cmnd_Alias PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br></pre></td></tr></table></figure><p>正如您所看到的别名OPERATORS包括用户joe，mike和jude，别名OP包括用户root和operator，别名OFNET包括网络10.1.2.0（所有C类），命令别名PRINTING包含命令lpc和lprm。</p><p>因此，典型的sudoers文件可能如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> User_Alias     OPERATORS &#x3D; joe, mike, jude</span><br><span class="line"> Runas_Alias    OP &#x3D; root, operator</span><br><span class="line"> Host_Alias     OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0</span><br><span class="line"> Cmnd_Alias     PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br><span class="line"></span><br><span class="line">OPERATORS ALL&#x3D;ALL</span><br><span class="line"></span><br><span class="line">#The users in the OPERATORS group can run any command from</span><br><span class="line"> any terminal.</span><br><span class="line"></span><br><span class="line">linus ALL&#x3D;(OP) ALL</span><br><span class="line"></span><br><span class="line"># The user linus can run any command from any terminal as any </span><br><span class="line">user in the OP group (root or operator).</span><br><span class="line"></span><br><span class="line">user2 OFNET&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># user user2 may run any command from any machine in the </span><br><span class="line">OFNET network, as any user.</span><br><span class="line"></span><br><span class="line">user3 ALL&#x3D; PRINTING</span><br><span class="line"></span><br><span class="line"># user user3 may run lpc and lprm from any machine.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>在编辑器中打开 sudoers 文件后，您需要向下滚动到编辑器的末尾并在其中添加以下代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>用您的用户名替换“ yujiaao ”！（例如：anderson ALL =（ALL）NOPASSWD：ALL），命令NOPASSWD将在终端中运行SUDO命令时跳过密码验证。</p><p>如何在为特定命令运行sudo时跳过密码：<br>您可以允许某些命令使用密码运行sudo，使用以下命令来实现它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:&#x2F;bin&#x2F;cp,&#x2F;bin&#x2F;install,bin&#x2F;remove</span><br></pre></td></tr></table></figure><p>完成编辑后，请保存文件并退出终端。</p><p>NOPASSWD 是一个“标签”，表示不会请求密码。它有一个名为的伴随命令 PASSWD，是默认行为。标签与规则的其余部分相关，除非在其后面的“双胞胎”标签上被否决。<br>例如，我们可以有这样的一行：</p><p>在 /etc/sudoers文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUPTWO    ALL &#x3D; NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;updatedb, PASSWD: &#x2F;bin&#x2F;kill</span><br></pre></td></tr></table></figure><p>另一个有用的标签NOEXEC，可用于防止某些程序中的某些危险行为。</p><p>例如，某些程序（如“less”）可以通过在其界面中键入以下内容来生成其他命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!command_to_run</span><br></pre></td></tr></table></figure><p>这基本上执行用户赋予它的任何命令，具有“less”运行的相同权限，这可能非常危险。</p><p>为了限制这一点，我们可以使用这样的一行：</p><p>在 /etc/sudoers文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username  ALL &#x3D; NOEXEC: &#x2F;usr&#x2F;bin&#x2F;less</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;centos6上免密切换到root，原理、步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Let’sEncrypt 证书自动更新脚本</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/08/Let%E2%80%99sEncrypt-%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/08/Let%E2%80%99sEncrypt-%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/</id>
    <published>2021-04-08T10:49:00.000Z</published>
    <updated>2021-04-12T17:21:51.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vps科学上网用的Let’sEncrypt免费证书，有效期一般是3个月，需要定期更新。写个脚本，定时更新。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Version:1.0</span><br><span class="line">#Author:zzl</span><br><span class="line">#Automatically renew Let&#39;s Encrypt certificates</span><br><span class="line">#A cron job will run this shell script everyday</span><br><span class="line">i&#x3D;0</span><br><span class="line">while [[ $i -lt 10]]</span><br><span class="line">do</span><br><span class="line">  let &quot;i++&quot;</span><br><span class="line">  if [ $(ps -C nginx --no-header | wc -l) -ne 0];then</span><br><span class="line">    service nginx stop</span><br><span class="line">    sleep 3s</span><br><span class="line">    if [ $(ps -C nginx --no-header | wc -l) -eq 0];then</span><br><span class="line">      break</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">certbot renew </span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>或者直接用certbot renew command，详情如下<br>        <strong><a href="https://certbot.eff.org/docs/using.html?highlight=hooks#renewing-certificates" target="_blank" rel="noopener">Certbot documentation on renewing certificates</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;vps科学上网用的Let’sEncrypt免费证书，有效期一般是3个月，需要定期更新。写个脚本，定时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell脚本检查nginx服务状态</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/08/shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%9F%A5nginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/08/shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%9F%A5nginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</id>
    <published>2021-04-08T10:35:00.000Z</published>
    <updated>2021-04-08T10:36:20.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    service nginx start</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="脚本解析"><a href="#脚本解析" class="headerlink" title="脚本解析"></a>脚本解析</h3><p>以上是通过进程判断，也可以通过端口判断，如netstat -nlpt | grep nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@newyork ~]# netstat -nlpt | grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8801&#x2F;nginx: master</span><br></pre></td></tr></table></figure><p>以下，以进程为例详解，ps -C nginx –no-header<br>这里涉及ps 的用法，我们一般用ps查看相关进程，一般都是用ps -ef | grep XX 或 ps -aux| grep XX 的模式<br>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br><span class="line">root     11660  5532  0 09:55 pts&#x2F;1    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><p>但是这样通常都会覆盖一个grep的进程。</p><p>我们可以用ps -ef|grep nginx|grep -v grep的方式排除grep的进程，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@newyork ~]# ps -ef|grep nginx|grep -v grep</span><br><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>也可以直接用ps -C 或ps -c 的方式， -C 后面接命令的名字（推荐） ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  8801 ?        00:00:00 nginx</span><br><span class="line">  8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure><p>–no-header 就是去挑title,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx --no-header</span><br><span class="line"> 8801 ?        00:00:00 nginx</span><br><span class="line"> 8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure><p>wc -l 这个很熟悉了，行数计算</p><p>所以用这种方式可判断，如果<br>ps -C nginx –no-header|wc -l</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值为0，即代表服务未启动</span><br><span class="line">值为非0，即代表服务已启动</span><br></pre></td></tr></table></figure><p>最后，killall keepalived 这个是以服务名称杀死进程，日常中也用的挺多的</p><p>上面那段完整的脚本意思即为：<br>判断nginx 服务是否启动<br>如果未启动，执行启动命令<br>再次判断，如果启动失败，关掉keepalived，进入从节点</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/categories/shell/"/>
    
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux 后台运行、输出重定向</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2021-04-02T13:05:00.000Z</published>
    <updated>2021-04-12T17:22:20.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux termianl中，命令脚本的后台运行以及输出的重定向，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &gt; my.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &amp;&gt; my.log &amp;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>当启动一个服务后，希望命令在后台运行时，可以通过在命令末尾增加 &amp; ，例如：./test.sh &amp;，执行上述命令后，脚本开始在后台运行，并且命令行回显为 [1] 12532 ,这里的 1表示后台进程的编号，可以通过命令 fg 1 把进程切换回前台运行。</p><p>此时，虽然命令已经后台运行了，我们可以在控制台输入其他命令，但是脚本每秒打印的 x 会不断的输出到控制台，影响我们其他命令的执行，这时，我也需要用输出重定向把命令的执行结果输出的文件中。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>一个程序执行后，系统会生成三个句柄，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0&#x3D;stdin（标准输入）</span><br><span class="line">1&#x3D;stdout（标准输出）</span><br><span class="line">2&#x3D;stderr（错误输出）</span><br></pre></td></tr></table></figure><p>默认情况下，三个句柄都指向当前会话的命令行控制台。命令转到后台执行后，stdin关闭，stdout和stderr还是指向控制台。</p><p>通过在命令后使用输出重定向符 &gt; 实现对输出的重定向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout重定向到当前目录的run.log文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout和stderr都重定向到run.log，其中 2&gt;&amp;1 表示把stderr重定向到stdout。另外，其中&gt; run.log表示标准输出重定向到文件run.log中且是<strong>覆盖重写，如果想要追加方式写入，则是&gt;&gt; run.log</strong>。</p><p>Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。 </p><p>如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-) </p><p>另外+: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &amp;&gt; make_log</span><br></pre></td></tr></table></figure><p>意思是把标准输出和错误输出都重定向, <em>command&gt;out</em> 只重定向标准输出!!!!! </p><p><em>&gt;log</em> 表示把标准输出重新定向到文件log中 </p><p><em>&amp;&gt; log</em> 表示把标准输出和错误输出都定向到文件log中，相当于 <em>&gt;log 2&gt;&amp;1</em></p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>通过 &amp; 虽然可以把命令以后台进程的方式执行，但是如果SSH会话中断退出，和此会话相关的所有进程都会终止。<br>如果我们是登录服务器去启动一个服务程序，总不能启动后一直把SSH会话开着，而且会话到期会自动终止。</p><p>这是，我们可以使用 nohup（no hung up）来执行进程，此命令确保会话挂断后，命令可以继续运行。以nohup运行的命令，系统默认自动把stdout和stderr重定向到当前目录的nohup.out文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;run.py &amp;</span><br></pre></td></tr></table></figure><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><p>&amp;：已后台进程执行命令，但是会话关闭后，进程会结束。</p><p>nohup：确保进程不挂断的执行，但是没有后台执行的功能，所以一般nohup和&amp;需要配合一起使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;linux termianl中，命令脚本的后台运行以及输出的重定向，如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;gt; my.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;amp;&amp;gt; my.log &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu 开机启动管理</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-03-20T16:26:00.000Z</published>
    <updated>2021-04-12T17:24:50.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu自启服务管理命令</p><a id="more"></a><p>查看开机启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --type&#x3D;service|grep enabled</span><br></pre></td></tr></table></figure><p>以蓝牙为例，查询蓝牙服务是否开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled bluetooth.service</span><br></pre></td></tr></table></figure><p>如果是enable开机自启动<br>如果是disable不开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable bluetooth.service #开机运行服务</span><br><span class="line"></span><br><span class="line">systemctl disable bluetooth.service #取消开机运行</span><br><span class="line"></span><br><span class="line">sudo systemctl disable  bluetooth.service#关闭蓝牙服务</span><br><span class="line"></span><br><span class="line">systemctl start bluetooth.service #启动服务</span><br><span class="line"></span><br><span class="line">systemctl stop bluetooth.service #停止服务</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth.service #重启服务</span><br><span class="line"></span><br><span class="line">systemctl reload bluetooth.service #重新加载服务配置文件</span><br><span class="line"></span><br><span class="line">systemctl status bluetooth.service #查询服务运行状态</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu自启服务管理命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA激活</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/</id>
    <published>2021-03-20T07:01:00.000Z</published>
    <updated>2021-04-12T17:25:21.669Z</updated>
    
    <content type="html"><![CDATA[<p>可用方法：<a href="https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3" target="_blank" rel="noopener">IntelliJ IDEA 2020.3.3激活破解教程（亲测激活至 2099 年，长期更新）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可用方法：&lt;a href=&quot;https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA 2020.3.
      
    
    </summary>
    
    
    
      <category term="idea" scheme="http://blog.zhangzonglinagain.xyz/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>ssh 密码登录脚本</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</id>
    <published>2021-03-18T19:37:00.000Z</published>
    <updated>2021-04-12T17:25:59.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脚本密码登录服务器</p><a id="more"></a><p>1、安装expect<br>使用以下代码检测expect是否已经安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;usr&#x2F;bin | grep expect</span><br></pre></td></tr></table></figure><p>如果显示为空，则使用以下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure><p>2、 制作脚本<br>合适位置建个sh文件，脚本中写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh root@127.0.0.1 -p 22</span><br><span class="line">expect &quot;*Are you sure you want to continue connecting (yes&#x2F;no)?&quot;</span><br><span class="line">send &quot;yes\r&quot;</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;脚本密码登录服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/shell/"/>
    
    
      <category term="ssh" scheme="http://blog.zhangzonglinagain.xyz/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 打开win10 txt中文乱码</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2021-03-18T19:05:00.000Z</published>
    <updated>2021-03-18T19:15:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。</p><a id="more"></a><p>1、原因<br>ubuntu系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件）则vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），最终显示文件为乱码。</p><p>2、解决办法<br>在<em>/home/user/*下修改</em>.vimrc*文件（系统新装，默认情况下尚未创建）。 编辑 ~/.vimrc 文件（ 添加如下几行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set fileencodings&#x3D;utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding&#x3D;utf-8</span><br><span class="line">set encoding&#x3D;utf-8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下使用微信、QQ等</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/new/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/new/</id>
    <published>2021-03-17T19:32:00.000Z</published>
    <updated>2021-03-18T01:38:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。</p><a id="more"></a><p>网上教程多如牛毛，但不是坑，就是坑，找了个自己能用的，记录下备用<br>1、安装docker docker-compose，网上教程一大把，自己搜<br>2、执行如下命令<br>首先要允许所有用户访问X11服务,运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></table></figure><p>拉取镜像（注意docker设置国内镜像地址，用科大的就行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bestwu&#x2F;wechat</span><br></pre></td></tr></table></figure><p>在你指定的文件夹下创建 docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">  wechat:</span><br><span class="line">    image: bestwu&#x2F;wechat</span><br><span class="line">    container_name: wechat</span><br><span class="line">    devices:</span><br><span class="line">      - &#x2F;dev&#x2F;snd</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;tmp&#x2F;.X11-unix:&#x2F;tmp&#x2F;.X11-unix</span><br><span class="line">      - $PWD&#x2F;WeChatFiles:&#x2F;WeChatFiles</span><br><span class="line">    environment:</span><br><span class="line">      - DISPLAY&#x3D;unix$DISPLAY</span><br><span class="line">      - QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">      - GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - AUDIO_GID&#x3D;26 # 可选 默认63（在终端用getent group video | cut -d: -f3查） 主机audio gid 解决声音设备访问权限问题</span><br><span class="line">      - GID&#x3D;1000 # 可选 默认1000 主机当前用户 gid 解决挂载目录访问权限问题</span><br><span class="line">      - UID&#x3D;1000 # 可选 默认1000 主机当前用户 uid 解决挂载目录访问权限问题</span><br><span class="line">    ipc: host</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="wechat" scheme="http://blog.zhangzonglinagain.xyz/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自动挂载其他盘</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/</id>
    <published>2021-03-17T19:12:00.000Z</published>
    <updated>2021-04-12T17:26:32.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p><a id="more"></a><p>1、查询挂载硬盘UUID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p><p>2、打开文件/etc/fstab文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>在文档末尾添加相应磁盘的信息。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p><p>3、重启生效</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu terminal 打开后的默认位置和大小</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/</id>
    <published>2021-03-17T17:28:00.000Z</published>
    <updated>2021-03-17T19:12:15.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。</p><a id="more"></a><p>网传的一般有两种，一种是自定义快捷键，一种是修改<em>/usr/share/applications/gnome-terminal.desktop</em>。第二种效果只是修改了“通过菜单栏或鼠标点击进入终端时的位置”，用<em>Ctrl+Alt+T</em>进入时，没有效果，所以本文选择第一种，步骤如下：</p><p>1、打开一个终端，把它调整到自己想要的大小和位置</p><p>2、在终端内执行xwininfo，鼠标变成十字，然后鼠标点击终端，出现终端窗口的信息，注意最后一行： -geometry 80x24-4+168</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>3、依次进入Setting - Devices - keyboard，可以看到系统的所有快捷键设置，包括<em>Launch terminal Ctrl+Alt+T</em>。拉到最下面，点击+号</p><p><img src="/images/pasted-31.png" alt="upload successful"></p><p>Name自己取，主要是Command,输入步骤2的大小坐标信息，  <em>gnome-terminal –geometry=80x24-4+168</em> ，Shortcut自定义即可，注意不要跟现存的快捷键冲突。我自己是用的Super+T。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="terminal" scheme="http://blog.zhangzonglinagain.xyz/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中vim的粘帖复制</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-16T17:13:00.000Z</published>
    <updated>2021-04-12T17:27:38.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。</p><a id="more"></a><h3 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h3><h4 id="默认剪贴板"><a href="#默认剪贴板" class="headerlink" title="默认剪贴板"></a>默认剪贴板</h4><p>vim会有一些存储空间来暂存内容，vim中将这些存储空间叫寄存器。此寄存器非我们硬件所说的寄存器，可以理解为是一种cache。例如我们在vim中y操作复制的内容，实际就是暂存到寄存器中。</p><p>如下，在vim中执使用:reg命令，可以查看各个寄存器的内容。<br><img src="/images/pasted-27.png" alt="upload successful"></p><p>其中有两个特殊的寄存器: “* 和 “+。前者关联系统选择缓冲区(Buffer)，后者关联系统剪切板(Clipboard)，关于系统剪切板的使用见下文。</p><h4 id="复制和粘贴到指定剪贴板"><a href="#复制和粘贴到指定剪贴板" class="headerlink" title="复制和粘贴到指定剪贴板"></a>复制和粘贴到指定剪贴板</h4><p>要把vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后（按Esc），按 *”Ny* 完成复制，其中N表示特定寄存器编号（注意是按一下双引号然后按粘贴板号最后按y），例如要把内容复制到系统剪切板，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+y</span><br></pre></td></tr></table></figure><p>就可以了。注意的是，上面是 双引号 + 加号寄存器 + y。通过这命令copy后就可以去浏览器Ctrl+v了。</p><p>如果从浏览器Ctrl+c后，要粘贴到vim中，则需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+p</span><br></pre></td></tr></table></figure><h3 id="系统剪切板及使用"><a href="#系统剪切板及使用" class="headerlink" title="系统剪切板及使用"></a>系统剪切板及使用</h3><h4 id="查看-Vim-是否支持系统剪切板"><a href="#查看-Vim-是否支持系统剪切板" class="headerlink" title="查看 Vim 是否支持系统剪切板"></a>查看 Vim 是否支持系统剪切板</h4><p>刚重装了系统，命令按了半天，跑到其他地方Ctrl+v，什么也没有，原来是系统剪切板不支持的锅。<br>在终端输入 <em>vim –version | grep clipboard</em>回车：<br><img src="/images/pasted-28.png" alt="upload successful"><br>如果 clipboard 前面都是 - 号，说目前还不支持系统剪切板功能，请继续看下一节，如果都是 + 号，略过此节。</p><h4 id="开启系统剪切板功能"><a href="#开启系统剪切板功能" class="headerlink" title="开启系统剪切板功能"></a>开启系统剪切板功能</h4><p>开启系统剪切板功能的方法也有很多，比较正统的应该是重新编译安装 Vim 源码，因为我怕麻烦（水平渣），所以选择简单的方法，即安装 vim-gnome。<br>一行指令即可搞定，在终端输入 <em>sudo apt install vim-gnome -y</em>回车。<br>此时再次使用上述的两个方法验证，发现 Vim 已经支持系统剪切板功能。</p><h3 id="vim内部复制、粘贴、剪切"><a href="#vim内部复制、粘贴、剪切" class="headerlink" title="vim内部复制、粘贴、剪切"></a>vim内部复制、粘贴、剪切</h3><h4 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h4><p>在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v+光标移动 （按字符选择）高亮选中所要的文本，然后进行各种操作（比如粘帖到系统剪切板“+y）。</span><br><span class="line">V （按行选择）</span><br><span class="line">v+选中的内容+c 更改选中的文字</span><br></pre></td></tr></table></figure><h4 id="复制：y-ank"><a href="#复制：y-ank" class="headerlink" title="复制：y(ank)"></a>复制：y(ank)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y 用v命令选中文本后，用y进行复制</span><br><span class="line">yy 复制当前行，然后用p进行粘贴</span><br><span class="line">5yy 复制从当前行开始的5行</span><br><span class="line">y_ 等同于yy</span><br><span class="line">Y 等同于yy</span><br><span class="line">yw 复制当前单词</span><br><span class="line">y$ 从当前位置复制到行尾</span><br><span class="line">y0 从当前位置复制到行首</span><br><span class="line">y^ 从当前位置复制到第一个非空白字符</span><br><span class="line">yG 从当前行复制到文件结束</span><br><span class="line">y20G 从当前行复制到第20行</span><br><span class="line">y?bar 复制至上一个出现bar的位置</span><br></pre></td></tr></table></figure><h4 id="粘贴：p-aste"><a href="#粘贴：p-aste" class="headerlink" title="粘贴：p(aste)"></a>粘贴：p(aste)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p(小写) 在光标位置之后粘贴</span><br><span class="line">P(大写) 在光标位置之前粘贴</span><br></pre></td></tr></table></figure><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v + 方向键(hjkl)选中内容 + d 剪切 + p粘贴</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="vim复制到系统剪贴板"><a href="#vim复制到系统剪贴板" class="headerlink" title="vim复制到系统剪贴板"></a>vim复制到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;*y</span><br><span class="line">&quot;+y</span><br><span class="line">&quot;+2yy – 复制两行</span><br><span class="line">&#123;Visual&#125;&quot;+y - copy the selected text into the system clipboard</span><br><span class="line">&quot;+y&#123;motion&#125; - copy the text specified by &#123;motion&#125; into the system clipboard</span><br><span class="line">:[range]yank + - copy the text specified by [range] into the system clipboard</span><br></pre></td></tr></table></figure><h5 id="vim剪切到系统剪贴板"><a href="#vim剪切到系统剪贴板" class="headerlink" title="vim剪切到系统剪贴板"></a>vim剪切到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;+dd – 剪切一行</span><br><span class="line">从系统剪贴板粘贴到vim</span><br><span class="line">&quot;*p</span><br><span class="line">&quot;+p</span><br><span class="line">Shift+Insert</span><br><span class="line">:put + - Ex command puts contents of system clipboard on a new line</span><br><span class="line">&lt;C-r&gt;+ - From insert mode (or commandline mode)</span><br><span class="line">&quot;+p比 Ctrl-v 命令更好，它可以更快更可靠地处理大块文本的粘贴，也能够避免粘贴大量文本时，发生每行行首的自动缩进累积，因为Ctrl-v是通过系统缓存的stream处理，一行一行地处理粘贴的文本。</span><br></pre></td></tr></table></figure><p>参考：<strong><a href="https://liushiming.cn/article/copy-and-paste-in-vim.html" target="_blank" rel="noopener">一文搞懂vim复制粘贴</a></strong>、<strong><a href="https://blog.csdn.net/jpch89/article/details/93915710" target="_blank" rel="noopener">打开 Ubuntu 18 中 Vim 的系统剪切板功能</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="vim" scheme="http://blog.zhangzonglinagain.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>巧记linux常用命令中的递归参数-r(R)和-p</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/</id>
    <published>2021-03-08T18:38:00.000Z</published>
    <updated>2021-03-08T18:39:29.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/longyamiao/article/details/79782254" target="_blank" rel="noopener">巧记linux常用命令中的递归参数-r(R)和-p</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/longyamiao/article/details/79782254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;巧记linux常用命令中的递归参数-r(R)和-p&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
</feed>
