<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglinagain.xyz/"/>
  <updated>2021-04-13T18:03:45.688Z</updated>
  <id>http://blog.zhangzonglinagain.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu登录界面美化</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/14/ubuntu%E5%BC%80%E6%9C%BA%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/14/ubuntu%E5%BC%80%E6%9C%BA%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</id>
    <published>2021-04-13T18:03:00.000Z</published>
    <updated>2021-04-13T18:03:45.688Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://blog.csdn.net/vselfdom/article/details/88546349" target="_blank" rel="noopener">Ubuntu 18.04 用户登录界面优化</a></strong>，备用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/vselfdom/article/details/88546349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 18.04 用户登录界面优化&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Async/await</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/14/Async-await/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/14/Async-await/</id>
    <published>2021-04-13T17:05:00.000Z</published>
    <updated>2021-04-13T18:00:19.428Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javascript.info/async-await" target="_blank" rel="noopener">Async/await</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://javascript.info/async-await&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Async/await&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Using the Switch(true) Pattern in JavaScript</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/13/Using-the-Switch-true-Pattern-in-JavaScript-https-seanbarry-dev-posts-switch-true-pattern/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/13/Using-the-Switch-true-Pattern-in-JavaScript-https-seanbarry-dev-posts-switch-true-pattern/</id>
    <published>2021-04-12T17:19:00.000Z</published>
    <updated>2021-04-12T17:20:35.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://seanbarry.dev/posts/switch-true-pattern" target="_blank" rel="noopener">Using the Switch(true) Pattern in JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://seanbarry.dev/posts/switch-true-pattern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using the Switch(true) Pattern in JavaScript&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://blog.zhangzonglinagain.xyz/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>centos 免密切换root</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/11/centos-switch-to-root-without-password/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/11/centos-switch-to-root-without-password/</id>
    <published>2021-04-10T17:29:00.000Z</published>
    <updated>2021-04-13T19:16:18.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>centos6上免密切换到root，原理、步骤。</p><a id="more"></a><h3 id="execute-ALL-sudo-commands-without-password"><a href="#execute-ALL-sudo-commands-without-password" class="headerlink" title="execute ALL sudo commands without password"></a>execute ALL sudo commands without password</h3><p>Type the following command as root user:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># visudo</span><br></pre></td></tr></table></figure><p>Or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br></pre></td></tr></table></figure><p>Append the following entry to run ALL command without a password for a user named marlena:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remo ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>Save and close the file in vim. It is also possible to grant access to the group name such as sysadm. Any member of sysadm group can run command without a password. The syntax is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>Of course, you can force the sysadm group to run only given commands such as /usr/sbin/reboot and systemctl:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: &#x2F;sbin&#x2F;reboot, systemctl</span><br></pre></td></tr></table></figure><p>参考：<strong><a href="https://www.cyberciti.biz/faq/how-to-sudo-without-password-on-centos-linux/" target="_blank" rel="noopener">How to sudo without password on CentOS Linux</a></strong></p><h3 id="switch-to-root-without-password"><a href="#switch-to-root-without-password" class="headerlink" title="switch to root without password"></a>switch to root without password</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lansetongxin2 &#x2F;]# vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>相应位置添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-34.png" alt="upload successful"><br>ps: By default on CentOS systems, members of the group wheel are granted with sudo access.</p><p>:wq 保存后，便可以免密切换到root(sudo su -)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[remo@lansetongxin2 ~]$ sudo su #最好使用sudo su -完全切换，su会加载不出来环境变量</span><br></pre></td></tr></table></figure><p>ps: su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令。</p><h3 id="root-ALL-ALL-ALL详解"><a href="#root-ALL-ALL-ALL详解" class="headerlink" title="root ALL=(ALL) ALL详解"></a>root ALL=(ALL) ALL详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>/etc/sudoers中的此行表示：root用户可以从所有终端执行，充当所有（任何）用户，并运行ALL（任何）命令。<br>第一部分是用户，第二部分是用户可以使用sudo命令的终端，第三部分是他可以充当哪些用户，最后一部分是使用时可以运行的命令sudo。</p><p>sudoers的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator ALL&#x3D; &#x2F;sbin&#x2F;poweroff</span><br></pre></td></tr></table></figure><p>以上命令，使用户操作员可以从任何终端，关闭命令电源。</p><p>您还可以为以下项创建别名：users - &gt; User_Alias，以其他用户身份运行命令 - &gt; Runas_Alias，主机 - &gt; Host_Alias 命令 - &gt; Cmnd_Alias</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User_Alias OPERATORS &#x3D; joe, mike, jude Runas_Alias OP &#x3D; root, operator Host_Alias OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0 Cmnd_Alias PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br></pre></td></tr></table></figure><p>正如您所看到的别名OPERATORS包括用户joe，mike和jude，别名OP包括用户root和operator，别名OFNET包括网络10.1.2.0（所有C类），命令别名PRINTING包含命令lpc和lprm。</p><p>因此，典型的sudoers文件可能如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> User_Alias     OPERATORS &#x3D; joe, mike, jude</span><br><span class="line"> Runas_Alias    OP &#x3D; root, operator</span><br><span class="line"> Host_Alias     OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0</span><br><span class="line"> Cmnd_Alias     PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br><span class="line"></span><br><span class="line">OPERATORS ALL&#x3D;ALL</span><br><span class="line"></span><br><span class="line">#The users in the OPERATORS group can run any command from</span><br><span class="line"> any terminal.</span><br><span class="line"></span><br><span class="line">linus ALL&#x3D;(OP) ALL</span><br><span class="line"></span><br><span class="line"># The user linus can run any command from any terminal as any </span><br><span class="line">user in the OP group (root or operator).</span><br><span class="line"></span><br><span class="line">user2 OFNET&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># user user2 may run any command from any machine in the </span><br><span class="line">OFNET network, as any user.</span><br><span class="line"></span><br><span class="line">user3 ALL&#x3D; PRINTING</span><br><span class="line"></span><br><span class="line"># user user3 may run lpc and lprm from any machine.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>在编辑器中打开 sudoers 文件后，您需要向下滚动到编辑器的末尾并在其中添加以下代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>用您的用户名替换“ yujiaao ”！（例如：anderson ALL =（ALL）NOPASSWD：ALL），命令NOPASSWD将在终端中运行SUDO命令时跳过密码验证。</p><p>如何在为特定命令运行sudo时跳过密码：<br>您可以允许某些命令使用密码运行sudo，使用以下命令来实现它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:&#x2F;bin&#x2F;cp,&#x2F;bin&#x2F;install,bin&#x2F;remove</span><br></pre></td></tr></table></figure><p>完成编辑后，请保存文件并退出终端。</p><p>NOPASSWD 是一个“标签”，表示不会请求密码。它有一个名为的伴随命令 PASSWD，是默认行为。标签与规则的其余部分相关，除非在其后面的“双胞胎”标签上被否决。<br>例如，我们可以有这样的一行：</p><p>在 /etc/sudoers文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUPTWO    ALL &#x3D; NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;updatedb, PASSWD: &#x2F;bin&#x2F;kill</span><br></pre></td></tr></table></figure><p>另一个有用的标签NOEXEC，可用于防止某些程序中的某些危险行为。</p><p>例如，某些程序（如“less”）可以通过在其界面中键入以下内容来生成其他命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!command_to_run</span><br></pre></td></tr></table></figure><p>这基本上执行用户赋予它的任何命令，具有“less”运行的相同权限，这可能非常危险。</p><p>为了限制这一点，我们可以使用这样的一行：</p><p>在 /etc/sudoers文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username  ALL &#x3D; NOEXEC: &#x2F;usr&#x2F;bin&#x2F;less</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;centos6上免密切换到root，原理、步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Let’sEncrypt 证书自动更新脚本</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/08/Let%E2%80%99sEncrypt-%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/08/Let%E2%80%99sEncrypt-%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/</id>
    <published>2021-04-08T10:49:00.000Z</published>
    <updated>2021-04-12T17:21:51.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vps科学上网用的Let’sEncrypt免费证书，有效期一般是3个月，需要定期更新。写个脚本，定时更新。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Version:1.0</span><br><span class="line">#Author:zzl</span><br><span class="line">#Automatically renew Let&#39;s Encrypt certificates</span><br><span class="line">#A cron job will run this shell script everyday</span><br><span class="line">i&#x3D;0</span><br><span class="line">while [[ $i -lt 10]]</span><br><span class="line">do</span><br><span class="line">  let &quot;i++&quot;</span><br><span class="line">  if [ $(ps -C nginx --no-header | wc -l) -ne 0];then</span><br><span class="line">    service nginx stop</span><br><span class="line">    sleep 3s</span><br><span class="line">    if [ $(ps -C nginx --no-header | wc -l) -eq 0];then</span><br><span class="line">      break</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">certbot renew </span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>或者直接用certbot renew command，详情如下<br>        <strong><a href="https://certbot.eff.org/docs/using.html?highlight=hooks#renewing-certificates" target="_blank" rel="noopener">Certbot documentation on renewing certificates</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;vps科学上网用的Let’sEncrypt免费证书，有效期一般是3个月，需要定期更新。写个脚本，定时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell脚本检查nginx服务状态</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/08/shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%9F%A5nginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/08/shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%9F%A5nginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</id>
    <published>2021-04-08T10:35:00.000Z</published>
    <updated>2021-04-08T10:36:20.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    service nginx start</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="脚本解析"><a href="#脚本解析" class="headerlink" title="脚本解析"></a>脚本解析</h3><p>以上是通过进程判断，也可以通过端口判断，如netstat -nlpt | grep nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@newyork ~]# netstat -nlpt | grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8801&#x2F;nginx: master</span><br></pre></td></tr></table></figure><p>以下，以进程为例详解，ps -C nginx –no-header<br>这里涉及ps 的用法，我们一般用ps查看相关进程，一般都是用ps -ef | grep XX 或 ps -aux| grep XX 的模式<br>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br><span class="line">root     11660  5532  0 09:55 pts&#x2F;1    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><p>但是这样通常都会覆盖一个grep的进程。</p><p>我们可以用ps -ef|grep nginx|grep -v grep的方式排除grep的进程，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@newyork ~]# ps -ef|grep nginx|grep -v grep</span><br><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>也可以直接用ps -C 或ps -c 的方式， -C 后面接命令的名字（推荐） ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  8801 ?        00:00:00 nginx</span><br><span class="line">  8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure><p>–no-header 就是去挑title,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx --no-header</span><br><span class="line"> 8801 ?        00:00:00 nginx</span><br><span class="line"> 8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure><p>wc -l 这个很熟悉了，行数计算</p><p>所以用这种方式可判断，如果<br>ps -C nginx –no-header|wc -l</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值为0，即代表服务未启动</span><br><span class="line">值为非0，即代表服务已启动</span><br></pre></td></tr></table></figure><p>最后，killall keepalived 这个是以服务名称杀死进程，日常中也用的挺多的</p><p>上面那段完整的脚本意思即为：<br>判断nginx 服务是否启动<br>如果未启动，执行启动命令<br>再次判断，如果启动失败，关掉keepalived，进入从节点</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/categories/shell/"/>
    
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>linux 后台运行、输出重定向</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2021-04-02T13:05:00.000Z</published>
    <updated>2021-04-12T17:22:20.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux termianl中，命令脚本的后台运行以及输出的重定向，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &gt; my.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &amp;&gt; my.log &amp;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>当启动一个服务后，希望命令在后台运行时，可以通过在命令末尾增加 &amp; ，例如：./test.sh &amp;，执行上述命令后，脚本开始在后台运行，并且命令行回显为 [1] 12532 ,这里的 1表示后台进程的编号，可以通过命令 fg 1 把进程切换回前台运行。</p><p>此时，虽然命令已经后台运行了，我们可以在控制台输入其他命令，但是脚本每秒打印的 x 会不断的输出到控制台，影响我们其他命令的执行，这时，我也需要用输出重定向把命令的执行结果输出的文件中。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>一个程序执行后，系统会生成三个句柄，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0&#x3D;stdin（标准输入）</span><br><span class="line">1&#x3D;stdout（标准输出）</span><br><span class="line">2&#x3D;stderr（错误输出）</span><br></pre></td></tr></table></figure><p>默认情况下，三个句柄都指向当前会话的命令行控制台。命令转到后台执行后，stdin关闭，stdout和stderr还是指向控制台。</p><p>通过在命令后使用输出重定向符 &gt; 实现对输出的重定向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout重定向到当前目录的run.log文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>表示把stdout和stderr都重定向到run.log，其中 2&gt;&amp;1 表示把stderr重定向到stdout。另外，其中&gt; run.log表示标准输出重定向到文件run.log中且是<strong>覆盖重写，如果想要追加方式写入，则是&gt;&gt; run.log</strong>。</p><p>Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。 </p><p>如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-) </p><p>另外+: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &amp;&gt; make_log</span><br></pre></td></tr></table></figure><p>意思是把标准输出和错误输出都重定向, <em>command&gt;out</em> 只重定向标准输出!!!!! </p><p><em>&gt;log</em> 表示把标准输出重新定向到文件log中 </p><p><em>&amp;&gt; log</em> 表示把标准输出和错误输出都定向到文件log中，相当于 <em>&gt;log 2&gt;&amp;1</em></p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>通过 &amp; 虽然可以把命令以后台进程的方式执行，但是如果SSH会话中断退出，和此会话相关的所有进程都会终止。<br>如果我们是登录服务器去启动一个服务程序，总不能启动后一直把SSH会话开着，而且会话到期会自动终止。</p><p>这是，我们可以使用 nohup（no hung up）来执行进程，此命令确保会话挂断后，命令可以继续运行。以nohup运行的命令，系统默认自动把stdout和stderr重定向到当前目录的nohup.out文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;run.py &amp;</span><br></pre></td></tr></table></figure><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><p>&amp;：已后台进程执行命令，但是会话关闭后，进程会结束。</p><p>nohup：确保进程不挂断的执行，但是没有后台执行的功能，所以一般nohup和&amp;需要配合一起使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;linux termianl中，命令脚本的后台运行以及输出的重定向，如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;gt; my.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nohup .&amp;#x2F;myshell.sh &amp;amp;&amp;gt; my.log &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu 开机启动管理</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-03-20T16:26:00.000Z</published>
    <updated>2021-04-12T17:24:50.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu自启服务管理命令</p><a id="more"></a><p>查看开机启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --type&#x3D;service|grep enabled</span><br></pre></td></tr></table></figure><p>以蓝牙为例，查询蓝牙服务是否开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled bluetooth.service</span><br></pre></td></tr></table></figure><p>如果是enable开机自启动<br>如果是disable不开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable bluetooth.service #开机运行服务</span><br><span class="line"></span><br><span class="line">systemctl disable bluetooth.service #取消开机运行</span><br><span class="line"></span><br><span class="line">sudo systemctl disable  bluetooth.service#关闭蓝牙服务</span><br><span class="line"></span><br><span class="line">systemctl start bluetooth.service #启动服务</span><br><span class="line"></span><br><span class="line">systemctl stop bluetooth.service #停止服务</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth.service #重启服务</span><br><span class="line"></span><br><span class="line">systemctl reload bluetooth.service #重新加载服务配置文件</span><br><span class="line"></span><br><span class="line">systemctl status bluetooth.service #查询服务运行状态</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu自启服务管理命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA激活</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/</id>
    <published>2021-03-20T07:01:00.000Z</published>
    <updated>2021-04-12T17:25:21.669Z</updated>
    
    <content type="html"><![CDATA[<p>可用方法：<a href="https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3" target="_blank" rel="noopener">IntelliJ IDEA 2020.3.3激活破解教程（亲测激活至 2099 年，长期更新）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可用方法：&lt;a href=&quot;https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA 2020.3.
      
    
    </summary>
    
    
    
      <category term="idea" scheme="http://blog.zhangzonglinagain.xyz/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>ssh 密码登录脚本</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</id>
    <published>2021-03-18T19:37:00.000Z</published>
    <updated>2021-04-12T17:25:59.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脚本密码登录服务器</p><a id="more"></a><p>1、安装expect<br>使用以下代码检测expect是否已经安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;usr&#x2F;bin | grep expect</span><br></pre></td></tr></table></figure><p>如果显示为空，则使用以下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure><p>2、 制作脚本<br>合适位置建个sh文件，脚本中写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh root@127.0.0.1 -p 22</span><br><span class="line">expect &quot;*Are you sure you want to continue connecting (yes&#x2F;no)?&quot;</span><br><span class="line">send &quot;yes\r&quot;</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;脚本密码登录服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="shell" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/shell/"/>
    
    
      <category term="ssh" scheme="http://blog.zhangzonglinagain.xyz/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 打开win10 txt中文乱码</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2021-03-18T19:05:00.000Z</published>
    <updated>2021-03-18T19:15:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。</p><a id="more"></a><p>1、原因<br>ubuntu系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件）则vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），最终显示文件为乱码。</p><p>2、解决办法<br>在<em>/home/user/*下修改</em>.vimrc*文件（系统新装，默认情况下尚未创建）。 编辑 ~/.vimrc 文件（ 添加如下几行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set fileencodings&#x3D;utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding&#x3D;utf-8</span><br><span class="line">set encoding&#x3D;utf-8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下使用微信、QQ等</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/new/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/new/</id>
    <published>2021-03-17T19:32:00.000Z</published>
    <updated>2021-03-18T01:38:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。</p><a id="more"></a><p>网上教程多如牛毛，但不是坑，就是坑，找了个自己能用的，记录下备用<br>1、安装docker docker-compose，网上教程一大把，自己搜<br>2、执行如下命令<br>首先要允许所有用户访问X11服务,运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></table></figure><p>拉取镜像（注意docker设置国内镜像地址，用科大的就行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull bestwu&#x2F;wechat</span><br></pre></td></tr></table></figure><p>在你指定的文件夹下创建 docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">  wechat:</span><br><span class="line">    image: bestwu&#x2F;wechat</span><br><span class="line">    container_name: wechat</span><br><span class="line">    devices:</span><br><span class="line">      - &#x2F;dev&#x2F;snd</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;tmp&#x2F;.X11-unix:&#x2F;tmp&#x2F;.X11-unix</span><br><span class="line">      - $PWD&#x2F;WeChatFiles:&#x2F;WeChatFiles</span><br><span class="line">    environment:</span><br><span class="line">      - DISPLAY&#x3D;unix$DISPLAY</span><br><span class="line">      - QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">      - GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - AUDIO_GID&#x3D;26 # 可选 默认63（在终端用getent group video | cut -d: -f3查） 主机audio gid 解决声音设备访问权限问题</span><br><span class="line">      - GID&#x3D;1000 # 可选 默认1000 主机当前用户 gid 解决挂载目录访问权限问题</span><br><span class="line">      - UID&#x3D;1000 # 可选 默认1000 主机当前用户 uid 解决挂载目录访问权限问题</span><br><span class="line">    ipc: host</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="wechat" scheme="http://blog.zhangzonglinagain.xyz/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自动挂载其他盘</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ceshi/</id>
    <published>2021-03-17T19:12:00.000Z</published>
    <updated>2021-04-12T17:26:32.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p><a id="more"></a><p>1、查询挂载硬盘UUID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p><p>2、打开文件/etc/fstab文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>在文档末尾添加相应磁盘的信息。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p><p>3、重启生效</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu terminal 打开后的默认位置和大小</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/18/ubuntu-terminal-location/</id>
    <published>2021-03-17T17:28:00.000Z</published>
    <updated>2021-03-17T19:12:15.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。</p><a id="more"></a><p>网传的一般有两种，一种是自定义快捷键，一种是修改<em>/usr/share/applications/gnome-terminal.desktop</em>。第二种效果只是修改了“通过菜单栏或鼠标点击进入终端时的位置”，用<em>Ctrl+Alt+T</em>进入时，没有效果，所以本文选择第一种，步骤如下：</p><p>1、打开一个终端，把它调整到自己想要的大小和位置</p><p>2、在终端内执行xwininfo，鼠标变成十字，然后鼠标点击终端，出现终端窗口的信息，注意最后一行： -geometry 80x24-4+168</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>3、依次进入Setting - Devices - keyboard，可以看到系统的所有快捷键设置，包括<em>Launch terminal Ctrl+Alt+T</em>。拉到最下面，点击+号</p><p><img src="/images/pasted-31.png" alt="upload successful"></p><p>Name自己取，主要是Command,输入步骤2的大小坐标信息，  <em>gnome-terminal –geometry=80x24-4+168</em> ，Shortcut自定义即可，注意不要跟现存的快捷键冲突。我自己是用的Super+T。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="terminal" scheme="http://blog.zhangzonglinagain.xyz/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中vim的粘帖复制</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-16T17:13:00.000Z</published>
    <updated>2021-04-12T17:27:38.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。</p><a id="more"></a><h3 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h3><h4 id="默认剪贴板"><a href="#默认剪贴板" class="headerlink" title="默认剪贴板"></a>默认剪贴板</h4><p>vim会有一些存储空间来暂存内容，vim中将这些存储空间叫寄存器。此寄存器非我们硬件所说的寄存器，可以理解为是一种cache。例如我们在vim中y操作复制的内容，实际就是暂存到寄存器中。</p><p>如下，在vim中执使用:reg命令，可以查看各个寄存器的内容。<br><img src="/images/pasted-27.png" alt="upload successful"></p><p>其中有两个特殊的寄存器: “* 和 “+。前者关联系统选择缓冲区(Buffer)，后者关联系统剪切板(Clipboard)，关于系统剪切板的使用见下文。</p><h4 id="复制和粘贴到指定剪贴板"><a href="#复制和粘贴到指定剪贴板" class="headerlink" title="复制和粘贴到指定剪贴板"></a>复制和粘贴到指定剪贴板</h4><p>要把vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后（按Esc），按 *”Ny* 完成复制，其中N表示特定寄存器编号（注意是按一下双引号然后按粘贴板号最后按y），例如要把内容复制到系统剪切板，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+y</span><br></pre></td></tr></table></figure><p>就可以了。注意的是，上面是 双引号 + 加号寄存器 + y。通过这命令copy后就可以去浏览器Ctrl+v了。</p><p>如果从浏览器Ctrl+c后，要粘贴到vim中，则需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;+p</span><br></pre></td></tr></table></figure><h3 id="系统剪切板及使用"><a href="#系统剪切板及使用" class="headerlink" title="系统剪切板及使用"></a>系统剪切板及使用</h3><h4 id="查看-Vim-是否支持系统剪切板"><a href="#查看-Vim-是否支持系统剪切板" class="headerlink" title="查看 Vim 是否支持系统剪切板"></a>查看 Vim 是否支持系统剪切板</h4><p>刚重装了系统，命令按了半天，跑到其他地方Ctrl+v，什么也没有，原来是系统剪切板不支持的锅。<br>在终端输入 <em>vim –version | grep clipboard</em>回车：<br><img src="/images/pasted-28.png" alt="upload successful"><br>如果 clipboard 前面都是 - 号，说目前还不支持系统剪切板功能，请继续看下一节，如果都是 + 号，略过此节。</p><h4 id="开启系统剪切板功能"><a href="#开启系统剪切板功能" class="headerlink" title="开启系统剪切板功能"></a>开启系统剪切板功能</h4><p>开启系统剪切板功能的方法也有很多，比较正统的应该是重新编译安装 Vim 源码，因为我怕麻烦（水平渣），所以选择简单的方法，即安装 vim-gnome。<br>一行指令即可搞定，在终端输入 <em>sudo apt install vim-gnome -y</em>回车。<br>此时再次使用上述的两个方法验证，发现 Vim 已经支持系统剪切板功能。</p><h3 id="vim内部复制、粘贴、剪切"><a href="#vim内部复制、粘贴、剪切" class="headerlink" title="vim内部复制、粘贴、剪切"></a>vim内部复制、粘贴、剪切</h3><h4 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h4><p>在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v+光标移动 （按字符选择）高亮选中所要的文本，然后进行各种操作（比如粘帖到系统剪切板“+y）。</span><br><span class="line">V （按行选择）</span><br><span class="line">v+选中的内容+c 更改选中的文字</span><br></pre></td></tr></table></figure><h4 id="复制：y-ank"><a href="#复制：y-ank" class="headerlink" title="复制：y(ank)"></a>复制：y(ank)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y 用v命令选中文本后，用y进行复制</span><br><span class="line">yy 复制当前行，然后用p进行粘贴</span><br><span class="line">5yy 复制从当前行开始的5行</span><br><span class="line">y_ 等同于yy</span><br><span class="line">Y 等同于yy</span><br><span class="line">yw 复制当前单词</span><br><span class="line">y$ 从当前位置复制到行尾</span><br><span class="line">y0 从当前位置复制到行首</span><br><span class="line">y^ 从当前位置复制到第一个非空白字符</span><br><span class="line">yG 从当前行复制到文件结束</span><br><span class="line">y20G 从当前行复制到第20行</span><br><span class="line">y?bar 复制至上一个出现bar的位置</span><br></pre></td></tr></table></figure><h4 id="粘贴：p-aste"><a href="#粘贴：p-aste" class="headerlink" title="粘贴：p(aste)"></a>粘贴：p(aste)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p(小写) 在光标位置之后粘贴</span><br><span class="line">P(大写) 在光标位置之前粘贴</span><br></pre></td></tr></table></figure><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v + 方向键(hjkl)选中内容 + d 剪切 + p粘贴</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="vim复制到系统剪贴板"><a href="#vim复制到系统剪贴板" class="headerlink" title="vim复制到系统剪贴板"></a>vim复制到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;*y</span><br><span class="line">&quot;+y</span><br><span class="line">&quot;+2yy – 复制两行</span><br><span class="line">&#123;Visual&#125;&quot;+y - copy the selected text into the system clipboard</span><br><span class="line">&quot;+y&#123;motion&#125; - copy the text specified by &#123;motion&#125; into the system clipboard</span><br><span class="line">:[range]yank + - copy the text specified by [range] into the system clipboard</span><br></pre></td></tr></table></figure><h5 id="vim剪切到系统剪贴板"><a href="#vim剪切到系统剪贴板" class="headerlink" title="vim剪切到系统剪贴板"></a>vim剪切到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;+dd – 剪切一行</span><br><span class="line">从系统剪贴板粘贴到vim</span><br><span class="line">&quot;*p</span><br><span class="line">&quot;+p</span><br><span class="line">Shift+Insert</span><br><span class="line">:put + - Ex command puts contents of system clipboard on a new line</span><br><span class="line">&lt;C-r&gt;+ - From insert mode (or commandline mode)</span><br><span class="line">&quot;+p比 Ctrl-v 命令更好，它可以更快更可靠地处理大块文本的粘贴，也能够避免粘贴大量文本时，发生每行行首的自动缩进累积，因为Ctrl-v是通过系统缓存的stream处理，一行一行地处理粘贴的文本。</span><br></pre></td></tr></table></figure><p>参考：<strong><a href="https://liushiming.cn/article/copy-and-paste-in-vim.html" target="_blank" rel="noopener">一文搞懂vim复制粘贴</a></strong>、<strong><a href="https://blog.csdn.net/jpch89/article/details/93915710" target="_blank" rel="noopener">打开 Ubuntu 18 中 Vim 的系统剪切板功能</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
      <category term="ubuntu" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/ubuntu/"/>
    
    
      <category term="vim" scheme="http://blog.zhangzonglinagain.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>巧记linux常用命令中的递归参数-r(R)和-p</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/</id>
    <published>2021-03-08T18:38:00.000Z</published>
    <updated>2021-03-08T18:39:29.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/longyamiao/article/details/79782254" target="_blank" rel="noopener">巧记linux常用命令中的递归参数-r(R)和-p</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/longyamiao/article/details/79782254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;巧记linux常用命令中的递归参数-r(R)和-p&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux sort uniq命令</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/26/linux-sort-uniq%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/26/linux-sort-uniq%E5%91%BD%E4%BB%A4/</id>
    <published>2021-02-25T19:03:00.000Z</published>
    <updated>2021-04-12T17:28:12.406Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.linuxjournal.com/content/back-basics-sort-and-uniq" target="_blank" rel="noopener">Back to Basics: Sort and Uniq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.linuxjournal.com/content/back-basics-sort-and-uniq&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Back to Basics: Sort and Uniq&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 查看登录历史 操作用户</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/26/linux-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E5%8E%86%E5%8F%B2-%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/26/linux-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E5%8E%86%E5%8F%B2-%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7/</id>
    <published>2021-02-25T18:31:00.000Z</published>
    <updated>2021-02-25T18:45:24.291Z</updated>
    
    <content type="html"><![CDATA[<p>linux 查看登录历史 操作用户</p><a id="more"></a><h2 id="linux查看用户登录，操作历史等"><a href="#linux查看用户登录，操作历史等" class="headerlink" title="linux查看用户登录，操作历史等"></a>linux查看用户登录，操作历史等</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">who 命令：显示当前当登录的用户的信息</span><br><span class="line">who -b命令：显示系统最近一次的启动时间</span><br><span class="line">w 命令：显示登录的用户及其当前执行的任务</span><br><span class="line">last 命令：显示当前与过去登录系统的用户的信息</span><br><span class="line">lastb 命令：显示所有登录系统失败的用户的信息</span><br><span class="line">lastlog 命令：显示用户最后一次登录的信息</span><br><span class="line">history 命令：查看操作历史</span><br><span class="line">history -c命令：清除操作历史</span><br><span class="line">pkill -kill -u test ： 强制test用户下线</span><br></pre></td></tr></table></figure><h2 id="linux清除系统日志、历史记录、登录信息"><a href="#linux清除系统日志、历史记录、登录信息" class="headerlink" title="linux清除系统日志、历史记录、登录信息"></a>linux清除系统日志、历史记录、登录信息</h2><h3 id="清楚日志"><a href="#清楚日志" class="headerlink" title="清楚日志"></a>清楚日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;wtmp &#x2F;&#x2F;清除用户登录记录</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;btmp &#x2F;&#x2F;清除尝试登录记录</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;lastlog &#x2F;&#x2F;清除最近登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;syslog &#x2F;&#x2F;记录系统日志的服务</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;xferlog</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;auth.log</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;user.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;adm&#x2F;sylog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;maillog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;openwebmail.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;mail.info</span><br><span class="line">echo&gt;&#x2F;var&#x2F;run&#x2F;utmp</span><br></pre></td></tr></table></figure><h3 id="清除操作过的命令记录"><a href="#清除操作过的命令记录" class="headerlink" title="清除操作过的命令记录"></a>清除操作过的命令记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; .bash_history &#x2F;&#x2F;清除保存的用户操作历史记录</span><br><span class="line">history -cw &#x2F;&#x2F;清除所有历史</span><br></pre></td></tr></table></figure><h3 id="Linux查看History记录加时间戳小技巧"><a href="#Linux查看History记录加时间戳小技巧" class="headerlink" title="Linux查看History记录加时间戳小技巧"></a>Linux查看History记录加时间戳小技巧</h3><p>熟悉bash的都一定知道使用history可以输出你曾经输入过的历史命令，例如  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@servyou_web ~]# history | more</span><br><span class="line">.&#x2F;test.sh</span><br><span class="line">vim test.sh</span><br><span class="line">.&#x2F;test.sh</span><br></pre></td></tr></table></figure><p>但是这里只显示了命令，并没有显示执行命令的时间，因为保存历史命令的~/.bash_history里并没有保存时间。</p><p>通过设置环境变量 export HISTTIMEFORMAT=”%F %T whoami “ 给history加上时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@servyou_web ~]# export HISTTIMEFORMAT&#x3D;&quot;%F %T whoami &quot;</span><br><span class="line">[root@servyou_web ~]# history | tail</span><br><span class="line">2011-06-22 19:17:29 root 15 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 16 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 17 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 18 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 19 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 20 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 21 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:22 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:28 root history | tail</span><br></pre></td></tr></table></figure><p>可以看到，历史命令的时间戳已经加上了，但是.bash_history里并没有加上这个时间戳。其实这个时间记录是保存在当前shell进程内存里的，如果你logout并且重新登录的话会发现你上次登录时执行的那些命令的时间戳都为同一个值，即当时logout时的时间。</p><p>尽管如此，对于加上screen的bash来说，这个时间戳仍然可以长时间有效的，毕竟只要你的server不重启，screen就不会退出，因而这些时间就能长时间保留。你也可以使用echo ‘export HISTTIMEFORMAT=”%F %T whoami “‘ &gt;&gt; /etc/profile 然后source一下就OK。</p><p><a href="https://blog.51cto.com/study2008/2301555" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux 查看登录历史 操作用户&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.zhangzonglinagain.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SkipList (跳跃表)的那点事儿</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</id>
    <published>2021-02-22T18:13:00.000Z</published>
    <updated>2021-04-12T17:28:47.463Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c" target="_blank" rel="noopener">SkipList 的那点事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
      <category term="SkipList" scheme="http://blog.zhangzonglinagain.xyz/tags/SkipList/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhangzonglinagain.xyz/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-22T17:51:27.000Z</published>
    <updated>2021-02-22T17:51:56.236Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/yw09041432/p/5908444.html" target="_blank" rel="noopener">七大查找算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yw09041432/p/5908444.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;七大查找算法&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
