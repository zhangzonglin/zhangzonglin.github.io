<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglin.xyz/"/>
  <updated>2020-06-07T04:38:03.208Z</updated>
  <id>http://blog.zhangzonglin.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>websocket --Token Authentication</title>
    <link href="http://blog.zhangzonglin.xyz/2020/06/07/websocket-Token-Authentication/"/>
    <id>http://blog.zhangzonglin.xyz/2020/06/07/websocket-Token-Authentication/</id>
    <published>2020-06-07T03:01:52.000Z</published>
    <updated>2020-06-07T04:38:03.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链接：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication" target="_blank" rel="noopener">STOMP–Token Authentication</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;链接：&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framewor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cors--springboot shiro 前后端分离跨域</title>
    <link href="http://blog.zhangzonglin.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/"/>
    <id>http://blog.zhangzonglin.xyz/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-05-18T14:55:00.000Z</published>
    <updated>2020-06-08T12:05:21.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。</p><a id="more"></a><h3 id="跨域的两种方案"><a href="#跨域的两种方案" class="headerlink" title="跨域的两种方案"></a>跨域的两种方案</h3><h4 id="沿用Cookie"><a href="#沿用Cookie" class="headerlink" title="沿用Cookie"></a>沿用Cookie</h4><p>沿用传统的cookie session方式，就需要前后端分别设置，可以让前端的request带上后端域名对应的cookie</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>客户端需要设置Ajax请求属性withCredentials 为true，让Ajax请求都带上Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">           url:url,</span><br><span class="line">           type:&quot;GET&quot;,</span><br><span class="line">           xhrFields:&#123;</span><br><span class="line">               withCredentials:true</span><br><span class="line">           &#125;,</span><br><span class="line">           success:function(res)&#123; </span><br><span class="line">               console.log(res);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>首先服务端在使用cors协议时需要设置响应消息头<em>Access-Control-Allow-Credentials<em>的值为</em>true*，即允许在ajax访问时携带cookie(如上，前端也要设置withCredentials为true)。另外为了安全，在cors标准里不允许Access-Control-Allow-Origin设置为</em>,而是必须指定明确的、与请求网页一致的域名，cookie也依然遵循“同源策略”，只有用目标服务器域名设置的cookie才会上传，而且使用document.cookie也无法读取目标服务器域名下的cookie。接下来我们来看看实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">]</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)     &#x2F;&#x2F; 此时，不允许为*</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">&#x2F;&#x2F;            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义http-header"><a href="#自定义http-header" class="headerlink" title="自定义http header"></a>自定义http header</h4><p>绕过cookie，自定义http header传输token(本项目token即sessionId)，这种方式适合前端不支持cookie的时候，具体设置在后文中。</p><h3 id="session管理"><a href="#session管理" class="headerlink" title="session管理"></a>session管理</h3><p>采用第二种方式，就需要绕过传统的sessionid传输方式：通过请求头里的cookie传输（浏览器的cookie是跟着域名走的）。客户端登录，服务端通过JSON返回sessionid，客户端保存，后续每次请求要在请求头中添加加token字段，服务端shiro根据请求头的token字段获取sessionid。<br>shiroConfiguration中的securityManager配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        manager.sessionManager &#x3D; sessionManager()</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun sessionManager(): SessionManager? &#123;</span><br><span class="line">        val mySessionManager &#x3D; MySessionManager()</span><br><span class="line">        mySessionManager.setSessionDAO(sessionDAO())</span><br><span class="line">        return mySessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是在MySessionManager里重写DefaultWebSessionManager的getSessionId方法和retrieveSession方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.apache.shiro.session.Session</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey</span><br><span class="line">import org.apache.shiro.web.servlet.ShiroHttpServletRequest</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line">import org.apache.shiro.web.util.WebUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import java.io.Serializable</span><br><span class="line">import java.lang.Boolean</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class MySessionManager : DefaultWebSessionManager&#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var log &#x3D; LoggerFactory.getLogger(this.javaClass.name)</span><br><span class="line">        private val AUTHORIZATION &#x3D; &quot;auth-token&quot;</span><br><span class="line">        private val HEADER_SESSION_ID_SOURCE &#x3D; &quot;header request&quot;</span><br><span class="line">        private val MY_SESSION_ATTRIBUTE &#x3D; &quot;MY_SESSION_ATTRIBUTE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override fun getSessionId(request: ServletRequest, response: ServletResponse?): Serializable? &#123;</span><br><span class="line">        val id &#x3D; WebUtils.toHttp(request).getHeader(AUTHORIZATION)</span><br><span class="line">        &#x2F;&#x2F;如果请求头中有 Authorization 字段， 则其值为sessionId</span><br><span class="line">        return if (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, HEADER_SESSION_ID_SOURCE)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE)</span><br><span class="line">            id</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;否则按默认规则从cookie取sessionId</span><br><span class="line">            super.getSessionId(request, response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(UnknownSessionException::class)</span><br><span class="line">    protected override fun retrieveSession(sessionKey: SessionKey?): Session? &#123;</span><br><span class="line">        val sessionId &#x3D; getSessionId(sessionKey) ?: return null</span><br><span class="line">        val request: ServletRequest &#x3D; WebUtils.getRequest(sessionKey)</span><br><span class="line">        return if (request.getAttribute(MY_SESSION_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">            log.debug(&quot;Get Session from request!&quot;)</span><br><span class="line">            request.getAttribute(MY_SESSION_ATTRIBUTE) as Session</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Get Session from redis!&quot;)</span><br><span class="line">            val s: Session &#x3D; retrieveSessionFromDataSource(sessionId)</span><br><span class="line">            if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;session ID was provided, meaning one is expected to be found, but we couldn&#39;t find one:</span><br><span class="line">                val msg &#x3D; &quot;Could not find session with ID [$sessionId]&quot;</span><br><span class="line">                throw UnknownSessionException(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            request.setAttribute(MY_SESSION_ATTRIBUTE, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>  对于简单请求，浏览器直接在ruquest头之中，增加一个Origin字段，相应地，服务器会在response头中添加Access-Control-Allow-Origin等字段，如此便是一次成功的跨域请求。</p><p><img src="/images/pasted-24.png" alt="upload successful"><br>只要同时满足以下两大条件，就属于简单请求。</p><p>请求方法是以下三种方法之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure><p>HTTP的头信息不超出以下几种字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight），预检的请求方法（Request Method）为OPTION。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义过滤器，针对请求头中有Origin字段的，response头中添加相应字段，针对OPITION请求,response返回200状态码。<br>新建CorsFilter类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.http.HttpStatus</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod</span><br><span class="line">import javax.servlet.*</span><br><span class="line">import javax.servlet.http.HttpServletRequest</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@WebFilter(urlPatterns &#x3D; arrayOf(&quot;&#x2F;*&quot;),filterName &#x3D; &quot;crosFilter&quot;)</span><br><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">            logger.info(&quot;处理跨域请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立WebFilterConfig类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean</span><br><span class="line">import org.springframework.context.annotation.Bean</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import javax.servlet.Filter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1：自定义过滤器，可以采取Filter加@WebFilter和启动类加@ServletComponentScan的方式，过滤器的执行顺序按照类名排序</span><br><span class="line"> * 故而采用如下FilterRegistrationBean的方式，可以自定义顺序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">class WebFilterConfig&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun crosResFilter(): FilterRegistrationBean&lt;*&gt;? &#123;</span><br><span class="line">        val filterRegistrationBean: FilterRegistrationBean&lt;Filter?&gt; &#x3D; FilterRegistrationBean&lt;Filter?&gt;()</span><br><span class="line">        val corsFilter &#x3D; CorsFilter()</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter)</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;) &#x2F;&#x2F;配置过滤规则</span><br><span class="line">        filterRegistrationBean.setName(&quot;corsFilter&quot;) &#x2F;&#x2F;设置过滤器名称</span><br><span class="line">        filterRegistrationBean.order &#x3D; 1 &#x2F;&#x2F;执行次序</span><br><span class="line">        return filterRegistrationBean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此便能愉快的跨域访问了。</p><h3 id="shiro跳转"><a href="#shiro跳转" class="headerlink" title="shiro跳转"></a>shiro跳转</h3><p>由于shiro对前后端分离支持不是很理想，如访问需认证的路径，若未登录会直接跳转至登录页面（默认是/login.jsp），这中情况我们需要直接返回未认证的JSON数据，由前端控制路由。<br>新建MyFormAuthenticationFilter，继承shiro的FormAuthenticationFilter（对应过滤authc的路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.JsonUtils</span><br><span class="line">import com.example.customer.util.constants.ErrorEnum</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line">class MyFormAuthenticationFilter : FormAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val log &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun onAccessDenied(request: ServletRequest?, response: ServletResponse?): Boolean &#123;</span><br><span class="line">        return if (isLoginRequest(request, response)) &#123;</span><br><span class="line">            if (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                executeLogin(request, response)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login page view.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;allow them to see the login page ;)</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var resp &#x3D; response as HttpServletResponse</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +</span><br><span class="line">                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不再跳转，直接返回Json信息</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.getWriter().write(JsonUtils.errorJson(ErrorEnum.E_401).toString())</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在shiro过滤链中，添加自定义过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class ShiroConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * shiro过滤器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun shiroFilter(manager: SecurityManager) : ShiroFilterFactoryBean&#123;</span><br><span class="line">        val factoryBean &#x3D; ShiroFilterFactoryBean()</span><br><span class="line">        &#x2F;&#x2F;设置securityManager</span><br><span class="line">        factoryBean.securityManager &#x3D; manager</span><br><span class="line">        &#x2F;&#x2F;自定义过滤器,修改认证失败跳转</span><br><span class="line">        val filters &#x3D; mutableMapOf&lt;String,Filter&gt;()</span><br><span class="line">        filters.put(&quot;myauthc&quot;,myFormAuthenticationFilter())</span><br><span class="line">        factoryBean.filters &#x3D;  filters</span><br><span class="line"></span><br><span class="line">        val filterChainDefinitionMap: MutableMap&lt;String, String&gt; &#x3D; LinkedHashMap()</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;static&#x2F;**&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 静态资源匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;doLogin&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;logout&quot;] &#x3D; &quot;logout&quot; &#x2F;&#x2F; 用户退出，只需配置logout即可实现该功能</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;**&quot;] &#x3D; &quot;myauthc&quot; &#x2F;&#x2F; 其他路径均需要身份认证，一般位于最下面，优先级最低</span><br><span class="line">        &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面</span><br><span class="line">        &#x2F;&#x2F;身份认证失败，不直接Shiro跳转至默认登录页，而是跳转至未认证接口，返回Json数据，前后端分离中登录界面跳转应由前端路由控制</span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F; factoryBean.setLoginUrl(&quot;&#x2F;login&#x2F;unauth&quot;);</span><br><span class="line">        &#x2F;&#x2F; 权限认证失败，跳转后续处理</span><br><span class="line"> &#x2F;&#x2F;       factoryBean.setUnauthorizedUrl(&quot;&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap)</span><br><span class="line"></span><br><span class="line">        return factoryBean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private fun myFormAuthenticationFilter(): MyFormAuthenticationFilter&#123;</span><br><span class="line">        return MyFormAuthenticationFilter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *securityManager配置</span><br><span class="line">     * 不指定名字的话，自动创建一个方法名第一个字母小写的bean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglin.xyz/categories/kotlin/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglin.xyz/categories/kotlin/shiro/"/>
    
      <category term="springboot" scheme="http://blog.zhangzonglin.xyz/categories/kotlin/shiro/springboot/"/>
    
    
      <category term="cors" scheme="http://blog.zhangzonglin.xyz/tags/cors/"/>
    
      <category term="shiro" scheme="http://blog.zhangzonglin.xyz/tags/shiro/"/>
    
      <category term="spring boot" scheme="http://blog.zhangzonglin.xyz/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 构造函数</title>
    <link href="http://blog.zhangzonglin.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.zhangzonglin.xyz/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-17T06:28:00.000Z</published>
    <updated>2020-05-17T06:51:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.cnblogs.com/Jetictors/p/7758828.html" target="_blank" rel="noopener">Kotlin——中级篇（一）：类（class）详解</a></strong>、<strong><a href="https://www.jianshu.com/p/5db34354d812" target="_blank" rel="noopener">kotlin之构造函数(constructor)</a></strong><br>1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。</p><p>2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派</p><a id="more"></a><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test constructor(num: Int)&#123;</span><br><span class="line">    constructor(num : Int, num2: Int) : this(num) &#123;</span><br><span class="line">        println(num + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：二级构造函数中的参数1(num)，是委托了主构造函数的参数num。</span><br></pre></td></tr></table></figure><p>3、在JVM上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。<br>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Jetictors/p/7758828.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin——中级篇（一）：类（class）详解&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/5db34354d812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin之构造函数(constructor)
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。&lt;/p&gt;
&lt;p&gt;2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派&lt;/p&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglin.xyz/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://blog.zhangzonglin.xyz/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>json web token(jwt)</title>
    <link href="http://blog.zhangzonglin.xyz/2020/05/02/json-web-token-jwt/"/>
    <id>http://blog.zhangzonglin.xyz/2020/05/02/json-web-token-jwt/</id>
    <published>2020-05-02T14:13:00.000Z</published>
    <updated>2020-05-02T14:18:28.928Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://learnku.com/articles/22616" target="_blank" rel="noopener">别再使用 JWT 作为 Session 系统！问题重重且很危险。</a></strong><br>结论：无状态 JWT Tokens 无法被单独地销毁或更新，取决于你如何存储，可能还会导致长度问题、安全隐患。有状态 JWT Tokens 在功能方面与 Session cookies 无异，但缺乏生产环境的验证、经过大量 Review 的实现，以及良好的客户端支持。<br>JWT 特别有效的使用例子通常是作为一次性的授权令牌。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://learnku.com/articles/22616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别再使用 JWT 作为 Session 系统！问题重重且很危险。
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="jwt" scheme="http://blog.zhangzonglin.xyz/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之IP、MAC</title>
    <link href="http://blog.zhangzonglin.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/"/>
    <id>http://blog.zhangzonglin.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/</id>
    <published>2020-04-14T02:31:00.000Z</published>
    <updated>2020-04-14T02:34:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.wmathor.com/index.php/archives/1124/" target="_blank" rel="noopener">MAC 地址与 IP 地址</a></strong>、<strong><a href="https://zhuanlan.zhihu.com/p/82184208" target="_blank" rel="noopener">物理层 和 MAC 层</a></strong>、<strong><a href="https://www.jianshu.com/p/63fd0faa47da" target="_blank" rel="noopener">网络传输中的三张表，MAC地址表、ARP缓存表以及路由表详解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.wmathor.com/index.php/archives/1124/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MAC 地址与 IP 地址&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.zhangzonglin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="MAC" scheme="http://blog.zhangzonglin.xyz/tags/MAC/"/>
    
      <category term="IP" scheme="http://blog.zhangzonglin.xyz/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>锁、synchronized、CAS、volatile</title>
    <link href="http://blog.zhangzonglin.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/"/>
    <id>http://blog.zhangzonglin.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/</id>
    <published>2020-04-06T10:42:00.000Z</published>
    <updated>2020-04-06T10:49:03.174Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></strong>、<strong><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></strong>、<strong><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/12129120.html" target="_blank" rel="noopener">从原子类和UNSAFE来理解JAVA内存模型，ATOMICINTEGER的INCREMENTANDGET方法和UNSAFE部分源码介绍，VALUEOFFSET偏移量的理解</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9396834.html" target="_blank" rel="noopener">JAVA内存模型中VOLATILE关键字的作用</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9399881.html" target="_blank" rel="noopener">JAVA内存模型，为啥线程要有自己的本地内存，CPU高速缓存</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不可不说的Java“锁”事&lt;/a&gt;&lt;/strong&gt;、&lt;strong
      
    
    </summary>
    
    
    
      <category term="lock" scheme="http://blog.zhangzonglin.xyz/tags/lock/"/>
    
      <category term="synchronized" scheme="http://blog.zhangzonglin.xyz/tags/synchronized/"/>
    
      <category term="CAS" scheme="http://blog.zhangzonglin.xyz/tags/CAS/"/>
    
      <category term="volatile" scheme="http://blog.zhangzonglin.xyz/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP之NAT</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/</id>
    <published>2020-03-27T10:12:00.000Z</published>
    <updated>2020-03-27T10:13:19.218Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.mobilezhao.com/?cat=3" target="_blank" rel="noopener">TCP/IP之NAT</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.mobilezhao.com/?cat=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP/IP之NAT&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="tcp/ip" scheme="http://blog.zhangzonglin.xyz/categories/tcp-ip/"/>
    
    
      <category term="nat" scheme="http://blog.zhangzonglin.xyz/tags/nat/"/>
    
  </entry>
  
  <entry>
    <title>补码原理的个人理解</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-03-20T07:25:00.000Z</published>
    <updated>2020-03-20T07:26:25.818Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/jiaobuchong/article/details/83188674" target="_blank" rel="noopener">补码原理的个人理解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/jiaobuchong/article/details/83188674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;补码原理的个人理解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://blog.zhangzonglin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="补码" scheme="http://blog.zhangzonglin.xyz/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《Spring设计思想-事务篇》2.数据库隔离级别</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-03-12T09:32:48.000Z</published>
    <updated>2020-03-12T09:37:29.516Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">《Spring设计思想-事务篇》2.数据库隔离级别</a></strong></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。</p><a id="more"></a><p>事务的并发数和数据数据一致性这两个是两个相反的理想指标。而数据库研发的方向就是尽可能提高同时提高两个指标，尽可能减少之间的反作用影响。</p><p>SERIALIZABLE 序列化读，隔离级别最高，客户端以互斥的方式访问数据库资源，统一时间内，同一个资源只能被一个客户端访问，好像客户端在排队请求访问，所以称为序列化读。<br>REPEATABLE_READ 可重复读，可重复读能够保证，一个客户端在一个事务内，多次访问同一个资源时，返回结果是一样的，顾名思义，称为可重复读，这种隔离级别可能会造成幻读现象。<br>READ_COMMITTED 读已提交，即客户端在一个事务内，每次查询读取的数据都是从数据库读取最新的已提交的数据；这种隔离界别可能会造成不可重复读和幻读现象。<br>READ_UNCOMMITTED 读未提交，即客户端在一个事务内，可以读取到其他客户端事务的尚未提交的数据；这种隔离级别可能会造成脏读、不可重复读、幻读 现象。</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>————————————————<br>版权声明：本文为CSDN博主「亦山」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/95319795</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/95319795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想-事务篇》2.数据库隔离级别
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《Spring设计思想》AOP设计基本原理</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-11T14:32:00.000Z</published>
    <updated>2020-03-11T14:34:40.664Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">《Spring设计思想》AOP设计基本原理</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/51095702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想》AOP设计基本原理
&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglin.xyz/tags/spring/"/>
    
      <category term="aop" scheme="http://blog.zhangzonglin.xyz/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/</id>
    <published>2020-03-11T06:07:04.000Z</published>
    <updated>2020-03-11T14:24:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/24589193&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java动态代理机制详解（JDK 和CGLIB，Java
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring 线程安全</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-03-09T06:46:00.000Z</published>
    <updated>2020-03-09T07:15:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/kismetv/p/8757260.html" target="_blank" rel="noopener"><strong>Spring中获取request的几种方法，及其线程安全性分析</strong></a>、<strong><a href="https://www.jianshu.com/p/e04491f3550f" target="_blank" rel="noopener">Spring 如何保证线程安全</a></strong>、<strong><a href="https://blog.csdn.net/cs408/article/details/48972653" target="_blank" rel="noopener">Spring中Singleton模式的线程安全</a></strong></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作</p><a id="more"></a><p>数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧。并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该栈帧并释放掉。</p><p>&emsp;注意：Java栈中的数据是线程私有的，一个线程是无法访问另一个线程的Java栈的数据。这也就是为什么多线程编程时，两个相同线程执行同一方法时，对方法内的局部变量是不需要数据同步的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/8757260.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Spring中获取request的几种方法，及其线程安全性分析&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/e04491f3550f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 如何保证线程安全
&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/cs408/article/details/48972653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring中Singleton模式的线程安全
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;备注&quot;&gt;&lt;a href=&quot;#备注&quot; class=&quot;headerlink&quot; title=&quot;备注&quot;&gt;&lt;/a&gt;备注&lt;/h3&gt;&lt;p&gt;&amp;emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglin.xyz/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>jvm-invokeinterface</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/09/vm-invokeinterface/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/09/vm-invokeinterface/</id>
    <published>2020-03-09T05:57:00.000Z</published>
    <updated>2020-03-09T06:01:48.588Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://blog.csdn.net/kang389110772/article/details/50723127" target="_blank" rel="noopener">Spring为什么Autowired注入的是接口</a>、</p><p><a href="https://github.com/1993hzh/thoughts/issues/5" target="_blank" rel="noopener">浅析JVM中invokevirtual与invokeinterface的区别 #5</a>、</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.3" target="_blank" rel="noopener">Java Virtual Machine Specification</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/kang389110772/article/details/50723127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring为什么Autowired注入的是接口
&lt;/a&gt;、&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="jvm" scheme="http://blog.zhangzonglin.xyz/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java底层机制（堆/栈/方法区/GC/类加载）</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-08T13:21:00.000Z</published>
    <updated>2020-03-11T09:15:36.601Z</updated>
    
    <content type="html"><![CDATA[<p>转载:<strong><a href="https://www.jianshu.com/p/ae97b692614e?from=timeline" target="_blank" rel="noopener">java底层机制</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载:&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/ae97b692614e?from=timeline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java底层机制&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring boot注解基本了解</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/06/java-annotation/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/06/java-annotation/</id>
    <published>2020-03-06T03:38:00.000Z</published>
    <updated>2020-03-06T03:43:08.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里放两篇对Java注解的文章，以备后面查询。<a href="https://www.jianshu.com/p/d74ed7374841" target="_blank" rel="noopener"><strong>Spring Boot 注解—基本知识</strong></a>以及<a href="https://www.cnblogs.com/liaojie970/p/7879917.html" target="_blank" rel="noopener"><strong>Java注释@interface的用法</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里放两篇对Java注解的文章，以备后面查询。&lt;a href=&quot;https://www.jianshu.com/p/d74ed7374841
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="annotation" scheme="http://blog.zhangzonglin.xyz/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>idea下gradle报jdk版本错误</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/05/idea-gradle-jdk/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/05/idea-gradle-jdk/</id>
    <published>2020-03-05T02:32:00.000Z</published>
    <updated>2020-03-05T02:56:02.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”</p><a id="more"></a><p>确认project采用的jdk 13,build.gradle里也是13，应该是Gradle用的版本不匹配，最后在File–&gt;Setting–&gt;Build Tools–&gt;Gradle里，找到配置项。</p><p><img src="/images/pasted-22.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="gradle" scheme="http://blog.zhangzonglin.xyz/tags/gradle/"/>
    
      <category term="jdk" scheme="http://blog.zhangzonglin.xyz/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>IOC的实现原理—反射与工厂模式(转载)</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-03T08:16:39.000Z</published>
    <updated>2020-03-03T08:24:03.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射与工厂模式实现IOC"><a href="#反射与工厂模式实现IOC" class="headerlink" title="反射与工厂模式实现IOC"></a>反射与工厂模式实现IOC</h3><p>   &emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：<br>   <a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125; </span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Orange&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造工厂类</span><br><span class="line">&#x2F;&#x2F;也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了</span><br><span class="line">class Factory&#123;</span><br><span class="line">     public static fruit getInstance(String fruitName)&#123;</span><br><span class="line">         fruit f&#x3D;null;</span><br><span class="line">         if(&quot;Apple&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Apple();</span><br><span class="line">         &#125;</span><br><span class="line">         if(&quot;Orange&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Orange();</span><br><span class="line">         &#125;</span><br><span class="line">         return f;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">     public static void main(String[] a)&#123;</span><br><span class="line">         fruit f&#x3D;Factory.getInstance(&quot;Orange&quot;);</span><br><span class="line">         f.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   &emsp;上面写法的缺点是当我们再添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改动就会很多。下面用反射机制实现工厂模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">     public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a)&#123;</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(&quot;Reflect.Apple&quot;);</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  &emsp;现在就算我们添加任意多个子类的时候，工厂类都不需要修改。使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。</p><p>   &emsp;下面编写使用反射机制并结合属性文件的工厂模式（即IoC）。首先创建一个fruit.properties的资源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple&#x3D;Reflect.Apple</span><br><span class="line">orange&#x3D;Reflect.Orange</span><br></pre></td></tr></table></figure><p>   &emsp;然后编写主类代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;操作属性文件类</span><br><span class="line">class init&#123;</span><br><span class="line">    public static Properties getPro() throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;new Properties();</span><br><span class="line">        File f&#x3D;new File(&quot;fruit.properties&quot;);</span><br><span class="line">        if(f.exists())&#123;</span><br><span class="line">            pro.load(new FileInputStream(f));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pro.setProperty(&quot;apple&quot;, &quot;Reflect.Apple&quot;);</span><br><span class="line">            pro.setProperty(&quot;orange&quot;, &quot;Reflect.Orange&quot;);</span><br><span class="line">            pro.store(new FileOutputStream(f), &quot;FRUIT CLASS&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a) throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;init.getPro();</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(pro.getProperty(&quot;apple&quot;));</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果：Apple</p><h3 id="IOC容器的技术剖析"><a href="#IOC容器的技术剖析" class="headerlink" title="IOC容器的技术剖析"></a>IOC容器的技术剖析</h3><p> &emsp;IOC中最基本的技术就是“反射(Reflection)”编程，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要生产的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。</p><p> &emsp;目前C#、Java和PHP5等语言均支持反射，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚。反射的应用是很广泛的，很多的成熟的框架，比如像Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.NET框架都是把”反射“做为最基本的技术手段。</p><p>&emsp;反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。</p><p>&emsp;我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><h3 id="使用IOC框架应该注意什么"><a href="#使用IOC框架应该注意什么" class="headerlink" title="使用IOC框架应该注意什么"></a>使用IOC框架应该注意什么</h3><p>&emsp;使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p><p>&emsp;1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p><p>&emsp;2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p><p>&emsp;3）具体到IOC框架产品（比如Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p><p>&emsp;4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</p><p>&emsp;我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。<br>————————————————<br>版权声明：本文为CSDN博主「fuzhongmin05」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/fuzhongmin05/article/details/61614873" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射与工厂模式实现IOC&quot;&gt;&lt;a href=&quot;#反射与工厂模式实现IOC&quot; class=&quot;headerlink&quot; title=&quot;反射与工厂模式实现IOC&quot;&gt;&lt;/a&gt;反射与工厂模式实现IOC&lt;/h3&gt;&lt;p&gt;   &amp;emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java类加载</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/va-class/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/va-class/</id>
    <published>2020-03-03T08:07:57.000Z</published>
    <updated>2020-03-03T08:13:43.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里贴一个介绍类加载的介绍链接：<a href="https://juejin.im/post/5dac4edff265da5b5f7588d1#heading-0" target="_blank" rel="noopener">java 的类加载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里贴一个介绍类加载的介绍链接：&lt;a href=&quot;https://juejin.im/post/5dac4edff265da5b5f7588
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/ava-reflection/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/ava-reflection/</id>
    <published>2020-03-03T05:50:39.000Z</published>
    <updated>2020-03-03T08:11:14.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。</p><a id="more"></a><h3 id="反射回顾"><a href="#反射回顾" class="headerlink" title="反射回顾"></a>反射回顾</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p>Oracle 官方对反射的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</span><br><span class="line">The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</span><br></pre></td></tr></table></figure><p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p><h3 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h3><p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p><p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p><p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;login&quot;</span><br><span class="line">               class&#x3D;&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;</span><br><span class="line">               method&#x3D;&quot;execute&quot;&gt;</span><br><span class="line">           &lt;result&gt;&#x2F;shop&#x2F;shop-index.jsp&lt;&#x2F;result&gt;</span><br><span class="line">           &lt;result name&#x3D;&quot;error&quot;&gt;login.jsp&lt;&#x2F;result&gt; </span><br><span class="line">&lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure><p>配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">反射调用的一个Log</a><br><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Java反射原理简析</a></p><p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java自定义类equal重写</title>
    <link href="http://blog.zhangzonglin.xyz/2020/02/27/ava-equal/"/>
    <id>http://blog.zhangzonglin.xyz/2020/02/27/ava-equal/</id>
    <published>2020-02-27T14:47:14.000Z</published>
    <updated>2020-02-27T14:50:12.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。</p><a id="more"></a><p>比较的常用对象如int，float和String等，已重写了equals和hashcode方法，默认比较的是值，而其它自定义对象在用equal时都是比较的引用地址，故此有需要的时候需要重写equal方法。</p><h3 id="重写equal的要求"><a href="#重写equal的要求" class="headerlink" title="重写equal的要求"></a>重写equal的要求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;  </span><br><span class="line">        if(this &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(null &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">       if (obj instanceof Test)&#123;</span><br><span class="line">            Test o &#x3D; (Test) obj;</span><br><span class="line">            return this.id &#x3D;&#x3D; o.id;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写equals方法的要求：<br>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。<br>2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。<br>3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。<br>4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。<br>5、非空性：对于任意非空引用x，x.equals(null)应该返回false。</p><h3 id="hashCode方法也要重写"><a href="#hashCode方法也要重写" class="headerlink" title="hashCode方法也要重写"></a>hashCode方法也要重写</h3><p>问什么说<strong>重写了equals方法都要进而重写Hashcode方法</strong>呢？</p><p>原因如下：当equals此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p><p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p><p>   &emsp;&emsp;hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p><p>   &emsp;&emsp;以HashMap为例说一下的原理，HashMap存储数据的时候，是取的key值的哈希值，然后计算数组下标，采用链地址法解决冲突，然后进行存储；取数据的时候，依然是先要获取到hash值，找到数组下标，然后for遍历链表集合，进行比较是否有对应的key。比较关心的有2点：<br>  &emsp;&emsp; 1.不管是put还是get的时候，都需要得到key的哈希值，去定位key的数组下标；<br>   &emsp;&emsp;2.在get的时候，需要调用equals方法比较是否有相等的key存储过。</p><p>   更详细具体的可以看<a href="https://www.jianshu.com/p/75d9c2c3d0c1" target="_blank" rel="noopener">这篇博文</a>或者<a href="https://www.cnblogs.com/silence-hust/p/4510574.html" target="_blank" rel="noopener">这一篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
