<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglin.xyz/"/>
  <updated>2020-05-02T14:18:28.928Z</updated>
  <id>http://blog.zhangzonglin.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>json web token(jwt)</title>
    <link href="http://blog.zhangzonglin.xyz/2020/05/02/json-web-token-jwt/"/>
    <id>http://blog.zhangzonglin.xyz/2020/05/02/json-web-token-jwt/</id>
    <published>2020-05-02T14:13:00.000Z</published>
    <updated>2020-05-02T14:18:28.928Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://learnku.com/articles/22616" target="_blank" rel="noopener">别再使用 JWT 作为 Session 系统！问题重重且很危险。</a></strong><br>结论：无状态 JWT Tokens 无法被单独地销毁或更新，取决于你如何存储，可能还会导致长度问题、安全隐患。有状态 JWT Tokens 在功能方面与 Session cookies 无异，但缺乏生产环境的验证、经过大量 Review 的实现，以及良好的客户端支持。<br>JWT 特别有效的使用例子通常是作为一次性的授权令牌。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://learnku.com/articles/22616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别再使用 JWT 作为 Session 系统！问题重重且很危险。
&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="jwt" scheme="http://blog.zhangzonglin.xyz/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之IP、MAC</title>
    <link href="http://blog.zhangzonglin.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/"/>
    <id>http://blog.zhangzonglin.xyz/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/</id>
    <published>2020-04-14T02:31:00.000Z</published>
    <updated>2020-04-14T02:34:07.139Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.wmathor.com/index.php/archives/1124/" target="_blank" rel="noopener">MAC 地址与 IP 地址</a></strong>、<strong><a href="https://zhuanlan.zhihu.com/p/82184208" target="_blank" rel="noopener">物理层 和 MAC 层</a></strong>、<strong><a href="https://www.jianshu.com/p/63fd0faa47da" target="_blank" rel="noopener">网络传输中的三张表，MAC地址表、ARP缓存表以及路由表详解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.wmathor.com/index.php/archives/1124/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MAC 地址与 IP 地址&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.zhangzonglin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="MAC" scheme="http://blog.zhangzonglin.xyz/tags/MAC/"/>
    
      <category term="IP" scheme="http://blog.zhangzonglin.xyz/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>锁、synchronized、CAS、volatile</title>
    <link href="http://blog.zhangzonglin.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/"/>
    <id>http://blog.zhangzonglin.xyz/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/</id>
    <published>2020-04-06T10:42:00.000Z</published>
    <updated>2020-04-06T10:49:03.174Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></strong>、<strong><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></strong>、<strong><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/12129120.html" target="_blank" rel="noopener">从原子类和UNSAFE来理解JAVA内存模型，ATOMICINTEGER的INCREMENTANDGET方法和UNSAFE部分源码介绍，VALUEOFFSET偏移量的理解</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9396834.html" target="_blank" rel="noopener">JAVA内存模型中VOLATILE关键字的作用</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9399881.html" target="_blank" rel="noopener">JAVA内存模型，为啥线程要有自己的本地内存，CPU高速缓存</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不可不说的Java“锁”事&lt;/a&gt;&lt;/strong&gt;、&lt;strong
      
    
    </summary>
    
    
    
      <category term="lock" scheme="http://blog.zhangzonglin.xyz/tags/lock/"/>
    
      <category term="synchronized" scheme="http://blog.zhangzonglin.xyz/tags/synchronized/"/>
    
      <category term="CAS" scheme="http://blog.zhangzonglin.xyz/tags/CAS/"/>
    
      <category term="volatile" scheme="http://blog.zhangzonglin.xyz/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP之NAT</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/27/CP-IP%E4%B9%8BNAT/</id>
    <published>2020-03-27T10:12:00.000Z</published>
    <updated>2020-03-27T10:13:19.218Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://www.mobilezhao.com/?cat=3" target="_blank" rel="noopener">TCP/IP之NAT</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://www.mobilezhao.com/?cat=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP/IP之NAT&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="tcp/ip" scheme="http://blog.zhangzonglin.xyz/categories/tcp-ip/"/>
    
    
      <category term="nat" scheme="http://blog.zhangzonglin.xyz/tags/nat/"/>
    
  </entry>
  
  <entry>
    <title>补码原理的个人理解</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-03-20T07:25:00.000Z</published>
    <updated>2020-03-20T07:26:25.818Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/jiaobuchong/article/details/83188674" target="_blank" rel="noopener">补码原理的个人理解</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/jiaobuchong/article/details/83188674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;补码原理的个人理解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://blog.zhangzonglin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="补码" scheme="http://blog.zhangzonglin.xyz/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《Spring设计思想-事务篇》2.数据库隔离级别</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-03-12T09:32:48.000Z</published>
    <updated>2020-03-12T09:37:29.516Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">《Spring设计思想-事务篇》2.数据库隔离级别</a></strong></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。</p><a id="more"></a><p>事务的并发数和数据数据一致性这两个是两个相反的理想指标。而数据库研发的方向就是尽可能提高同时提高两个指标，尽可能减少之间的反作用影响。</p><p>SERIALIZABLE 序列化读，隔离级别最高，客户端以互斥的方式访问数据库资源，统一时间内，同一个资源只能被一个客户端访问，好像客户端在排队请求访问，所以称为序列化读。<br>REPEATABLE_READ 可重复读，可重复读能够保证，一个客户端在一个事务内，多次访问同一个资源时，返回结果是一样的，顾名思义，称为可重复读，这种隔离级别可能会造成幻读现象。<br>READ_COMMITTED 读已提交，即客户端在一个事务内，每次查询读取的数据都是从数据库读取最新的已提交的数据；这种隔离界别可能会造成不可重复读和幻读现象。<br>READ_UNCOMMITTED 读未提交，即客户端在一个事务内，可以读取到其他客户端事务的尚未提交的数据；这种隔离级别可能会造成脏读、不可重复读、幻读 现象。</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>————————————————<br>版权声明：本文为CSDN博主「亦山」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/95319795</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/95319795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想-事务篇》2.数据库隔离级别
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《Spring设计思想》AOP设计基本原理</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-11T14:32:00.000Z</published>
    <updated>2020-03-11T14:34:40.664Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">《Spring设计思想》AOP设计基本原理</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/51095702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Spring设计思想》AOP设计基本原理
&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglin.xyz/tags/spring/"/>
    
      <category term="aop" scheme="http://blog.zhangzonglin.xyz/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/</id>
    <published>2020-03-11T06:07:04.000Z</published>
    <updated>2020-03-11T14:24:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/luanlouis/article/details/24589193&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java动态代理机制详解（JDK 和CGLIB，Java
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring 线程安全</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-03-09T06:46:00.000Z</published>
    <updated>2020-03-09T07:15:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/kismetv/p/8757260.html" target="_blank" rel="noopener"><strong>Spring中获取request的几种方法，及其线程安全性分析</strong></a>、<strong><a href="https://www.jianshu.com/p/e04491f3550f" target="_blank" rel="noopener">Spring 如何保证线程安全</a></strong>、<strong><a href="https://blog.csdn.net/cs408/article/details/48972653" target="_blank" rel="noopener">Spring中Singleton模式的线程安全</a></strong></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作</p><a id="more"></a><p>数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧。并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该栈帧并释放掉。</p><p>&emsp;注意：Java栈中的数据是线程私有的，一个线程是无法访问另一个线程的Java栈的数据。这也就是为什么多线程编程时，两个相同线程执行同一方法时，对方法内的局部变量是不需要数据同步的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/8757260.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Spring中获取request的几种方法，及其线程安全性分析&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/e04491f3550f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 如何保证线程安全
&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/cs408/article/details/48972653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring中Singleton模式的线程安全
&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;备注&quot;&gt;&lt;a href=&quot;#备注&quot; class=&quot;headerlink&quot; title=&quot;备注&quot;&gt;&lt;/a&gt;备注&lt;/h3&gt;&lt;p&gt;&amp;emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="spring" scheme="http://blog.zhangzonglin.xyz/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>jvm-invokeinterface</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/09/vm-invokeinterface/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/09/vm-invokeinterface/</id>
    <published>2020-03-09T05:57:00.000Z</published>
    <updated>2020-03-09T06:01:48.588Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://blog.csdn.net/kang389110772/article/details/50723127" target="_blank" rel="noopener">Spring为什么Autowired注入的是接口</a>、</p><p><a href="https://github.com/1993hzh/thoughts/issues/5" target="_blank" rel="noopener">浅析JVM中invokevirtual与invokeinterface的区别 #5</a>、</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.3" target="_blank" rel="noopener">Java Virtual Machine Specification</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/kang389110772/article/details/50723127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring为什么Autowired注入的是接口
&lt;/a&gt;、&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="jvm" scheme="http://blog.zhangzonglin.xyz/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java底层机制（堆/栈/方法区/GC/类加载）</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-08T13:21:00.000Z</published>
    <updated>2020-03-11T09:15:36.601Z</updated>
    
    <content type="html"><![CDATA[<p>转载:<strong><a href="https://www.jianshu.com/p/ae97b692614e?from=timeline" target="_blank" rel="noopener">java底层机制</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载:&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/ae97b692614e?from=timeline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java底层机制&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring boot注解基本了解</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/06/java-annotation/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/06/java-annotation/</id>
    <published>2020-03-06T03:38:00.000Z</published>
    <updated>2020-03-06T03:43:08.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里放两篇对Java注解的文章，以备后面查询。<a href="https://www.jianshu.com/p/d74ed7374841" target="_blank" rel="noopener"><strong>Spring Boot 注解—基本知识</strong></a>以及<a href="https://www.cnblogs.com/liaojie970/p/7879917.html" target="_blank" rel="noopener"><strong>Java注释@interface的用法</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里放两篇对Java注解的文章，以备后面查询。&lt;a href=&quot;https://www.jianshu.com/p/d74ed7374841
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="annotation" scheme="http://blog.zhangzonglin.xyz/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>idea下gradle报jdk版本错误</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/05/idea-gradle-jdk/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/05/idea-gradle-jdk/</id>
    <published>2020-03-05T02:32:00.000Z</published>
    <updated>2020-03-05T02:56:02.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”</p><a id="more"></a><p>确认project采用的jdk 13,build.gradle里也是13，应该是Gradle用的版本不匹配，最后在File–&gt;Setting–&gt;Build Tools–&gt;Gradle里，找到配置项。</p><p><img src="/images/pasted-22.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="gradle" scheme="http://blog.zhangzonglin.xyz/tags/gradle/"/>
    
      <category term="jdk" scheme="http://blog.zhangzonglin.xyz/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>IOC的实现原理—反射与工厂模式(转载)</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-03T08:16:39.000Z</published>
    <updated>2020-03-03T08:24:03.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射与工厂模式实现IOC"><a href="#反射与工厂模式实现IOC" class="headerlink" title="反射与工厂模式实现IOC"></a>反射与工厂模式实现IOC</h3><p>   &emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：<br>   <a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125; </span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Orange&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造工厂类</span><br><span class="line">&#x2F;&#x2F;也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了</span><br><span class="line">class Factory&#123;</span><br><span class="line">     public static fruit getInstance(String fruitName)&#123;</span><br><span class="line">         fruit f&#x3D;null;</span><br><span class="line">         if(&quot;Apple&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Apple();</span><br><span class="line">         &#125;</span><br><span class="line">         if(&quot;Orange&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Orange();</span><br><span class="line">         &#125;</span><br><span class="line">         return f;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">     public static void main(String[] a)&#123;</span><br><span class="line">         fruit f&#x3D;Factory.getInstance(&quot;Orange&quot;);</span><br><span class="line">         f.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   &emsp;上面写法的缺点是当我们再添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改动就会很多。下面用反射机制实现工厂模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">     public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a)&#123;</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(&quot;Reflect.Apple&quot;);</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  &emsp;现在就算我们添加任意多个子类的时候，工厂类都不需要修改。使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。</p><p>   &emsp;下面编写使用反射机制并结合属性文件的工厂模式（即IoC）。首先创建一个fruit.properties的资源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple&#x3D;Reflect.Apple</span><br><span class="line">orange&#x3D;Reflect.Orange</span><br></pre></td></tr></table></figure><p>   &emsp;然后编写主类代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;操作属性文件类</span><br><span class="line">class init&#123;</span><br><span class="line">    public static Properties getPro() throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;new Properties();</span><br><span class="line">        File f&#x3D;new File(&quot;fruit.properties&quot;);</span><br><span class="line">        if(f.exists())&#123;</span><br><span class="line">            pro.load(new FileInputStream(f));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pro.setProperty(&quot;apple&quot;, &quot;Reflect.Apple&quot;);</span><br><span class="line">            pro.setProperty(&quot;orange&quot;, &quot;Reflect.Orange&quot;);</span><br><span class="line">            pro.store(new FileOutputStream(f), &quot;FRUIT CLASS&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a) throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;init.getPro();</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(pro.getProperty(&quot;apple&quot;));</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果：Apple</p><h3 id="IOC容器的技术剖析"><a href="#IOC容器的技术剖析" class="headerlink" title="IOC容器的技术剖析"></a>IOC容器的技术剖析</h3><p> &emsp;IOC中最基本的技术就是“反射(Reflection)”编程，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要生产的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。</p><p> &emsp;目前C#、Java和PHP5等语言均支持反射，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚。反射的应用是很广泛的，很多的成熟的框架，比如像Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.NET框架都是把”反射“做为最基本的技术手段。</p><p>&emsp;反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。</p><p>&emsp;我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><h3 id="使用IOC框架应该注意什么"><a href="#使用IOC框架应该注意什么" class="headerlink" title="使用IOC框架应该注意什么"></a>使用IOC框架应该注意什么</h3><p>&emsp;使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p><p>&emsp;1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p><p>&emsp;2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p><p>&emsp;3）具体到IOC框架产品（比如Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p><p>&emsp;4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</p><p>&emsp;我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。<br>————————————————<br>版权声明：本文为CSDN博主「fuzhongmin05」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/fuzhongmin05/article/details/61614873" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射与工厂模式实现IOC&quot;&gt;&lt;a href=&quot;#反射与工厂模式实现IOC&quot; class=&quot;headerlink&quot; title=&quot;反射与工厂模式实现IOC&quot;&gt;&lt;/a&gt;反射与工厂模式实现IOC&lt;/h3&gt;&lt;p&gt;   &amp;emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java类加载</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/va-class/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/va-class/</id>
    <published>2020-03-03T08:07:57.000Z</published>
    <updated>2020-03-03T08:13:43.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里贴一个介绍类加载的介绍链接：<a href="https://juejin.im/post/5dac4edff265da5b5f7588d1#heading-0" target="_blank" rel="noopener">java 的类加载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里贴一个介绍类加载的介绍链接：&lt;a href=&quot;https://juejin.im/post/5dac4edff265da5b5f7588
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://blog.zhangzonglin.xyz/2020/03/03/ava-reflection/"/>
    <id>http://blog.zhangzonglin.xyz/2020/03/03/ava-reflection/</id>
    <published>2020-03-03T05:50:39.000Z</published>
    <updated>2020-03-03T08:11:14.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。</p><a id="more"></a><h3 id="反射回顾"><a href="#反射回顾" class="headerlink" title="反射回顾"></a>反射回顾</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p>Oracle 官方对反射的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</span><br><span class="line">The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</span><br></pre></td></tr></table></figure><p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p><h3 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h3><p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p><p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p><p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;login&quot;</span><br><span class="line">               class&#x3D;&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;</span><br><span class="line">               method&#x3D;&quot;execute&quot;&gt;</span><br><span class="line">           &lt;result&gt;&#x2F;shop&#x2F;shop-index.jsp&lt;&#x2F;result&gt;</span><br><span class="line">           &lt;result name&#x3D;&quot;error&quot;&gt;login.jsp&lt;&#x2F;result&gt; </span><br><span class="line">&lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure><p>配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">反射调用的一个Log</a><br><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Java反射原理简析</a></p><p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java自定义类equal重写</title>
    <link href="http://blog.zhangzonglin.xyz/2020/02/27/ava-equal/"/>
    <id>http://blog.zhangzonglin.xyz/2020/02/27/ava-equal/</id>
    <published>2020-02-27T14:47:14.000Z</published>
    <updated>2020-02-27T14:50:12.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。</p><a id="more"></a><p>比较的常用对象如int，float和String等，已重写了equals和hashcode方法，默认比较的是值，而其它自定义对象在用equal时都是比较的引用地址，故此有需要的时候需要重写equal方法。</p><h3 id="重写equal的要求"><a href="#重写equal的要求" class="headerlink" title="重写equal的要求"></a>重写equal的要求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;  </span><br><span class="line">        if(this &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(null &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">       if (obj instanceof Test)&#123;</span><br><span class="line">            Test o &#x3D; (Test) obj;</span><br><span class="line">            return this.id &#x3D;&#x3D; o.id;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写equals方法的要求：<br>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。<br>2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。<br>3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。<br>4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。<br>5、非空性：对于任意非空引用x，x.equals(null)应该返回false。</p><h3 id="hashCode方法也要重写"><a href="#hashCode方法也要重写" class="headerlink" title="hashCode方法也要重写"></a>hashCode方法也要重写</h3><p>问什么说<strong>重写了equals方法都要进而重写Hashcode方法</strong>呢？</p><p>原因如下：当equals此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p><p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p><p>   &emsp;&emsp;hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p><p>   &emsp;&emsp;以HashMap为例说一下的原理，HashMap存储数据的时候，是取的key值的哈希值，然后计算数组下标，采用链地址法解决冲突，然后进行存储；取数据的时候，依然是先要获取到hash值，找到数组下标，然后for遍历链表集合，进行比较是否有对应的key。比较关心的有2点：<br>  &emsp;&emsp; 1.不管是put还是get的时候，都需要得到key的哈希值，去定位key的数组下标；<br>   &emsp;&emsp;2.在get的时候，需要调用equals方法比较是否有相等的key存储过。</p><p>   更详细具体的可以看<a href="https://www.jianshu.com/p/75d9c2c3d0c1" target="_blank" rel="noopener">这篇博文</a>或者<a href="https://www.cnblogs.com/silence-hust/p/4510574.html" target="_blank" rel="noopener">这一篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RxJava --学习链接</title>
    <link href="http://blog.zhangzonglin.xyz/2020/02/18/xJava/"/>
    <id>http://blog.zhangzonglin.xyz/2020/02/18/xJava/</id>
    <published>2020-02-18T01:48:00.000Z</published>
    <updated>2020-02-26T14:48:56.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Rx（Reactive Extensions）是一个使用<code>可观察数据流</code>进行<code>异步编程</code>的编程接口，ReactiveX结合了<code>观察者模式</code>、<code>迭代器模式</code>和<code>函数式编程</code>的精华。Rx的语言库比较流行的有RxJava/RxJS/Rx.NET，这里贴一些有关RxJava的链接，以便后续查找。</p><a id="more"></a><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">Rx中文文档</a><br><a href="https://www.jianshu.com/p/03a72a5a2049" target="_blank" rel="noopener">RxJava心得</a><br><a href="https://blog.lixplor.com/2016/10/16/rxjava/" target="_blank" rel="noopener">RxJava操作符</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Rx（Reactive Extensions）是一个使用&lt;code&gt;可观察数据流&lt;/code&gt;进行&lt;code&gt;异步编程&lt;/code&gt;的编程接口，ReactiveX结合了&lt;code&gt;观察者模式&lt;/code&gt;、&lt;code&gt;迭代器模式&lt;/code&gt;和&lt;code&gt;函数式编程&lt;/code&gt;的精华。Rx的语言库比较流行的有RxJava/RxJS/Rx.NET，这里贴一些有关RxJava的链接，以便后续查找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://blog.zhangzonglin.xyz/categories/java/"/>
    
    
      <category term="RxJava" scheme="http://blog.zhangzonglin.xyz/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>android studio多语言(中英)适配</title>
    <link href="http://blog.zhangzonglin.xyz/2020/02/14/ndroid-studio%E4%B8%AD%E8%8B%B1%E6%96%87%E9%80%82%E9%85%8D/"/>
    <id>http://blog.zhangzonglin.xyz/2020/02/14/ndroid-studio%E4%B8%AD%E8%8B%B1%E6%96%87%E9%80%82%E9%85%8D/</id>
    <published>2020-02-14T02:28:15.000Z</published>
    <updated>2020-02-14T03:22:23.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>strings.xml在目录res相应的value文件夹下,用来显示文本，避免硬编码，要添加新的语言支持，就要在不同的 value 文件夹下（如value 、values-zh-rCN）添加不同语言的 string.xml 文件。本文以简体中文为例,描述一下Android studio下相应strings.xml(zh-rCN)的生成方式，其他语言类似。</p><a id="more"></a><h3 id="手动建立文件"><a href="#手动建立文件" class="headerlink" title="手动建立文件"></a>手动建立文件</h3><p>选中res文件夹，右键New–&gt;Android Resource Directory,然后选中Locale,如下图所示：</p><p><img src="/images/pasted-17.png" alt="upload successful"><br>选择相应语言和相应区域：</p><p><img src="/images/pasted-18.png" alt="upload successful"><br>文件夹名称（values-zh-rCN）自动生成，最后在该文件夹生成strings.xml即可。项目视图如下：</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p>打开Translations Editor（双击打开strings.xml，窗口右上角点击Open Editor），点击Add Locale，在下拉菜单中选择相应语言区域，系统会自动生成相应文件夹以及strings.xml文件。</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p><img src="/images/pasted-21.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;strings.xml在目录res相应的value文件夹下,用来显示文本，避免硬编码，要添加新的语言支持，就要在不同的 value 文件夹下（如value 、values-zh-rCN）添加不同语言的 string.xml 文件。本文以简体中文为例,描述一下Android studio下相应strings.xml(zh-rCN)的生成方式，其他语言类似。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>android studio 真机调试</title>
    <link href="http://blog.zhangzonglin.xyz/2020/02/10/android-run-on-a-real-device/"/>
    <id>http://blog.zhangzonglin.xyz/2020/02/10/android-run-on-a-real-device/</id>
    <published>2020-02-10T02:30:00.000Z</published>
    <updated>2020-02-14T02:23:52.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android studio调试的时候可以运行在模拟器，也可以在真机上运行，本文记录一下真机（MIUI10）调试的前期准备。</p><a id="more"></a><h3 id="Windows设置"><a href="#Windows设置" class="headerlink" title="Windows设置"></a>Windows设置</h3><p>打开AS，点击File–&gt;Setting–&gt;Appearance &amp; Behavior–&gt;System Setting–&gt;Android SDK，在SDK Platforms下勾选真机Android版本相应的SDK。</p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p>在SDK Tools目录下勾选Google Usb Driver，点击Apply，AS会自动下载Usb驱动，并记下Android SDK location。</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>数据线连接手机，windows打开设备管理器，点击便携设备，</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>点击相应的设备MI 5 ，选择驱动程序，更新驱动程序，浏览我的计算机以查找更新驱动程序，输入目录：AS中记下的SDK目录\extras\google\usb_driver，并安装。<br><img src="/images/pasted-12.png" alt="upload successful"></p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p><img src="/images/pasted-13.png" alt="upload successful"></p><h3 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h3><p>首先要打开开发者模式（每款手机的开发者模式打开方式不同，大家自行搜索），以小米为例，“设置-我的设备-全部参数-多次点击MIUI版本（有提示），如此便进入“开发者模式”了，在“更多设置”找到开发者选项，打开“USB调试” “USB安装”，并把滚动条滚到最下面，关掉“启用MIUI优化”。</p><p>如此便可以进入android studio调试安装了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Android studio调试的时候可以运行在模拟器，也可以在真机上运行，本文记录一下真机（MIUI10）调试的前期准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://blog.zhangzonglin.xyz/categories/android/"/>
    
    
      <category term="android-studio" scheme="http://blog.zhangzonglin.xyz/tags/android-studio/"/>
    
  </entry>
  
</feed>
