<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1.5L的喜欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhangzonglinagain.xyz/"/>
  <updated>2022-12-07T19:50:42.482Z</updated>
  <id>http://blog.zhangzonglinagain.xyz/</id>
  
  <author>
    <name>zzl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL语句的执行顺序</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/12/07/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/12/07/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-12-07T15:31:52.000Z</published>
    <updated>2022-12-07T19:50:42.482Z</updated>
    
    <content type="html"><![CDATA[<p>Logical Query Processing Phases in Brief—《Microsoft SQL Server 2008技术内幕T-SQL语言基础.pdf》p27</p><a id="more"></a><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>  The FROM phase identifi es the query’s source tables and processes table operators. Each table operator applies a series of subphases. For example, the phases involved in a join are (1-J1) Cartesian Product, (1-J2) ON Filter, (1-J3) Add Outer Rows. The FROM phase generates virtual table VT1. </p><h4 id="Cartesian-Product"><a href="#Cartesian-Product" class="headerlink" title="Cartesian Product"></a><em>Cartesian Product</em></h4><p>This phase performs a Cartesian product (cross join) between the two tables involved in the table operator, generating VT1-J1. </p><h4 id="ON-Filter"><a href="#ON-Filter" class="headerlink" title="ON Filter"></a><em>ON Filter</em></h4><p>This phase fi lters the rows from VT1-J1 based on the predicate that appears in the ON clause (<on_predicate>). Only rows for which the predicate evaluates to TRUE are inserted into VT1-J2.</on_predicate></p><h4 id="Add-Outer-Rows"><a href="#Add-Outer-Rows" class="headerlink" title="Add Outer Rows"></a><em>Add Outer Rows</em></h4><p>If OUTER JOIN is specifi ed (as opposed to CROSS JOIN or INNER JOIN), rows from the preserved table or tables for which a match was not found are added to the rows from VT1-J2 as outer rows, generating VT1-J3.</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><p>This phase fi lters the rows from VT1 based on the predicate that appears in the WHERE clause (<where_predicate>). Only rows for which the predicate evaluates to TRUE are inserted into VT2. </where_predicate></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p>This phase arranges the rows from VT2 in groups based on the column list specifi ed in the GROUP BY clause, generating VT3. Ultimately, there will be one result row per group. </p><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>This phase fi lters the groups from VT3 based on the predicate that appears in the HAVING clause (<having_predicate>). Only groups for which the predicate evaluates to TRUE are inserted into VT4. </having_predicate></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>This phase processes the elements in the SELECT clause, generating VT5. </p><h4 id="Evaluate-Expressions"><a href="#Evaluate-Expressions" class="headerlink" title="Evaluate Expressions"></a><em>Evaluate Expressions</em></h4><p>This phase evaluates the expressions in the SELECT list, generating VT5-1. </p><h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a><em>DISTINCT</em></h4><p>This phase removes duplicate rows from VT5-1, generating VT5-2. </p><h4 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a><em>TOP</em></h4><p>This phase fi lters the specifi ed top number or percentage of rows from VT5-2 based on the logical ordering defi ned by the ORDER BY clause, generating the table VT5-3. </p><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>This phase sorts the rows from VT5-3 according to the column list specifi ed in the ORDER BY clause, generating the cursor VC6.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Logical Query Processing Phases in Brief—《Microsoft SQL Server 2008技术内幕T-SQL语言基础.pdf》p27&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>centos 命令补全失效(硬盘满了)</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/12/04/centos-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8%E5%A4%B1%E6%95%88-%E7%A1%AC%E7%9B%98%E6%BB%A1%E4%BA%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/12/04/centos-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8%E5%A4%B1%E6%95%88-%E7%A1%AC%E7%9B%98%E6%BB%A1%E4%BA%86/</id>
    <published>2022-12-04T14:37:32.000Z</published>
    <updated>2022-12-04T19:08:13.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tab补全失效"><a href="#Tab补全失效" class="headerlink" title="Tab补全失效"></a>Tab补全失效</h3><p>登录服务器，cd 相应路径按Tab补全时，提示*-bash: cannot create temp file for here-document: No space left on device*。</p><a id="more"></a><p>如图所示：<br><img src="/images/pasted-52.png" alt="upload successful"><br>谷歌查询是硬盘满了。df命令查看，果然如此：</p><p><img src="/images/pasted-54.png" alt="upload successful"></p><p>然后用du命令查看可以目录</p><p><img src="/images/pasted-55.png" alt="upload successful"></p><p>发现可以目录&#x2F;var &#x2F;app &#x2F;sftproot,继续用du命令挨个查看，最后发现&#x2F;var&#x2F;log目录占用12G</p><p><img src="/images/pasted-56.png" alt="upload successful"></p><p>进入log继续du加sort排序查看(ll -h也可)</p><p><img src="/images/pasted-57.png" alt="upload successful"></p><p>就是这几个messages文件占了10多G，且都是最近产生的，随便打开进去一看都是如下内容：</p><p><img src="/images/pasted-58.png" alt="upload successful"></p><p>是crond产生的垃圾日志，不管它，先来个重启大法<em>service crond stop</em>、<em>service crond start</em>，再瞧问题依旧。谷歌之，<em>No configuration file found at &#x2F;root&#x2F;.esmtprc or &#x2F;etc&#x2F;esmtprc</em>,没找到问题原因，只看到个解决方法 <a href="https://www.axinblog.com/2022/02/16/Linux-%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/" target="_blank" rel="noopener">Linux 日志清理</a>，先暂且安装重启crond，记下来以观后效，明天再查…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tab补全失效&quot;&gt;&lt;a href=&quot;#Tab补全失效&quot; class=&quot;headerlink&quot; title=&quot;Tab补全失效&quot;&gt;&lt;/a&gt;Tab补全失效&lt;/h3&gt;&lt;p&gt;登录服务器，cd 相应路径按Tab补全时，提示*-bash: cannot create temp file for here-document: No space left on device*。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java内存使用情况查看工具(jmap,jinfo,jstack...)</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/07/02/Java%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/07/02/Java%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/</id>
    <published>2022-07-02T10:43:19.000Z</published>
    <updated>2022-12-04T19:29:57.085Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/hellozhxy/article/details/80496550" target="_blank" rel="noopener">Java内存使用情况查看工具</a>、或者直接采用阿里的开源工具<a href="https://developer.aliyun.com/article/764933" target="_blank" rel="noopener">Java 线上问题排查神器 Arthas 快速上手与原理浅谈</a>&amp;&amp;<a href="https://cloud.tencent.com/developer/article/1534894" target="_blank" rel="noopener">Arthas - Java 线上问题定位处理的终极利器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hellozhxy/article/details/80496550&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java内存使用情况查看工具&lt;/a&gt;、或者直接采用阿里的开源工具&lt;a href
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6中js的运算符（?.、?:、? ?、? ?=、）</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/06/25/ES6%E4%B8%ADjs%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E3%80%81-%E3%80%81-%E3%80%81-%E3%80%81%EF%BC%89/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/06/25/ES6%E4%B8%ADjs%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E3%80%81-%E3%80%81-%E3%80%81-%E3%80%81%EF%BC%89/</id>
    <published>2022-06-25T07:50:33.000Z</published>
    <updated>2022-07-15T20:58:25.094Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ShIcily/article/details/121673976" target="_blank" rel="noopener">ES6中js的运算符（?.、?:、? ?、? ?&#x3D;、）</a>、<a href="https://blog.csdn.net/sinat_36146776/article/details/112170829" target="_blank" rel="noopener">JavaScript表达式和运算符之：逻辑或赋值（||&#x3D; ），逻辑空赋值（??&#x3D;） ，逻辑与赋值（&amp;&amp;&#x3D;），空值合并操作符（??），可选链式操作符（?.）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ShIcily/article/details/121673976&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ES6中js的运算符（?.、?:、? ?、? ?&amp;#x3D;、）&lt;/a&gt;、&lt;a 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring中@Import的各种用法以及ImportAware接口</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/05/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/05/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-05-14T17:05:42.000Z</published>
    <updated>2022-05-18T21:49:00.657Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/640a339474fb" target="_blank" rel="noopener">Spring中@Import的各种用法以及ImportAware接口</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/640a339474fb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring中@Import的各种用法以及ImportAware接口&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java 内部类详解</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/05/15/Java-%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/05/15/Java-%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-05-14T16:44:56.000Z</published>
    <updated>2022-05-14T16:45:09.141Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/w3cnote/java-inner-class-intro.html" target="_blank" rel="noopener">Java 内部类详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.runoob.com/w3cnote/java-inner-class-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 内部类详解&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网络抓包常用命令</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/05/04/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/05/04/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-04T08:09:58.000Z</published>
    <updated>2022-05-04T08:10:13.476Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://plantegg.github.io/2022/01/01/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">网络抓包常用命令</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://plantegg.github.io/2022/01/01/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IDEA中的后缀补全</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/24/IDEA%E4%B8%AD%E7%9A%84%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/24/IDEA%E4%B8%AD%E7%9A%84%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8/</id>
    <published>2022-04-23T17:57:53.000Z</published>
    <updated>2022-04-23T17:58:02.069Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/correlate/article/details/109578810" target="_blank" rel="noopener">IDEA中的后缀补全</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/correlate/article/details/109578810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IDEA中的后缀补全&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hard Links VS Soft Links in Linux: What’s the Difference</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/23/Hard-Links-VS-Soft-Links-in-Linux-What%E2%80%99s-the-Difference/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/23/Hard-Links-VS-Soft-Links-in-Linux-What%E2%80%99s-the-Difference/</id>
    <published>2022-04-23T15:12:15.000Z</published>
    <updated>2022-04-23T15:27:08.837Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/techtofreedom/hard-links-vs-soft-links-in-linux-whats-the-difference-bbd3dfbe24f7" target="_blank" rel="noopener">Hard Links VS Soft Links in Linux: What’s the Difference</a></p><a id="more"></a><p>总结：</p><ul><li>A hard link is a link pointing to an existing file’s inode, One or more hard links for an existing file can be created, and they have the <strong>same  inode number</strong>. </li><li>A soft link is a pointer to a file or directory.Unlike a hard link, a soft link has its own inode and inode number. </li><li>A hard link: <ul><li>A file can be accessed with different filenames.</li><li>Modifications of a file by one of its filenames will affect all filenames.</li><li>Deleting one filename does not affect access to other filenames.</li></ul></li><li>A soft link points to another existing file’s content. This means that a soft link depends on its “host file” to exist. If its host file is deleted, opening the soft link will report an error: “No such file or directory”. (This is totally different with hard links.)</li><li>Hard links, by the way, <strong>cannot</strong> be created for directories and files on a different filesystem, cause different filesystems manage their own inodes.</li><li>A soft link is a pointer and there’s nothing about inodes, a soft link can point to a file or a directory on a different filesystem or partition.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://medium.com/techtofreedom/hard-links-vs-soft-links-in-linux-whats-the-difference-bbd3dfbe24f7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hard Links VS Soft Links in Linux: What’s the Difference&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ssh 复用(避免重输密码)</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/10/ssh-%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/10/ssh-%E5%A4%8D%E7%94%A8/</id>
    <published>2022-04-09T20:14:44.000Z</published>
    <updated>2022-04-09T20:20:20.280Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/int32bit/notes/blob/master/linux/%E8%AE%BE%E7%BD%AEssh%E8%BF%9E%E6%8E%A5%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8.md" target="_blank" rel="noopener">设置ssh连接会话复用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/int32bit/notes/blob/master/linux/%E8%AE%BE%E7%BD%AEssh%E8%BF%9E%E6%8E%A5%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Ulauncher</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/10/Ulauncher/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/10/Ulauncher/</id>
    <published>2022-04-09T18:13:58.000Z</published>
    <updated>2022-04-09T23:00:35.731Z</updated>
    
    <content type="html"><![CDATA[<p>Ulauncher(Application launcher for Linux)效率提升工具…</p><p><a href="https://ulauncher.io/#Download" target="_blank" rel="noopener">官网</a>、<a href="https://www.geeksforgeeks.org/how-to-install-ulauncher-in-ubuntu/" target="_blank" rel="noopener">How to Install Ulauncher in Ubuntu?</a>、<a href="https://www.makeuseof.com/install-ulauncher-on-linux/" target="_blank" rel="noopener">How to Install Extensions And Best Ulauncher Extensions</a>.<br>实测好用的插件：Terminal Runner(关机重启方便)、IpCopy（查看自己内网外网IP并复制）、Better file browser（文件浏览及搜索）、Translate（翻译。默认翻译成en，如果是英译汉格式为“tr :zh english”）、Calculate Anything</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ulauncher(Application launcher for Linux)效率提升工具…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ulauncher.io/#Download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;、&lt;a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重装ubuntu及win10引导修复</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/08/%E9%87%8D%E8%A3%85ubuntu%E5%8F%8Awin10%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/08/%E9%87%8D%E8%A3%85ubuntu%E5%8F%8Awin10%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/</id>
    <published>2022-04-07T19:27:52.000Z</published>
    <updated>2022-04-07T20:06:51.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>人被杀就会死，ubuntu20果然崩溃了，起因似乎是重装搜狗输入法，卸载时autoremove不知删了哪个依赖，桌面死活进不去（oh,no,something went wrong警告），<a id="more"></a> 后面<em>Ctrl+Alt+F3</em>通过tty3登录，进去翻日志，一通装一通删，试了N次，发现把gnome-session删了，倒是能进桌面了，算了，直接转移数据，重装。切到win10系统，下载镜像、刻盘一气呵成，隐约记得以前用EasyBCD添加引导，下了个进去手贱，把WIN10的引导给删了,这时候才想起ubuntu新版本不用自己添加引导了~~. 幸亏U盘已经刻好，索性先重装ubuntu，再在ubuntu下，看看有什么方法恢复引导文件。装系统网上很多教程，倒是在ubuntu下刻盘，恢复win10引导值得记录一下（毕竟两个晚上的青春）。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>度娘说，可以通过winPE，修复引导，所以第一步：下载镜像文件。国内镜像多坑爹，问问我那逝去的青春就知道了，直接谷歌救我命<a href="https://archive.org/details/wpe-64" target="_blank" rel="noopener">WinPE.iso</a>–!</p><h3 id="刻盘"><a href="#刻盘" class="headerlink" title="刻盘"></a>刻盘</h3><p>ubuntu下刻盘，看大部分推荐dd命令，用国内坑爹的镜像试了几次，不确定是哪儿的原因，反正开机进不去WinPE, 包括救我命的镜像，用该命令失败。后面还是用WoeUSB（采用命令行方式，GUI失败）成功</p><h4 id="安装WoeUSB"><a href="#安装WoeUSB" class="headerlink" title="安装WoeUSB"></a>安装WoeUSB</h4><p>在github上下载最新版本：<a href="https://github.com/WoeUSB/WoeUSB/releases/download/v5.2.4/woeusb-5.2.4.bash" target="_blank" rel="noopener">WoeUSB github</a></p><p>安装 WoeUSB-ng 的依赖项，和第一种方法要安装的依赖项是一样的！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x woeusb-5.2.4.bash</span><br></pre></td></tr></table></figure><p>然后还需要安装一些依赖项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git p7zip-full python3-pip python3-wxgtk4.0 grub2-common grub-pc-bin wimtools</span><br></pre></td></tr></table></figure><p>现在就可以执行这个文件了 .&#x2F;woeusb-5.2.4.bash 可以看到命令提示，只需要制定一个windows镜像文件地址 和 u盘的位置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l #查看U盘</span><br><span class="line">umount &#x2F;dev&#x2F;sdb  #卸载u盘</span><br><span class="line">sudo mkfs.ntfs -F &#x2F;dev&#x2F;sdb #格式化U盘</span><br><span class="line">sudo .&#x2F;woeusb-5.2.4.bash --device &#39;WinPE.iso&#39;  &#x2F;dev&#x2F;sdb  --tgt-fs  NTFS #刻盘</span><br></pre></td></tr></table></figure><h3 id="WIN10-引导修复"><a href="#WIN10-引导修复" class="headerlink" title="WIN10 引导修复"></a>WIN10 引导修复</h3><p>拿着刻好的U盘，重新开机，狂按F12,进入WINPE，接来下的修复过程，严格参照下面的链接（C盘和D盘，我的也是反着的）<br><a href="https://blog.csdn.net/A_Sen_A/article/details/89545311" target="_blank" rel="noopener">win10 UEFI引导恢复</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;人被杀就会死，ubuntu20果然崩溃了，起因似乎是重装搜狗输入法，卸载时autoremove不知删了哪个依赖，桌面死活进不去（oh,no,something went wrong警告），&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nacos</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/04/01/Nacos/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/04/01/Nacos/</id>
    <published>2022-04-01T15:47:00.000Z</published>
    <updated>2022-04-01T15:54:44.867Z</updated>
    
    <content type="html"><![CDATA[<p>Nacos(Dynamic Naming and Configuration Service)，Na为naming&#x2F;nameServer即注册中心,co为configuration即配置中心，service是指该注册&#x2F;配置中心都是以服务为核心。操作起来比eureka简单且功能强大。<br><strong><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">Nacos Spring Cloud 快速开始</a><strong>、</strong><a href="https://www.jianshu.com/p/39ade28c150d" target="_blank" rel="noopener">什么是Nacos？Nacos注册配置中心介绍</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nacos(Dynamic Naming and Configuration Service)，Na为naming&amp;#x2F;nameServer即注册中心,co为configuration即配置中心，service是指该注册&amp;#x2F;配置中心都是以服务为核心。操作起来比
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>微信内置浏览器缓存清理</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/30/%E5%BE%AE%E4%BF%A1%E5%86%85%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/30/%E5%BE%AE%E4%BF%A1%E5%86%85%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86/</id>
    <published>2022-03-30T09:38:32.000Z</published>
    <updated>2022-03-30T09:45:51.828Z</updated>
    
    <content type="html"><![CDATA[<p>单页面应用在微信浏览器里是个巨坑，它会缓存你的index.html，导致版本更新失效…</p><a id="more"></a><p> 调试时，可以手动清除微信缓存， 在安卓版微信内打开链接  <em><a href="http://debugtbs.qq.com/" target="_blank" rel="noopener">http://debugtbs.qq.com</a></em><br> 按照它提示的再打开<em>debugmm.qq.com&#x2F;?forcex5&#x3D;true</em>，再重新打开<em><a href="http://debugtbs.qq.com/" target="_blank" rel="noopener">http://debugtbs.qq.com</a></em>，点击清楚本地缓存….</p><p><a href="https://blog.csdn.net/weixin_40136189/article/details/81485171" target="_blank" rel="noopener">微信内置浏览器缓存清理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单页面应用在微信浏览器里是个巨坑，它会缓存你的index.html，导致版本更新失效…&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu 搜狗拼音 繁简切换快捷键冲突</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/27/ubuntu-%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3-%E7%B9%81%E7%AE%80%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/27/ubuntu-%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3-%E7%B9%81%E7%AE%80%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/</id>
    <published>2022-03-27T15:46:20.000Z</published>
    <updated>2022-03-27T15:50:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>在用idea（vscode）搜索时，按Ctlr +Shift +F ,没反应，后打字发现触发了搜狗拼音的繁简切换，盘它~</p><a id="more"></a><h4 id="修改搜狗拼音的配置文件"><a href="#修改搜狗拼音的配置文件" class="headerlink" title="修改搜狗拼音的配置文件"></a>修改搜狗拼音的配置文件</h4><p>首先打开搜狗拼音的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.config&#x2F;sogoupinyin&#x2F;conf&#x2F;env.ini</span><br></pre></td></tr></table></figure><p>然后找到下面这行，将后面的值改为0，保存文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShortCutFanJian&#x3D;1</span><br></pre></td></tr></table></figure><p>完成这一步还没结束，还需要修改fcitx的配置文件</p><h4 id="修改-fcitx-的配置文件"><a href="#修改-fcitx-的配置文件" class="headerlink" title="修改 fcitx 的配置文件"></a>修改 fcitx 的配置文件</h4><p>打开 fcitx 的相关配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.config&#x2F;fcitx&#x2F;conf&#x2F;fcitx-chttrans.config</span><br></pre></td></tr></table></figure><p>然后找到下面这行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Hotkey&#x3D;CTRL_SHIFT_F</span><br></pre></td></tr></table></figure><p>将前面的注释取消，随便修改一个不常用的快捷键，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hotkey&#x3D;CTRL_SHIFT_]</span><br></pre></td></tr></table></figure><p>保存文件，重新登录一下账户即可。</p><p><a href="https://www.cnblogs.com/FengZeng666/p/15504636.html" target="_blank" rel="noopener">Ubuntu 禁用搜狗输入法Linux版的简繁切换快捷键</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用idea（vscode）搜索时，按Ctlr +Shift +F ,没反应，后打字发现触发了搜狗拼音的繁简切换，盘它~&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tmux 使用</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/25/tmux-%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/25/tmux-%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-24T18:09:22.000Z</published>
    <updated>2022-04-08T19:37:14.761Z</updated>
    
    <content type="html"><![CDATA[<p>只能说 tmux太香了…</p><a id="more"></a><h3 id="vim配色在tmux中异常"><a href="#vim配色在tmux中异常" class="headerlink" title="vim配色在tmux中异常"></a>vim配色在tmux中异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.tmux.conf</span><br><span class="line">set -g default-terminal &quot;xterm-256color&quot;</span><br><span class="line">source  ~&#x2F;.tmux.conf</span><br></pre></td></tr></table></figure><p>ps：退出tmux再设置…</p><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><ul><li>tmux：新建一个session和一个window</li><li>tmux a：打开挂起的session</li><li>tmux ls：显示所有挂起的session</li></ul><p>在tmux中的操作：</p><ul><li>按下 ctrl + b 后松开，再按 % 可将当前pane左右平分成两个pane</li><li>按下 ctrl + b 后松开，再按 “ 可将当前pane上下平分成两个pane</li><li>按下 ctrl + b 后松开，再按 d 可挂起当前的session</li><li>按下 ctrl + b 后松开，再按 z 可将当前pane全屏或取消全屏</li><li>按下 ctrl + b 后松开，再按 c 可在当前session中创建新的window</li><li>按下 ctrl + b 后松开，再按 s 可选择其他session，用方向键操作</li><li>按下 ctrl + b 后松开，再按 w 可选择其他window，同样用方向键操作</li><li>按下 ctrl + b 后松开，再按 PageUp 或 PageDown 可翻阅当前pane中的内容</li></ul><p>tmux中的复制粘贴</p><ul><li>按下 ctrl + b 后松开，再按 [</li><li>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</li><li>按下 ctrl + b 后松开，再按 ]，会将剪贴板的内容粘贴到光标处</li></ul><p><a href="https://developer.aliyun.com/article/789729" target="_blank" rel="noopener">tmux简介</a>、<br><a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">Tmux 使用教程</a>、<br><a href="https://developer.aliyun.com/article/789729" target="_blank" rel="noopener">Tmux 修改前缀快捷键</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只能说 tmux太香了…&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nginx conf location</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/23/nginx-conf-location-%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/23/nginx-conf-location-%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-23T15:58:00.000Z</published>
    <updated>2022-03-26T17:25:45.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="root-alias"><a href="#root-alias" class="headerlink" title="root alias"></a>root alias</h4><ul><li>root的处理结果是：root路径＋location路径</li><li>alias的处理结果是：使用alias路径替换location路径</li></ul><a id="more"></a><p>nginx指定文件路径有两种方式root和alias，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p><p>alias 指定的目录是准确的，给location指定一个目录。</p><p>root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录。也就是</p><p>以root方式设置资源路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法: root path;</span><br><span class="line">配置块: http、server、location、if</span><br></pre></td></tr></table></figure><p>如果server,location同时配置，优先采用location内的root路径，</p><p>以alias 方式设置资源路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法: alias path;</span><br><span class="line">配置块: location</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#若按照上述配置的话，则访问&#x2F;img&#x2F;目录里面的文件时，ningx会自动去&#x2F;var&#x2F;www&#x2F;image&#x2F;目录找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#若按照这种配置的话，则访问&#x2F;img&#x2F;目录下的文件时，nginx会去&#x2F;var&#x2F;www&#x2F;image&#x2F;img&#x2F;目录下找文件</p><p>注意： </p><ol><li>使用alias时，目录名后面一定要加”&#x2F;“。</li><li>使用alias标签的目录块中不能使用rewrite的break。</li><li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li><li>alias只能位于location块中</li></ol><h4 id="nginx-location配置详细解释"><a href="#nginx-location配置详细解释" class="headerlink" title="nginx location配置详细解释"></a>nginx location配置详细解释</h4><p>语法详解<br>语法规则： location [&#x3D;|<del>|</del>*|^~] &#x2F;uri&#x2F; { … }</p><ul><li>&#x3D; 开头表示精确匹配</li><li>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为&#x2F;static&#x2F;20%&#x2F;aa，可以被规则^~ &#x2F;static&#x2F; &#x2F;aa匹配到（注意是空格）。以xx开头</li><li>~ 开头表示区分大小写的正则匹配 以xx结尾</li><li>~* 开头表示不区分大小写的正则匹配 以xx结尾</li><li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配 的正则</li><li>&#x2F; 通用匹配，任何请求都会匹配到。</li></ul><p>例子，有如下匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">   #规则A  访问根目录&#x2F;， 比如http:&#x2F;&#x2F;localhost&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">location &#x3D; &#x2F;login &#123;</span><br><span class="line">   #规则B  http:&#x2F;&#x2F;localhost&#x2F;login 将匹配规则B，http:&#x2F;&#x2F;localhost&#x2F;register 则匹配规则H</span><br><span class="line">&#125;</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;</span><br><span class="line">   #规则C  http:&#x2F;&#x2F;localhost&#x2F;static&#x2F;a.html 将匹配规则C</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">   #规则D，注意：是根据括号内的大小写进行匹配。括号内全是小写，只匹配小写</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.png$ &#123;</span><br><span class="line">   #规则E  http:&#x2F;&#x2F;localhost&#x2F;a.gif, http:&#x2F;&#x2F;localhost&#x2F;b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用， </span><br><span class="line">      http:&#x2F;&#x2F;localhost&#x2F;static&#x2F;c.png 则优先匹配到 规则C</span><br><span class="line">      http:&#x2F;&#x2F;localhost&#x2F;a.PNG 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</span><br><span class="line">&#125;</span><br><span class="line">location !~ \.xhtml$ &#123;</span><br><span class="line">   #规则F  访问 http:&#x2F;&#x2F;localhost&#x2F;a.xhtml 不会匹配规则F和规则G，</span><br><span class="line">&#125;</span><br><span class="line">location !~* \.xhtml$ &#123;</span><br><span class="line">   #规则G  访问 http:&#x2F;&#x2F;localhost&#x2F;a.xhtml 不会匹配规则F和规则G，</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   #规则H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;a.XHTML不会匹配规则G，（因为!）。规则F，规则G属于排除法，符合匹配规则也不会匹配到，所以想想看实际应用中哪里会用到。</span><br><span class="line"></span><br><span class="line">访问 http:&#x2F;&#x2F;localhost&#x2F;category&#x2F;id&#x2F;1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候nginx转发请求给后端应用[服务器](https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;服务器&amp;tn&#x3D;24004469_oem_dg&amp;rsv_dl&#x3D;gh_pl_sl_csd)，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</span><br><span class="line"></span><br><span class="line">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x3D; &#x2F;api&#x2F; &#123;   # 访问http:&#x2F;&#x2F;localhost&#x2F;api&#x2F;xxx.xxx  会被代理到192.168.0.1&#x2F;xxx.xxx</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;192.168.0.1&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;                              &#x2F;&#x2F;以xx开头</span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;     &#x2F;&#x2F;以xx结尾</span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-files详解"><a href="#try-files详解" class="headerlink" title="try_files详解"></a>try_files详解</h4><ul><li>格式1：try_files file … uri;  </li><li>格式2：try_files file … &#x3D;code;</li></ul><p><a href="https://www.cnblogs.com/jedi1995/p/10900224.html" target="_blank" rel="noopener">nginx配置选项try_files详解</a></p><h4 id="proxy-pass详解"><a href="#proxy-pass详解" class="headerlink" title="proxy_pass详解"></a>proxy_pass详解</h4><p>在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加&#x2F;，表示绝对根路径；如果没有&#x2F;，表示相对路径，把匹配的路径部分也给代理走。<br>假设下面四种情况分别用 <a href="http://192.168.1.1/proxy/test.html" target="_blank" rel="noopener">http://192.168.1.1/proxy/test.html</a> 进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第二种（相对于第一种，最后少一个 &#x2F; ）</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;proxy&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第四种（相对于第三种，最后少一个 &#x2F; ）</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;aaatest.html</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/b010c9302cd0" target="_blank" rel="noopener">nginx 之 proxy_pass详解</a></p><h4 id="80端口重定向到443端口"><a href="#80端口重定向到443端口" class="headerlink" title="80端口重定向到443端口"></a>80端口重定向到443端口</h4><p>nginx 80端口重定向到443端口，也就是http访问自动跳转到https</p><p>配置如下：<br>一、按照如下格式修改nginx.conf 配置文件，80端口会自动转给443端口，这样就强制使用SSL证书加密了。访问http的时候会自动跳转到https上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.域名.com;</span><br><span class="line">    rewrite ^(.*)$ https:&#x2F;&#x2F;$&#123;server_name&#125;$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.域名.com;</span><br><span class="line">    root &#x2F;home&#x2F;wwwroot;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;server.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;server.key;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;root-alias&quot;&gt;&lt;a href=&quot;#root-alias&quot; class=&quot;headerlink&quot; title=&quot;root alias&quot;&gt;&lt;/a&gt;root alias&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;root的处理结果是：root路径＋location路径&lt;/li&gt;
&lt;li&gt;alias的处理结果是：使用alias路径替换location路径&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="alias" scheme="http://blog.zhangzonglinagain.xyz/tags/alias/"/>
    
      <category term="root" scheme="http://blog.zhangzonglinagain.xyz/tags/root/"/>
    
      <category term="location" scheme="http://blog.zhangzonglinagain.xyz/tags/location/"/>
    
      <category term="nginx" scheme="http://blog.zhangzonglinagain.xyz/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Rust copy 、move、clone</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/17/Rust-copy%E4%B8%8Emove%E8%AF%AD%E4%B9%89/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/17/Rust-copy%E4%B8%8Emove%E8%AF%AD%E4%B9%89/</id>
    <published>2022-03-16T17:37:00.000Z</published>
    <updated>2022-03-16T18:27:04.506Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch6/02_move_copy.html" target="_blank" rel="noopener">Rust Copy语义</a></p><a id="more"></a><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>比如下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">let s2 &#x3D; s1;</span><br></pre></td></tr></table></figure><p>上面已经分析过，值的所有权会从变量s1转移到变量s2，所有权的转移，涉及到的过程是拷贝到目标变量，同时重置原变量到未初始状态，整个过程就像是进行了一次数据的移动。但注意，上面示例中拷贝的是栈中的胖指针，而不是拷贝堆中的实际数据，因此这样的拷贝效率是相对较高的。</p><p>所有权转移之后，将只有新的所有者才会指向堆中的实际数据，而原变量将不再指向堆中实际数据，因此所有权转移之后仍然只有一个指针指向堆中数据。</p><p>Move不仅发生在变量赋值过程中，在函数传参、函数返回数据时也会Move，因此，如果将一个大对象(例如包含很多数据的数组，包含很多字段的struct)作为参数传递给函数，是否会让效率很低下？</p><p>按照上面的结论来说，确实如此。但Rust编译器会对Move语义的行为做出一些优化，简单来说，当数据量较大且不会引起程序正确性问题时，它会传递大对象的指针而非内存拷贝。</p><p>此外，对于胖指针类型的变量(如Vec、String)，即使发生了拷贝，其性能也不差，因为拷贝的只是它的胖指针部分。</p><p>总之，Move虽然发生了内存拷贝，但它的性能并不会太受影响。</p><p>此处部分结论参考：<em><a href="https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust" target="_blank" rel="noopener">https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust</a></em>。</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>默认情况下，在将一个值保存到某个位置时总是进行值的移动(实际上是拷贝  如String 拷贝的值是指针)，使得只有目标位置才拥有这个值，而原始变量将变回未初始化状态，也就是暂时不可用的状态。这是Rust的移动语义</strong>。</p><p>Rust还有Copy语义，和Move语义几乎相同，唯一的区别是Copy后，原始变量仍然可用。</p><p>前面说过，Move实际上是进行了拷贝，只不过拷贝后让原始变量变回未初始化状态了，而Copy的行为，就是保留原始变量。</p><p>但Rust默认是使用Move语义，如果想要使用Copy语义，要求要拷贝的数据类型实现了Copy Trait。</p><p>例如，i32默认就已经实现了Copy Trait，因此它在进行所有权转移的时候，会自动使用Copy语义，而不是Move语义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x &#x3D; 3;   &#x2F;&#x2F; 3是原始数据类型，它直接存储在栈中，所以x变量的值是3，x拥有3</span><br><span class="line">let n &#x3D; x;   &#x2F;&#x2F; Copy x的值(即3)到变量n，n现在拥有一个3，但x仍然拥有自己的3</span><br></pre></td></tr></table></figure><p>Rust中默认实现了Copy Trait的类型，包括但不限于：</p><ul><li>所有整数类型，比如u32</li><li>所有浮点数类型，比如f64</li><li>布尔类型，bool，它的值是true和false</li><li>字符类型，char</li><li>元组，当且仅当其包含的类型也都是Copy的时候。比如(i32, i32)是Copy的，但(i32, String)不是</li><li>共享指针类型或共享引用类型</li></ul><p>对于那些没有实现Copy的自定义类型，可以手动去实现Copy(要求同时实现Clone)，方式很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Copy, Clone)]</span><br><span class="line">struct Abc(i32, i32);</span><br></pre></td></tr></table></figure><p>下面是实现了Copy和未实现Copy时的一个对比示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Xyz(i32, i32);</span><br><span class="line"></span><br><span class="line">#[derive(Copy, Clone, Debug)]</span><br><span class="line">struct Def(i32, i32);</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x &#x3D; Xyz(11, 22);</span><br><span class="line">  let y &#x3D; x;</span><br><span class="line">  &#x2F;&#x2F; println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F; 报错</span><br><span class="line">  println!(&quot;y: &#123;:?&#125;&quot;, y);</span><br><span class="line"></span><br><span class="line">  let d &#x3D; Def(33, 44);</span><br><span class="line">  let e &#x3D; d;</span><br><span class="line">  println!(&quot;d: &#123;:?&#125;&quot;, d);</span><br><span class="line">  println!(&quot;e: &#123;:?&#125;&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-51.png" alt="upload successful"></p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>虽然实现Copy Trait可以让原变量继续拥有自己的值，但在某些需求下，不便甚至不能去实现Copy。这时如果想要继续使用原变量，可以使用clone()方法手动拷贝变量的数据，同时不会让原始变量变回未初始化状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">  let s1 &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">  &#x2F;&#x2F; 克隆s1，克隆之后，变量s1仍然绑定原始数据</span><br><span class="line">  let s2 &#x3D; s1.clone();</span><br><span class="line">  println!(&quot;&#123;&#125;,&#123;&#125;&quot;, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但不是所有数据类型都可以进行克隆，只有那些实现了Clone Trait的类型才可以进行克隆(Trait类似于面向对象语言中的接口，如果不了解可先不管Trait是什么)，常见的数据类型都已经实现了Clone，因此它们可以直接使用clone()来克隆。</p><p>对于那些没有实现Clone Trait的自定义类型，需要手动实现Clone Trait。在自定义类型之前加上#[derive(Copy, Clone)]即可。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Copy, Clone)]</span><br><span class="line">struct Abc(i32, i32);</span><br></pre></td></tr></table></figure><p>这样Abc类型的值就可以使用clone()方法进行克隆。</p><p>要注意Copy和Clone时的区别，如果不考虑自己实现Copy trait和Clone trait，而是使用它们的默认实现，那么：</p><p>Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据<br>Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据<br>也就是说，Copy是浅拷贝，Clone是深拷贝，Rust会对每个字段每个元素递归调用clone()，直到最底部。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let vb0 &#x3D; vec![&quot;s1&quot;.to_string()];</span><br><span class="line">  let v &#x3D; vec![vb0];</span><br><span class="line">  println!(&quot;&#123;:p&#125;&quot;, &amp;v[0][0]);     &#x2F;&#x2F; 0x21c43a20c50</span><br><span class="line"></span><br><span class="line">  let vc &#x3D; v.clone();</span><br><span class="line">  println!(&quot;&#123;:p&#125;&quot;, &amp;vc[0][0]);  &#x2F;&#x2F; 0x21c43a20b70</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，使用Clone的默认实现时，clone()操作的性能是较低的。但可以自己实现自己的克隆逻辑，也不一定总是会效率低。比如Rc，它的clone用于增加引用计数，同时只拷贝少量数据，它的clone效率并不低。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://rust-book.junmajinlong.com/ch6/02_move_copy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rust Copy语义&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.zhangzonglinagain.xyz/categories/rust/"/>
    
    
      <category term="move" scheme="http://blog.zhangzonglinagain.xyz/tags/move/"/>
    
      <category term="copy" scheme="http://blog.zhangzonglinagain.xyz/tags/copy/"/>
    
  </entry>
  
  <entry>
    <title>Rust引用</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/17/Rust%E5%BC%95%E7%94%A8/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/17/Rust%E5%BC%95%E7%94%A8/</id>
    <published>2022-03-16T17:07:00.000Z</published>
    <updated>2022-03-16T17:14:47.643Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch3/07_reference_type.html" target="_blank" rel="noopener">Rust中的引用</a></p><a id="more"></a><h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>Rust绝大多数时候不会自动地解除引用。但在某些环境下，Rust会自动进行解引用。</p><p>自动解引用的情况有(结论先总结在此，混脸熟，以后涉及到时再来)：</p><ol><li><p>使用.操作符时(包括取属性值和方法调用)，会隐式地尽可能解除或创建多层引用</p></li><li><p>使用比较操作符时，若比较的两边是相同类型的引用，则会自动解除引用到它们的值然后比较<br>对于(1)，Rust会自动分析func()的参数，并在需要的时候自动创建或自动解除引用。例如以abc.func()有可能会自动转换为&amp;abc.func()，反之，&amp;abc.func()也有可能会自动转换为abc.func()。</p></li></ol><p>对于(2)，例如有引用类型的变量n，那么n &gt; &amp;30和*n &gt; 30的效果是一样的。</p><p>————————————————《rust入门秘籍》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://rust-book.junmajinlong.com/ch3/07_reference_type.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rust中的引用&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.zhangzonglinagain.xyz/categories/rust/"/>
    
    
      <category term="references" scheme="http://blog.zhangzonglinagain.xyz/tags/references/"/>
    
  </entry>
  
  <entry>
    <title>Rust是基于表达式的语言</title>
    <link href="http://blog.zhangzonglinagain.xyz/2022/03/16/rust-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.zhangzonglinagain.xyz/2022/03/16/rust-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-03-15T17:04:00.000Z</published>
    <updated>2022-03-16T17:15:02.351Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch1/01_expression.html" target="_blank" rel="noopener">Rust是基于表达式的语言</a></p><a id="more"></a><p>除了在表达式尾部加分号的代码是语句之外，还有另外一种情况的代码是语句而非表达式：<strong>用于声明或定义</strong>。例如let声明变量、fn定义函数、struct声明结构体等。</p><p>Rust很多地方都会结合表达式和语句来做变量赋值。例如，if结构也是一个表达式，所以它有返回值，可以将if的返回值赋值给变量，而<strong>它的返回值来自于它的大括号</strong>：当大括号最后执行的一条代码不加分号结尾时，该代码的计算结果就是if结构的返回值。</p><p>————————————————《rust入门秘籍》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://rust-book.junmajinlong.com/ch1/01_expression.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rust是基于表达式的语言&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="rust" scheme="http://blog.zhangzonglinagain.xyz/tags/rust/"/>
    
  </entry>
  
</feed>
