<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>intellij-idea的快捷键</title>
    <url>/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p><a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">Intellij-idea的快捷键</a></p>
]]></content>
  </entry>
  <entry>
    <title>java中的乱码</title>
    <url>/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a>、<a href="https://blog.csdn.net/u010234516/article/details/52853214" target="_blank" rel="noopener">锟斤拷？UTF-8与GBK互转，为什么会乱码？</a></p>
<p>附图一张:</p>
<a id="more"></a>
<p><img src="/images/crazyCode.jpg" alt="upload successful"></p>
]]></content>
      <tags>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket --Token Authentication</title>
    <url>/2020/06/07/websocket-Token-Authentication/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链接：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication" target="_blank" rel="noopener">STOMP–Token Authentication</a></p>
]]></content>
  </entry>
  <entry>
    <title>cors--springboot shiro 前后端分离跨域</title>
    <url>/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。</p>
<a id="more"></a>
<h3 id="跨域的两种方案"><a href="#跨域的两种方案" class="headerlink" title="跨域的两种方案"></a>跨域的两种方案</h3><h4 id="沿用Cookie"><a href="#沿用Cookie" class="headerlink" title="沿用Cookie"></a>沿用Cookie</h4><p>沿用传统的cookie session方式，就需要前后端分别设置，可以让前端的request带上后端域名对应的cookie</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>客户端需要设置Ajax请求属性withCredentials 为true，让Ajax请求都带上Cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">           url:url,</span><br><span class="line">           type:&quot;GET&quot;,</span><br><span class="line">           xhrFields:&#123;</span><br><span class="line">               withCredentials:true</span><br><span class="line">           &#125;,</span><br><span class="line">           success:function(res)&#123; </span><br><span class="line">               console.log(res);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>首先服务端在使用cors协议时需要设置响应消息头<em>Access-Control-Allow-Credentials<em>的值为</em>true*，即允许在ajax访问时携带cookie(如上，前端也要设置withCredentials为true)。另外为了安全，在cors标准里不允许Access-Control-Allow-Origin设置为</em>,而是必须指定明确的、与请求网页一致的域名，cookie也依然遵循“同源策略”，只有用目标服务器域名设置的cookie才会上传，而且使用document.cookie也无法读取目标服务器域名下的cookie。接下来我们来看看实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">]</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)     &#x2F;&#x2F; 此时，不允许为*</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">&#x2F;&#x2F;            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义http-header"><a href="#自定义http-header" class="headerlink" title="自定义http header"></a>自定义http header</h4><p>绕过cookie，自定义http header传输token(本项目token即sessionId)，这种方式适合前端不支持cookie的时候，具体设置在后文中。</p>
<h3 id="session管理"><a href="#session管理" class="headerlink" title="session管理"></a>session管理</h3><p>采用第二种方式，就需要绕过传统的sessionid传输方式：通过请求头里的cookie传输（浏览器的cookie是跟着域名走的）。客户端登录，服务端通过JSON返回sessionid，客户端保存，后续每次请求要在请求头中添加加token字段，服务端shiro根据请求头的token字段获取sessionid。<br>shiroConfiguration中的securityManager配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        manager.sessionManager &#x3D; sessionManager()</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun sessionManager(): SessionManager? &#123;</span><br><span class="line">        val mySessionManager &#x3D; MySessionManager()</span><br><span class="line">        mySessionManager.setSessionDAO(sessionDAO())</span><br><span class="line">        return mySessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要是在MySessionManager里重写DefaultWebSessionManager的getSessionId方法和retrieveSession方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.apache.shiro.session.Session</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey</span><br><span class="line">import org.apache.shiro.web.servlet.ShiroHttpServletRequest</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line">import org.apache.shiro.web.util.WebUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import java.io.Serializable</span><br><span class="line">import java.lang.Boolean</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class MySessionManager : DefaultWebSessionManager&#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var log &#x3D; LoggerFactory.getLogger(this.javaClass.name)</span><br><span class="line">        private val AUTHORIZATION &#x3D; &quot;auth-token&quot;</span><br><span class="line">        private val HEADER_SESSION_ID_SOURCE &#x3D; &quot;header request&quot;</span><br><span class="line">        private val MY_SESSION_ATTRIBUTE &#x3D; &quot;MY_SESSION_ATTRIBUTE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override fun getSessionId(request: ServletRequest, response: ServletResponse?): Serializable? &#123;</span><br><span class="line">        val id &#x3D; WebUtils.toHttp(request).getHeader(AUTHORIZATION)</span><br><span class="line">        &#x2F;&#x2F;如果请求头中有 Authorization 字段， 则其值为sessionId</span><br><span class="line">        return if (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, HEADER_SESSION_ID_SOURCE)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE)</span><br><span class="line">            id</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;否则按默认规则从cookie取sessionId</span><br><span class="line">            super.getSessionId(request, response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(UnknownSessionException::class)</span><br><span class="line">    protected override fun retrieveSession(sessionKey: SessionKey?): Session? &#123;</span><br><span class="line">        val sessionId &#x3D; getSessionId(sessionKey) ?: return null</span><br><span class="line">        val request: ServletRequest &#x3D; WebUtils.getRequest(sessionKey)</span><br><span class="line">        return if (request.getAttribute(MY_SESSION_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">            log.debug(&quot;Get Session from request!&quot;)</span><br><span class="line">            request.getAttribute(MY_SESSION_ATTRIBUTE) as Session</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Get Session from redis!&quot;)</span><br><span class="line">            val s: Session &#x3D; retrieveSessionFromDataSource(sessionId)</span><br><span class="line">            if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;session ID was provided, meaning one is expected to be found, but we couldn&#39;t find one:</span><br><span class="line">                val msg &#x3D; &quot;Could not find session with ID [$sessionId]&quot;</span><br><span class="line">                throw UnknownSessionException(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            request.setAttribute(MY_SESSION_ATTRIBUTE, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>  对于简单请求，浏览器直接在ruquest头之中，增加一个Origin字段，相应地，服务器会在response头中添加Access-Control-Allow-Origin等字段，如此便是一次成功的跨域请求。</p>
<p><img src="/images/pasted-24.png" alt="upload successful"><br>只要同时满足以下两大条件，就属于简单请求。</p>
<p>请求方法是以下三种方法之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure>
<p>HTTP的头信息不超出以下几种字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight），预检的请求方法（Request Method）为OPTION。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义过滤器，针对请求头中有Origin字段的，response头中添加相应字段，针对OPITION请求,response返回200状态码。<br>新建CorsFilter类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.http.HttpStatus</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod</span><br><span class="line">import javax.servlet.*</span><br><span class="line">import javax.servlet.http.HttpServletRequest</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@WebFilter(urlPatterns &#x3D; arrayOf(&quot;&#x2F;*&quot;),filterName &#x3D; &quot;crosFilter&quot;)</span><br><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">            logger.info(&quot;处理跨域请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立WebFilterConfig类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean</span><br><span class="line">import org.springframework.context.annotation.Bean</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import javax.servlet.Filter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1：自定义过滤器，可以采取Filter加@WebFilter和启动类加@ServletComponentScan的方式，过滤器的执行顺序按照类名排序</span><br><span class="line"> * 故而采用如下FilterRegistrationBean的方式，可以自定义顺序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">class WebFilterConfig&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun crosResFilter(): FilterRegistrationBean&lt;*&gt;? &#123;</span><br><span class="line">        val filterRegistrationBean: FilterRegistrationBean&lt;Filter?&gt; &#x3D; FilterRegistrationBean&lt;Filter?&gt;()</span><br><span class="line">        val corsFilter &#x3D; CorsFilter()</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter)</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;) &#x2F;&#x2F;配置过滤规则</span><br><span class="line">        filterRegistrationBean.setName(&quot;corsFilter&quot;) &#x2F;&#x2F;设置过滤器名称</span><br><span class="line">        filterRegistrationBean.order &#x3D; 1 &#x2F;&#x2F;执行次序</span><br><span class="line">        return filterRegistrationBean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此便能愉快的跨域访问了。</p>
<h3 id="shiro跳转"><a href="#shiro跳转" class="headerlink" title="shiro跳转"></a>shiro跳转</h3><p>由于shiro对前后端分离支持不是很理想，如访问需认证的路径，若未登录会直接跳转至登录页面（默认是/login.jsp），这中情况我们需要直接返回未认证的JSON数据，由前端控制路由。<br>新建MyFormAuthenticationFilter，继承shiro的FormAuthenticationFilter（对应过滤authc的路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.JsonUtils</span><br><span class="line">import com.example.customer.util.constants.ErrorEnum</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line">class MyFormAuthenticationFilter : FormAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val log &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun onAccessDenied(request: ServletRequest?, response: ServletResponse?): Boolean &#123;</span><br><span class="line">        return if (isLoginRequest(request, response)) &#123;</span><br><span class="line">            if (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                executeLogin(request, response)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login page view.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;allow them to see the login page ;)</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var resp &#x3D; response as HttpServletResponse</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +</span><br><span class="line">                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不再跳转，直接返回Json信息</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.getWriter().write(JsonUtils.errorJson(ErrorEnum.E_401).toString())</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在shiro过滤链中，添加自定义过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class ShiroConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * shiro过滤器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun shiroFilter(manager: SecurityManager) : ShiroFilterFactoryBean&#123;</span><br><span class="line">        val factoryBean &#x3D; ShiroFilterFactoryBean()</span><br><span class="line">        &#x2F;&#x2F;设置securityManager</span><br><span class="line">        factoryBean.securityManager &#x3D; manager</span><br><span class="line">        &#x2F;&#x2F;自定义过滤器,修改认证失败跳转</span><br><span class="line">        val filters &#x3D; mutableMapOf&lt;String,Filter&gt;()</span><br><span class="line">        filters.put(&quot;myauthc&quot;,myFormAuthenticationFilter())</span><br><span class="line">        factoryBean.filters &#x3D;  filters</span><br><span class="line"></span><br><span class="line">        val filterChainDefinitionMap: MutableMap&lt;String, String&gt; &#x3D; LinkedHashMap()</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;static&#x2F;**&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 静态资源匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;doLogin&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;logout&quot;] &#x3D; &quot;logout&quot; &#x2F;&#x2F; 用户退出，只需配置logout即可实现该功能</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;**&quot;] &#x3D; &quot;myauthc&quot; &#x2F;&#x2F; 其他路径均需要身份认证，一般位于最下面，优先级最低</span><br><span class="line">        &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面</span><br><span class="line">        &#x2F;&#x2F;身份认证失败，不直接Shiro跳转至默认登录页，而是跳转至未认证接口，返回Json数据，前后端分离中登录界面跳转应由前端路由控制</span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F; factoryBean.setLoginUrl(&quot;&#x2F;login&#x2F;unauth&quot;);</span><br><span class="line">        &#x2F;&#x2F; 权限认证失败，跳转后续处理</span><br><span class="line"> &#x2F;&#x2F;       factoryBean.setUnauthorizedUrl(&quot;&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap)</span><br><span class="line"></span><br><span class="line">        return factoryBean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private fun myFormAuthenticationFilter(): MyFormAuthenticationFilter&#123;</span><br><span class="line">        return MyFormAuthenticationFilter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *securityManager配置</span><br><span class="line">     * 不指定名字的话，自动创建一个方法名第一个字母小写的bean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
        <category>shiro</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>cors</tag>
        <tag>shiro</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin 构造函数</title>
    <url>/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://www.cnblogs.com/Jetictors/p/7758828.html" target="_blank" rel="noopener">Kotlin——中级篇（一）：类（class）详解</a></strong>、<strong><a href="https://www.jianshu.com/p/5db34354d812" target="_blank" rel="noopener">kotlin之构造函数(constructor)
</a></strong><br>1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。</p>
<p>2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派</p>
<a id="more"></a>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test constructor(num: Int)&#123;</span><br><span class="line">    constructor(num : Int, num2: Int) : this(num) &#123;</span><br><span class="line">        println(num + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：二级构造函数中的参数1(num)，是委托了主构造函数的参数num。</span><br></pre></td></tr></table></figure>

<p>3、在JVM上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。<br>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>json web token(jwt)</title>
    <url>/2020/05/02/json-web-token-jwt/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://learnku.com/articles/22616" target="_blank" rel="noopener">别再使用 JWT 作为 Session 系统！问题重重且很危险。
</a></strong><br>结论：无状态 JWT Tokens 无法被单独地销毁或更新，取决于你如何存储，可能还会导致长度问题、安全隐患。有状态 JWT Tokens 在功能方面与 Session cookies 无异，但缺乏生产环境的验证、经过大量 Review 的实现，以及良好的客户端支持。<br>JWT 特别有效的使用例子通常是作为一次性的授权令牌。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之IP、MAC</title>
    <url>/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://www.wmathor.com/index.php/archives/1124/" target="_blank" rel="noopener">MAC 地址与 IP 地址</a></strong>、<strong><a href="https://zhuanlan.zhihu.com/p/82184208" target="_blank" rel="noopener">物理层 和 MAC 层</a></strong>、<strong><a href="https://www.jianshu.com/p/63fd0faa47da" target="_blank" rel="noopener">网络传输中的三张表，MAC地址表、ARP缓存表以及路由表详解</a></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>MAC</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>锁、synchronized、CAS、volatile</title>
    <url>/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></strong>、<strong><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></strong>、<strong><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析
</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/12129120.html" target="_blank" rel="noopener">从原子类和UNSAFE来理解JAVA内存模型，ATOMICINTEGER的INCREMENTANDGET方法和UNSAFE部分源码介绍，VALUEOFFSET偏移量的理解</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9396834.html" target="_blank" rel="noopener">JAVA内存模型中VOLATILE关键字的作用
</a></strong>、<strong><a href="https://www.cnblogs.com/theRhyme/p/9399881.html" target="_blank" rel="noopener">JAVA内存模型，为啥线程要有自己的本地内存，CPU高速缓存
</a></strong></p>
]]></content>
      <tags>
        <tag>lock</tag>
        <tag>synchronized</tag>
        <tag>CAS</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP之NAT</title>
    <url>/2020/03/27/CP-IP%E4%B9%8BNAT/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://www.mobilezhao.com/?cat=3" target="_blank" rel="noopener">TCP/IP之NAT</a></strong></p>
]]></content>
      <categories>
        <category>tcp/ip</category>
      </categories>
      <tags>
        <tag>nat</tag>
      </tags>
  </entry>
  <entry>
    <title>补码原理的个人理解</title>
    <url>/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/jiaobuchong/article/details/83188674" target="_blank" rel="noopener">补码原理的个人理解</a></strong></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring设计思想-事务篇》2.数据库隔离级别</title>
    <url>/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">《Spring设计思想-事务篇》2.数据库隔离级别
</a></strong>，<strong><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">深入分析事务的隔离级别</a></strong>，<strong><a href="https://www.hollischuang.com/archives/923" target="_blank" rel="noopener">MySQL中的共享锁与排他锁</a></strong></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。</p>
<a id="more"></a>

<p>事务的并发数和数据数据一致性这两个是两个相反的理想指标。而数据库研发的方向就是尽可能提高同时提高两个指标，尽可能减少之间的反作用影响。</p>
<p>SERIALIZABLE 序列化读，隔离级别最高，客户端以互斥的方式访问数据库资源，统一时间内，同一个资源只能被一个客户端访问，好像客户端在排队请求访问，所以称为序列化读。<br>REPEATABLE_READ 可重复读，可重复读能够保证，一个客户端在一个事务内，多次访问同一个资源时，返回结果是一样的，顾名思义，称为可重复读，这种隔离级别可能会造成幻读现象。<br>READ_COMMITTED 读已提交，即客户端在一个事务内，每次查询读取的数据都是从数据库读取最新的已提交的数据；这种隔离界别可能会造成不可重复读和幻读现象。<br>READ_UNCOMMITTED 读未提交，即客户端在一个事务内，可以读取到其他客户端事务的尚未提交的数据；这种隔离级别可能会造成脏读、不可重复读、幻读 现象。</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
]]></content>
  </entry>
  <entry>
    <title>《Spring设计思想》AOP设计基本原理</title>
    <url>/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">《Spring设计思想》AOP设计基本原理
</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）
</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <url>/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/</url>
    <content><![CDATA[<p>转载：<strong><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）
</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>spring 线程安全</title>
    <url>/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>转载：<a href="https://www.cnblogs.com/kismetv/p/8757260.html" target="_blank" rel="noopener"><strong>Spring中获取request的几种方法，及其线程安全性分析</strong></a>、<strong><a href="https://www.jianshu.com/p/e04491f3550f" target="_blank" rel="noopener">Spring 如何保证线程安全
</a></strong>、<strong><a href="https://blog.csdn.net/cs408/article/details/48972653" target="_blank" rel="noopener">Spring中Singleton模式的线程安全
</a></strong></p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作</p>
<a id="more"></a>
<p>数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧。并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该栈帧并释放掉。</p>
<p>&emsp;注意：Java栈中的数据是线程私有的，一个线程是无法访问另一个线程的Java栈的数据。这也就是为什么多线程编程时，两个相同线程执行同一方法时，对方法内的局部变量是不需要数据同步的原因。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-invokeinterface</title>
    <url>/2020/03/09/vm-invokeinterface/</url>
    <content><![CDATA[<p>转载：<a href="https://blog.csdn.net/kang389110772/article/details/50723127" target="_blank" rel="noopener">Spring为什么Autowired注入的是接口
</a>、</p>
<p><a href="https://github.com/1993hzh/thoughts/issues/5" target="_blank" rel="noopener">浅析JVM中invokevirtual与invokeinterface的区别 #5
</a>、</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.3" target="_blank" rel="noopener">Java Virtual Machine Specification</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java底层机制（堆/栈/方法区/GC/类加载）</title>
    <url>/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载:<strong><a href="https://www.jianshu.com/p/ae97b692614e?from=timeline" target="_blank" rel="noopener">java底层机制</a></strong>、<strong><a href="https://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot注解基本了解</title>
    <url>/2020/03/06/java-annotation/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里放两篇对Java注解的文章，以备后面查询。<a href="https://www.jianshu.com/p/d74ed7374841" target="_blank" rel="noopener"><strong>Spring Boot 注解—基本知识</strong></a>以及<a href="https://www.cnblogs.com/liaojie970/p/7879917.html" target="_blank" rel="noopener"><strong>Java注释@interface的用法</strong></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>idea下gradle报jdk版本错误</title>
    <url>/2020/03/05/idea-gradle-jdk/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”</p>
<a id="more"></a>
<p>确认project采用的jdk 13,build.gradle里也是13，应该是Gradle用的版本不匹配，最后在File–&gt;Setting–&gt;Build Tools–&gt;Gradle里，找到配置项。</p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC的实现原理—反射与工厂模式(转载)</title>
    <url>/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="反射与工厂模式实现IOC"><a href="#反射与工厂模式实现IOC" class="headerlink" title="反射与工厂模式实现IOC"></a>反射与工厂模式实现IOC</h3><p>   &emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：<br>   <a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125; </span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Orange&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造工厂类</span><br><span class="line">&#x2F;&#x2F;也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了</span><br><span class="line">class Factory&#123;</span><br><span class="line">     public static fruit getInstance(String fruitName)&#123;</span><br><span class="line">         fruit f&#x3D;null;</span><br><span class="line">         if(&quot;Apple&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Apple();</span><br><span class="line">         &#125;</span><br><span class="line">         if(&quot;Orange&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Orange();</span><br><span class="line">         &#125;</span><br><span class="line">         return f;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">     public static void main(String[] a)&#123;</span><br><span class="line">         fruit f&#x3D;Factory.getInstance(&quot;Orange&quot;);</span><br><span class="line">         f.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   &emsp;上面写法的缺点是当我们再添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改动就会很多。下面用反射机制实现工厂模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">     public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a)&#123;</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(&quot;Reflect.Apple&quot;);</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  &emsp;现在就算我们添加任意多个子类的时候，工厂类都不需要修改。使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。</p>
<p>   &emsp;下面编写使用反射机制并结合属性文件的工厂模式（即IoC）。首先创建一个fruit.properties的资源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apple&#x3D;Reflect.Apple</span><br><span class="line">orange&#x3D;Reflect.Orange</span><br></pre></td></tr></table></figure>
<p>   &emsp;然后编写主类代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;操作属性文件类</span><br><span class="line">class init&#123;</span><br><span class="line">    public static Properties getPro() throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;new Properties();</span><br><span class="line">        File f&#x3D;new File(&quot;fruit.properties&quot;);</span><br><span class="line">        if(f.exists())&#123;</span><br><span class="line">            pro.load(new FileInputStream(f));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pro.setProperty(&quot;apple&quot;, &quot;Reflect.Apple&quot;);</span><br><span class="line">            pro.setProperty(&quot;orange&quot;, &quot;Reflect.Orange&quot;);</span><br><span class="line">            pro.store(new FileOutputStream(f), &quot;FRUIT CLASS&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a) throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;init.getPro();</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(pro.getProperty(&quot;apple&quot;));</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;运行结果：Apple</p>
<h3 id="IOC容器的技术剖析"><a href="#IOC容器的技术剖析" class="headerlink" title="IOC容器的技术剖析"></a>IOC容器的技术剖析</h3><p> &emsp;IOC中最基本的技术就是“反射(Reflection)”编程，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要生产的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。</p>
<p> &emsp;目前C#、Java和PHP5等语言均支持反射，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚。反射的应用是很广泛的，很多的成熟的框架，比如像Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.NET框架都是把”反射“做为最基本的技术手段。</p>
<p>&emsp;反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。</p>
<p>&emsp;我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h3 id="使用IOC框架应该注意什么"><a href="#使用IOC框架应该注意什么" class="headerlink" title="使用IOC框架应该注意什么"></a>使用IOC框架应该注意什么</h3><p>&emsp;使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<p>&emsp;1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p>
<p>&emsp;2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p>&emsp;3）具体到IOC框架产品（比如Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p>
<p>&emsp;4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</p>
<p>&emsp;我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。<br>————————————————<br>版权声明：本文为CSDN博主「fuzhongmin05」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/fuzhongmin05/article/details/61614873" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>java类加载</title>
    <url>/2020/03/03/va-class/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里贴一个介绍类加载的介绍链接：<a href="https://juejin.im/post/5dac4edff265da5b5f7588d1#heading-0" target="_blank" rel="noopener">java 的类加载</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/03/03/ava-reflection/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。</p>
<a id="more"></a>


<h3 id="反射回顾"><a href="#反射回顾" class="headerlink" title="反射回顾"></a>反射回顾</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p>Oracle 官方对反射的解释是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</span><br><span class="line">The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</span><br></pre></td></tr></table></figure>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java 反射主要提供以下功能：</p>
<p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p>
<h3 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h3><p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;login&quot;</span><br><span class="line">               class&#x3D;&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;</span><br><span class="line">               method&#x3D;&quot;execute&quot;&gt;</span><br><span class="line">           &lt;result&gt;&#x2F;shop&#x2F;shop-index.jsp&lt;&#x2F;result&gt;</span><br><span class="line">           &lt;result name&#x3D;&quot;error&quot;&gt;login.jsp&lt;&#x2F;result&gt; </span><br><span class="line">&lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">反射调用的一个Log</a><br><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Java反射原理简析</a></p>
<p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
]]></content>
  </entry>
  <entry>
    <title>java自定义类equal重写</title>
    <url>/2020/02/27/ava-equal/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。</p>
<a id="more"></a>
<p>比较的常用对象如int，float和String等，已重写了equals和hashcode方法，默认比较的是值，而其它自定义对象在用equal时都是比较的引用地址，故此有需要的时候需要重写equal方法。</p>
<h3 id="重写equal的要求"><a href="#重写equal的要求" class="headerlink" title="重写equal的要求"></a>重写equal的要求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;  </span><br><span class="line">        if(this &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(null &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">       if (obj instanceof Test)&#123;</span><br><span class="line">            Test o &#x3D; (Test) obj;</span><br><span class="line">            return this.id &#x3D;&#x3D; o.id;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重写equals方法的要求：<br>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。<br>2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。<br>3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。<br>4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。<br>5、非空性：对于任意非空引用x，x.equals(null)应该返回false。</p>
<h3 id="hashCode方法也要重写"><a href="#hashCode方法也要重写" class="headerlink" title="hashCode方法也要重写"></a>hashCode方法也要重写</h3><p>问什么说<strong>重写了equals方法都要进而重写Hashcode方法</strong>呢？</p>
<p>原因如下：当equals此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p>
<p>   &emsp;&emsp;hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p>
<p>   &emsp;&emsp;以HashMap为例说一下的原理，HashMap存储数据的时候，是取的key值的哈希值，然后计算数组下标，采用链地址法解决冲突，然后进行存储；取数据的时候，依然是先要获取到hash值，找到数组下标，然后for遍历链表集合，进行比较是否有对应的key。比较关心的有2点：<br>  &emsp;&emsp; 1.不管是put还是get的时候，都需要得到key的哈希值，去定位key的数组下标；<br>   &emsp;&emsp;2.在get的时候，需要调用equals方法比较是否有相等的key存储过。</p>
<p>   更详细具体的可以看<a href="https://www.jianshu.com/p/75d9c2c3d0c1" target="_blank" rel="noopener">这篇博文</a>或者<a href="https://www.cnblogs.com/silence-hust/p/4510574.html" target="_blank" rel="noopener">这一篇</a></p>
]]></content>
  </entry>
  <entry>
    <title>RxJava --学习链接</title>
    <url>/2020/02/18/xJava/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Rx（Reactive Extensions）是一个使用<code>可观察数据流</code>进行<code>异步编程</code>的编程接口，ReactiveX结合了<code>观察者模式</code>、<code>迭代器模式</code>和<code>函数式编程</code>的精华。Rx的语言库比较流行的有RxJava/RxJS/Rx.NET，这里贴一些有关RxJava的链接，以便后续查找。</p>
<a id="more"></a>
<p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">Rx中文文档</a><br><a href="https://www.jianshu.com/p/03a72a5a2049" target="_blank" rel="noopener">RxJava心得</a><br><a href="https://blog.lixplor.com/2016/10/16/rxjava/" target="_blank" rel="noopener">RxJava操作符</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio多语言(中英)适配</title>
    <url>/2020/02/14/ndroid-studio%E4%B8%AD%E8%8B%B1%E6%96%87%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>strings.xml在目录res相应的value文件夹下,用来显示文本，避免硬编码，要添加新的语言支持，就要在不同的 value 文件夹下（如value 、values-zh-rCN）添加不同语言的 string.xml 文件。本文以简体中文为例,描述一下Android studio下相应strings.xml(zh-rCN)的生成方式，其他语言类似。</p>
<a id="more"></a>
<h3 id="手动建立文件"><a href="#手动建立文件" class="headerlink" title="手动建立文件"></a>手动建立文件</h3><p>选中res文件夹，右键New–&gt;Android Resource Directory,然后选中Locale,如下图所示：</p>
<p><img src="/images/pasted-17.png" alt="upload successful"><br>选择相应语言和相应区域：</p>
<p><img src="/images/pasted-18.png" alt="upload successful"><br>文件夹名称（values-zh-rCN）自动生成，最后在该文件夹生成strings.xml即可。项目视图如下：</p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p>打开Translations Editor（双击打开strings.xml，窗口右上角点击Open Editor），点击Add Locale，在下拉菜单中选择相应语言区域，系统会自动生成相应文件夹以及strings.xml文件。</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
]]></content>
  </entry>
  <entry>
    <title>android studio 真机调试</title>
    <url>/2020/02/10/android-run-on-a-real-device/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android studio调试的时候可以运行在模拟器，也可以在真机上运行，本文记录一下真机（MIUI10）调试的前期准备。</p>
<a id="more"></a>
<h3 id="Windows设置"><a href="#Windows设置" class="headerlink" title="Windows设置"></a>Windows设置</h3><p>打开AS，点击File–&gt;Setting–&gt;Appearance &amp; Behavior–&gt;System Setting–&gt;Android SDK，在SDK Platforms下勾选真机Android版本相应的SDK。</p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>在SDK Tools目录下勾选Google Usb Driver，点击Apply，AS会自动下载Usb驱动，并记下Android SDK location。</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>数据线连接手机，windows打开设备管理器，点击便携设备，</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<p>点击相应的设备MI 5 ，选择驱动程序，更新驱动程序，浏览我的计算机以查找更新驱动程序，输入目录：AS中记下的SDK目录\extras\google\usb_driver，并安装。<br><img src="/images/pasted-12.png" alt="upload successful"></p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<h3 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h3><p>首先要打开开发者模式（每款手机的开发者模式打开方式不同，大家自行搜索），以小米为例，“设置-我的设备-全部参数-多次点击MIUI版本（有提示），如此便进入“开发者模式”了，在“更多设置”找到开发者选项，打开“USB调试” “USB安装”，并把滚动条滚到最下面，关掉“启用MIUI优化”。</p>
<p>如此便可以进入android studio调试安装了。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android-studio</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio http proxy for sdk </title>
    <url>/2020/02/02/andorid-studio-proxy-setting/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>闲来无事，研究一下安卓的开发，并记录一下开发工具android studio的配置，主要是安装时要下载android sdk，又因长城的原因，需要设置国内镜像，或者如果你能科学上网的话，设置http proxy也可。</p>
<a id="more"></a>

<h3 id="镜像设置"><a href="#镜像设置" class="headerlink" title="镜像设置"></a>镜像设置</h3><p>这里用的是电子科技大学的镜像网站：mirrors.dormforce.net 端口：80<br>通过File–&gt;Setting–&gt;Appearance &amp; Behavior –&gt;System Settings –&gt;Http Proxy，选择Auto-detect proxy settings，并且填写URL为：mirrors.dormforce.net :80，点击clear passwords<br><img src="/images/pasted-0.png" alt="upload successful"></p>
<h3 id="Http-proxy设置"><a href="#Http-proxy设置" class="headerlink" title="Http proxy设置"></a>Http proxy设置</h3><p>这个适合可以科学上网的同学，我用的是trojan,配置如下：<br>Manual proxy configuration–&gt;SOCKS–&gt;Host name:127.0.0.1 Port number:1080<br>完成后点击Check connection，输入网址<em><a href="https://www.android.com/" target="_blank" rel="noopener">https://www.android.com/</a></em>，测试连接。</p>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p>通过上述两种之一的方式设置后，点击Android SDK,点击SDK Update Sites，下面勾选<em>『Force https://… sources to be fetched using http://…』</em>，点击Apply，完成后返回主页面即可。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>pac.txt---url通配规则</title>
    <url>/2020/01/30/pac/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>科学上网PAC模式，有时会需要自己在pac.txt里添加一些被墙的URL，记录一下url通配的规则，以备以后使用。</p>
<a id="more"></a>
<ol>
<li>通配符支持。比如 .example.com/ 实际书写时可省略 * ， 如 .example.com/ ， 和 *.example.com/ 效果一样</li>
<li>正则表达式支持。以 \ 开始和结束， 如 [\w]+://example.com\</li>
<li>例外规则 @@ ，如 @@.example.com/ 满足 @@ 后规则的地址不使用代理</li>
<li>匹配地址开始和结尾 | ，如 |<a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 、 example.com| 分别表示以 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 开始和以 example.com 结束的地址</li>
<li>|| 标记，如 ||example.com 则 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 、 <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 、 <a href="ftp://example.com" target="_blank" rel="noopener">ftp://example.com</a> 等地址均满足条件</li>
<li>注释 ! 。 如 !我是注释<br>v2rayN需重启生效。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>trojan科学上网</title>
    <url>/2020/01/29/gfw/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直用的ssr科学上网，侥幸挺过了去年国庆等的各种严打，一直傲娇地活跃到年底，没想到值此新春佳节之际，终于不出预料地被封了，丧事喜办，旧的不去新的不来，正好试试trojan，希望他能接过前辈的火种，超神带我飞，直直挺到2021吖，本文记录一下vps、windows pc以及android手机的配置。</p>
<a id="more"></a>
<h3 id="vps配置"><a href="#vps配置" class="headerlink" title="vps配置"></a>vps配置</h3><h4 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h4><p>系统centos7，网上荡来的一键安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;atrandys&#x2F;trojan&#x2F;master&#x2F;trojan_mult.sh &amp;&amp; chmod +x trojan_mult.sh &amp;&amp; .&#x2F;trojan_mult.sh</span><br></pre></td></tr></table></figure>
<p>根据脚本提示，该输入数字输入数字，该输入域名输入域名，一撸到底，成功后屏幕会显示一个客户端的链接，弃之不用。</p>
<h4 id="bbr加速"><a href="#bbr加速" class="headerlink" title="bbr加速"></a>bbr加速</h4><p>先查看系统内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p>低于4.10的需升级内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo&#x3D;elrepo-kernel install kernel-ml -y</span><br></pre></td></tr></table></figure>
<p>安装完毕后查看已安装内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F\&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;etc&#x2F;grub2.cfg</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 : CentOS Linux 7 Rescue f128bc3705574dfab442f23fb7245e0b (5.5.0-1.el7.elrepo.x86_64)</span><br><span class="line">1 : CentOS Linux (5.5.0-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (3.10.0-1062.9.1.el7.x86_64) 7 (Core)</span><br><span class="line">3 : CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)</span><br><span class="line">4 : CentOS Linux (0-rescue-7bd68357fb1f47688c0f1b0a48330334) 7 (Core)</span><br></pre></td></tr></table></figure>
<p>根据序号设置默认内核：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub2-set-default 1</span><br></pre></td></tr></table></figure>
<p>重启服务器。<br>修改sysctl配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;net.core.default_qdisc&#x3D;fq&#39; | tee -a &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &#39;net.ipv4.tcp_congestion_control&#x3D;bbr&#39; |  tee -a &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>检查是否加载BBR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>如果输出结果包含tcp_bbr，则表示开启成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp_bbr   20480  35</span><br></pre></td></tr></table></figure>
<p>值此，VPS配置完毕。</p>
<h3 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h3><p>下载v2rayN客户端：<a href="https://github.com/2dust/v2rayN/releases/download/3.5/v2rayN.zip" target="_blank" rel="noopener">v2rayN</a><br>运行v2rayN.exe，服务器–&gt;Add [trojan]server–&gt;输入VPS IP，密码以及端口443–&gt;右击任务栏上v2rayN,启用Http代理，Http模式选择pac。<br>密码可以在vps（cat /usr/src/trojan/server.conf）trojan配置文件中查看。<br>至此，便可以在浏览器里科学上网了，至于其他电脑程序要科学上网，可以配置本机socks5代理，监听1080端口。</p>
<h3 id="android配置"><a href="#android配置" class="headerlink" title="android配置"></a>android配置</h3><p>现在只找到<a href="https://github.com/trojan-gfw/igniter/releases/download/v0.1.0-pre-alpha13/app-release.apk" target="_blank" rel="noopener">Igniter</a>，不太好用，静待更新。。。</p>
]]></content>
      <tags>
        <tag>trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/01/18/git-command/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前使用SVN,切换到分布式版本控制系统Git，此笔记记录一下学习心得，备询。<strong><a href="https://gist.github.com/guweigang/9848271" target="_blank" rel="noopener">git命令大全</a></strong>，贴个链接，比较<strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank" rel="noopener">适合初次接触者</a></strong>，<strong><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1" target="_blank" rel="noopener">动画演示Git命令</a></strong></p>
<a id="more"></a>
<h3 id="git配置代理"><a href="#git配置代理" class="headerlink" title="git配置代理"></a>git配置代理</h3><p>天朝特色，使用git clone下载同性交友网站（github）的仓库时，巨慢！如果可以科学上网的话，设置一下代理，加一下速…<br>本文用的trojan科学上网，利用它的socks5代理加速。配置命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;</span><br></pre></td></tr></table></figure>

<p>取消代理的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="git提交到多个remote"><a href="#git提交到多个remote" class="headerlink" title="git提交到多个remote"></a>git提交到多个remote</h3><p>本地生成博客页面，git部署到VPS远端，也顺便也部署到github。下面就通过把本地的文件提交到两个git远端(Remote)的事例，了解git命令的使用。<br>切换到指定目录（以目录hexo下的.deploy_git文件夹为例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init        &#x2F;&#x2F;初始化一个git的本地仓库(以前hexo deploy的时候已经有了本地仓库，配置信息在隐藏文件夹.git里)</span><br><span class="line">git add myfile. &#x2F;&#x2F;将myfile加入暂存区index（</span><br><span class="line">git commit -m “first commit” &#x2F;&#x2F;把暂存区的文件提交到本地仓库</span><br><span class="line">git remote add Name1 git@vps的IP:hexo.git &#x2F;&#x2F;增加一个新的远程仓库，并命名为Name1</span><br><span class="line">git push -u Name1 master &#x2F;&#x2F;把分支master的内容push到远程仓库</span><br><span class="line">git remote add Name2 git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line"> &#x2F;&#x2F;添加第二个远程仓库，并命名为Name2</span><br><span class="line">git push -u Name2 master &#x2F;&#x2F;将分支master的内容push到第二个远程仓库</span><br></pre></td></tr></table></figure>
<p>至此，就将本地文件提交到两个远端仓库了。<br>ps:由于我的github的yourname.github.io仓库里已经有了文件，所以push的时候会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: failed to push some refs to &#39;git@github.com:yourname&#x2F;yourname.github.io.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>
<p>解决方法：<br>$ git push -f Name2 master</p>
<h3 id="git-pull冲突"><a href="#git-pull冲突" class="headerlink" title="git pull冲突"></a>git pull冲突</h3><p>从github上fork了一个项目，并clone到本地，做了一些删改后，想要提交到github个人仓库，但发现作者项目更新了，便把fork来的项目通过New pull request和原项目同步更新了。这时本地在用git pull更新项目时，遇到了下面的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge: xxx&#x2F;xxx&#x2F;xxx </span><br><span class="line">Please, commit your changes or stash them before you can merge. </span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>解决方法两种：</p>
<h4 id="覆盖本地修改"><a href="#覆盖本地修改" class="headerlink" title="覆盖本地修改"></a>覆盖本地修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>这种会放弃本地修改的代码，看情况使用。</p>
<h4 id="使用git-stash"><a href="#使用git-stash" class="headerlink" title="使用git stash"></a>使用git stash</h4><p>这种会保留自己本地修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<p>最后就可以diff一下文件看看自动合并的情况，并对解决冲突文件做相应修改后提交即可。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>本地Hexo生成的博客部署到VPS</title>
    <url>/2020/01/17/localblog-git-vps/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为了科学上网搭建了vps，顺便跑一下自己的博客，但vps只有500M内存，所以决定本地windows跑hexo生成网页，然后git到vps，记录一下本地和vps的git配置。</p>
<a id="more"></a>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>本地windows安装Node.js hexo git，过程不提。</p>
<h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><p>安装后打开 Git Bash 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的电子邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>由于 Hexo 的 Git 部署不支持使用密码登陆，所以需要配置 SSH 公钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">cd .ssh</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>由此便在系统当前用户文件夹下生成了私钥 id_rsa 和公钥 id_rsa.pub。</p>
<p>在上面建立的.ssh文件中新建config文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">vim config</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host 服务器IP</span><br><span class="line">HostName 服务器IP</span><br><span class="line">User git</span><br><span class="line">Port 端口号</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<h4 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h4><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>打开位于 hexo 文件夹下的 _config.yml，修改 deploy 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@vps的IP:hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="VPS-配置"><a href="#VPS-配置" class="headerlink" title="VPS 配置"></a>VPS 配置</h3><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<h4 id="为用户git添加-sudo-权限"><a href="#为用户git添加-sudo-权限" class="headerlink" title="为用户git添加 sudo 权限"></a>为用户git添加 sudo 权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 &#x2F;etc&#x2F;sudoers</span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>找到以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>添加修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">git     ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>假如是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>则修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL) ALL</span><br><span class="line">git     ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>保存,退出</p>
<p>然后修改回文件的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<h4 id="关闭-git-用户-shell-权限"><a href="#关闭-git-用户-shell-权限" class="headerlink" title="关闭 git 用户 shell 权限"></a>关闭 git 用户 shell 权限</h4><p>至此我们可以在本地通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@VPS IP</span><br></pre></td></tr></table></figure>
<p>ssh 连接服务器，登录到服务器上，对服务器进行各种操作，这通常很不安全，也不合适，我们只需要能对仓库操作就可以了，不需要更大的权限。</p>
<p>因此我们关闭 git 用户 shell 权限，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<p>找到git用户的一行：<em>git:x:1001:1001:,,,:/home/git:/bin/bash</em><br>改为：<em>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</em></p>
<p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
<h4 id="初始化-git-仓库"><a href="#初始化-git-仓库" class="headerlink" title="初始化 git 仓库"></a>初始化 git 仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git                &#x2F;&#x2F;切换到git用户目录</span><br><span class="line">mkdir blog.git              &#x2F;&#x2F;创建git仓库文件夹，以blog.git为例</span><br><span class="line">cd blog.git                 &#x2F;&#x2F;进入仓库目录</span><br><span class="line">git init --bare             &#x2F;&#x2F;使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区</span><br></pre></td></tr></table></figure>
<p>注意：裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以.git 结尾。</p>
<h4 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git                &#x2F;&#x2F;切换到git用户目录</span><br><span class="line">mkdir .ssh                  &#x2F;&#x2F;创建.ssh目录</span><br><span class="line">cd .ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure>
<p>然后将本地的公钥复制到 authorized_keys 文件里 (公钥即上文生成的公钥，可通过 <em>cat ~/.ssh/id_rsa.pub</em> 查看)。</p>
<p>注意：收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <em>/home/git/.ssh/authorized_keys</em> 文件里，一行一个。</p>
<h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll &#x2F;home&#x2F;git&#x2F;</span><br><span class="line">ll &#x2F;var&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure>
<p>确保 blog.git、.ssh、blog 目录的用户组权限为 git:git，若不是，执行下列命令：</p>
<p>修改用户权限的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R git.git &#x2F;home&#x2F;git&#x2F;blog.git&#x2F;</span><br><span class="line">chown -R git.git &#x2F;home&#x2F;git&#x2F;.ssh&#x2F;</span><br><span class="line">chown -R git.git &#x2F;var&#x2F;www&#x2F;blog&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="配置-Git-Hooks"><a href="#配置-Git-Hooks" class="headerlink" title="配置 Git Hooks"></a>配置 Git Hooks</h4><p>创建 post-receive 文件<br>git 用户下执行（这里由于禁止了git用户shell权限，所以我用 root 用户执行上述命令，然后更改了文件所有者为 git.git）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git&#x2F;blog.git&#x2F;hooks     &#x2F;&#x2F;切换到hooks目录下</span><br><span class="line">vim post-receive            &#x2F;&#x2F;创建文件</span><br></pre></td></tr></table></figure>
<p>复制下面的内容到 post-receive 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;post-receive hook is running...&quot;</span><br><span class="line"></span><br><span class="line">GIT_REPO&#x3D;&#x2F;home&#x2F;git&#x2F;blog.git</span><br><span class="line">TMP_GIT_CLONE&#x3D;&#x2F;tmp&#x2F;blog</span><br><span class="line">PUBLIC_WWW&#x3D;&#x2F;var&#x2F;www&#x2F;blog</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;&#x2F;*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;&#x2F;* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接将裸仓库克隆到 Web 根目录下呢？我之前也一直被这个问题困扰，感觉先&gt;克隆到 tmp 目录再拷贝到 Web 根目录是多此一举。后来我觉得可能是出于项目安全的&gt;考虑，在执行 cp 命令的时候，.git 作为隐藏目录不会被拷贝到 Web 根目录下，也就&gt;避免了将整个仓库历史暴露在 Web 服务中。</p>
</blockquote>
<p>赋予可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<p>ok，至此配置完毕，可以本地hexo d直接发布到vps了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常用命令、快捷键</title>
    <url>/2020/01/17/vim-hotkey/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vim的常用命令以及快捷键，记录一下，方便以后查询。详细链接：<a href="https://linux.cn/article-8144-1.html" target="_blank" rel="noopener">Vim 快捷键速查表</a></p>
<a id="more"></a>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Esc</td>
<td>从当前模式转换到“普通模式”。所有的键对应到命令。</td>
</tr>
<tr>
<td>i</td>
<td>“插入模式”用于插入文字。回归按键的本职工作。</td>
</tr>
<tr>
<td>:</td>
<td>“命令行模式” Vim 希望你输入类似于保存该文档命令的地方。</td>
</tr>
</tbody></table>
<h3 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 Ctrl + J</td>
<td>光标向下移动一行</td>
</tr>
<tr>
<td>k 或 Ctrl + P</td>
<td>光标向上移动一行</td>
</tr>
<tr>
<td>l</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>0</td>
<td>（数字 0）移动光标至本行开头</td>
</tr>
<tr>
<td>$</td>
<td>移动光标至本行末尾</td>
</tr>
<tr>
<td>^</td>
<td>移动光标至本行第一个非空字符处</td>
</tr>
<tr>
<td>w</td>
<td>向前移动一个词 （上一个字母和数字组成的词之后）</td>
</tr>
<tr>
<td>W</td>
<td>向前移动一个词 （以空格分隔的词）</td>
</tr>
<tr>
<td>5w</td>
<td>向前移动五个词</td>
</tr>
<tr>
<td>b</td>
<td>向后移动一个词 （下一个字母和数字组成的词之前）</td>
</tr>
<tr>
<td>B</td>
<td>向后移动一个词 （以空格分隔的词）</td>
</tr>
<tr>
<td>5b</td>
<td>向后移动五个词</td>
</tr>
<tr>
<td>G</td>
<td>移动至文件末尾</td>
</tr>
<tr>
<td>gg</td>
<td>移动至文件开头</td>
</tr>
</tbody></table>
<h3 id="浏览文档"><a href="#浏览文档" class="headerlink" title="浏览文档"></a>浏览文档</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>跳转到上一句</td>
</tr>
<tr>
<td>)</td>
<td>跳转到下一句</td>
</tr>
<tr>
<td>{</td>
<td>跳转到上一段</td>
</tr>
<tr>
<td>}</td>
<td>跳转到下一段</td>
</tr>
<tr>
<td>[[</td>
<td>跳转到上一部分</td>
</tr>
<tr>
<td>]]</td>
<td>跳转到下一部分</td>
</tr>
<tr>
<td>[]</td>
<td>跳转到上一部分的末尾</td>
</tr>
<tr>
<td>][</td>
<td>跳转到上一部分的开头</td>
</tr>
</tbody></table>
<h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>在光标后插入文本</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入文本</td>
</tr>
<tr>
<td>i</td>
<td>在光标前插入文本</td>
</tr>
<tr>
<td>o</td>
<td>（小写字母 o）在光标下方新开一行</td>
</tr>
<tr>
<td>O</td>
<td>（大写字母 O）在光标上方新开一行</td>
</tr>
</tbody></table>
<h3 id="特殊插入"><a href="#特殊插入" class="headerlink" title="特殊插入"></a>特殊插入</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:r [filename]</td>
<td>在光标下方插入文件 [filename] 的内容</td>
</tr>
<tr>
<td>:r ![command]</td>
<td>执行命令 [command] ，并将输出插入至光标下方</td>
</tr>
</tbody></table>
<h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除光标处字符</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个词</td>
</tr>
<tr>
<td>d0</td>
<td>删至行首</td>
</tr>
<tr>
<td>d$</td>
<td>删至行末</td>
</tr>
<tr>
<td>d)</td>
<td>删至句末</td>
</tr>
<tr>
<td>dgg</td>
<td>删至文件开头</td>
</tr>
<tr>
<td>dG</td>
<td>删至文件末尾</td>
</tr>
<tr>
<td>dd</td>
<td>删除该行</td>
</tr>
<tr>
<td>3dd</td>
<td>删除三行</td>
</tr>
</tbody></table>
<h3 id="简单替换文本"><a href="#简单替换文本" class="headerlink" title="简单替换文本"></a>简单替换文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>r{text}</td>
<td>将光标处的字符替换成 {text}</td>
</tr>
<tr>
<td>R</td>
<td>进入覆写模式，输入的字符将替换原有的字符</td>
</tr>
</tbody></table>
<h3 id="复制-粘贴文本"><a href="#复制-粘贴文本" class="headerlink" title="复制/粘贴文本"></a>复制/粘贴文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制当前行至存储缓冲区</td>
</tr>
<tr>
<td>[“x]yy</td>
<td>复制当前行至寄存器 x</td>
</tr>
<tr>
<td>p</td>
<td>在当前行之后粘贴存储缓冲区中的内容</td>
</tr>
<tr>
<td>P</td>
<td>在当前行之前粘贴存储缓冲区中的内容</td>
</tr>
<tr>
<td>[“x]p</td>
<td>在当前行之后粘贴寄存器 x 中的内容</td>
</tr>
<tr>
<td>[“x]P</td>
<td>在当前行之前粘贴寄存器 x 中的内容</td>
</tr>
</tbody></table>
<h3 id="撤销-重做操作"><a href="#撤销-重做操作" class="headerlink" title="撤销/重做操作"></a>撤销/重做操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>撤销最后的操作</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做最后撤销的操作</td>
</tr>
</tbody></table>
<h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>/search_text</td>
<td>检索文档，在文档后面的部分搜索 search_text</td>
</tr>
<tr>
<td>?search_text</td>
<td>检索文档，在文档前面的部分搜索 search_text</td>
</tr>
<tr>
<td>n</td>
<td>移动到后一个检索结果</td>
</tr>
<tr>
<td>N</td>
<td>移动到前一个检索结果</td>
</tr>
<tr>
<td>:%s/original/replacement</td>
<td>检索第一个 “original” 字符串并将其替换成“replacement”</td>
</tr>
<tr>
<td>:%s/original/replacement/g</td>
<td>检索并将所有的 “original” 替换为“replacement”</td>
</tr>
<tr>
<td>:%s/original/replacement/gc</td>
<td>检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换</td>
</tr>
</tbody></table>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>m {a-zA-Z}</td>
<td>在当前光标位置设置书签，书签名可用一个大小写字母（{a-zA-Z}）</td>
</tr>
<tr>
<td>:marks</td>
<td>列出所有书签</td>
</tr>
<tr>
<td>{a-zA-Z}</td>
<td>跳转到书签 {a-zA-Z}</td>
</tr>
</tbody></table>
<h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>进入逐字可视模式</td>
</tr>
<tr>
<td>V</td>
<td>进入逐行可视模式</td>
</tr>
<tr>
<td>Esc</td>
<td>退出可视模式</td>
</tr>
</tbody></table>
<h3 id="改动选中文本"><a href="#改动选中文本" class="headerlink" title="改动选中文本"></a>改动选中文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>切换大小写</td>
</tr>
<tr>
<td>d</td>
<td>删除一个词</td>
</tr>
<tr>
<td>c</td>
<td>变更</td>
</tr>
<tr>
<td>y</td>
<td>复制</td>
</tr>
<tr>
<td>&gt;</td>
<td>右移</td>
</tr>
<tr>
<td>&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>!</td>
<td>通过外部命令进行过滤</td>
</tr>
</tbody></table>
<h3 id="保存并退出"><a href="#保存并退出" class="headerlink" title="保存并退出"></a>保存并退出</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:q</td>
<td>退出 Vim，如果文件已被修改，将退出失败</td>
</tr>
<tr>
<td>:w</td>
<td>保存文件</td>
</tr>
<tr>
<td>:w new_name</td>
<td>用 new_name 作为文件名保存文件</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件并退出 Vim</td>
</tr>
<tr>
<td>:q!</td>
<td>退出 Vim，不保存文件改动</td>
</tr>
<tr>
<td>ZZ</td>
<td>退出 Vim，如果文件被改动过，保存改动内容</td>
</tr>
<tr>
<td>ZQ</td>
<td>与 :q! 相同，退出 Vim，不保存文件改动</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim hotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>bash快捷键 光标移动</title>
    <url>/2020/01/16/bash-hot-key/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用xshell登录并操作系统的时候，光标移动的快捷键用起来很方便，记录一下，方便以后查询</p>
<a id="more"></a>
<h3 id="ctrl组合"><a href="#ctrl组合" class="headerlink" title="ctrl组合"></a>ctrl组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+a:光标移到行首。</span><br><span class="line"></span><br><span class="line">ctrl+b:光标左移一个字母</span><br><span class="line"></span><br><span class="line">ctrl+c:杀死当前进程。</span><br><span class="line"></span><br><span class="line">ctrl+d:退出当前 Shell。</span><br><span class="line"></span><br><span class="line">ctrl+e:光标移到行尾。</span><br><span class="line"></span><br><span class="line">ctrl+h:删除光标前一个字符，同 backspace 键相同。</span><br><span class="line"></span><br><span class="line">ctrl+k:清除光标后至行尾的内容。</span><br><span class="line"></span><br><span class="line">ctrl+l:清屏，相当于clear。</span><br><span class="line"></span><br><span class="line">ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history</span><br><span class="line"></span><br><span class="line">ctrl+u: 清除光标前至行首间的所有内容。</span><br><span class="line"></span><br><span class="line">ctrl+w: 移除光标前的一个单词</span><br><span class="line"></span><br><span class="line">ctrl+t: 交换光标位置前的两个字符</span><br><span class="line"></span><br><span class="line">ctrl+y: 粘贴或者恢复上次的删除</span><br><span class="line"></span><br><span class="line">ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符</span><br><span class="line"></span><br><span class="line">ctrl+f: 光标右移</span><br><span class="line"></span><br><span class="line">ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</span><br></pre></td></tr></table></figure>

<h3 id="esc组合"><a href="#esc组合" class="headerlink" title="esc组合"></a>esc组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esc+d: 删除光标后的一个词</span><br><span class="line"></span><br><span class="line">esc+f: 往右跳一个词</span><br><span class="line"></span><br><span class="line">esc+b: 往左跳一个词</span><br><span class="line"></span><br><span class="line">esc+t: 交换光标位置前的两个单词</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bash-hotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 定时任务（cron）通过第三方邮件服务器（MTA）发送邮件</title>
    <url>/2020/01/13/corn-mail/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时会需要把一些日志或者任务结果发送到用户邮箱，特此记录一下定时任务和邮箱信息的配置。</p>
<a id="more"></a>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>守护进程 crond定期(每分钟)检查是否有要执行的任务，任务调度分为两类：<strong>系统任务调度</strong>和<strong>用户任务调度</strong>。</p>
<p><strong>系统任务调度</strong>：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。配置文件<code>/etc/crontab</code>。（若要配置定时reboot任务，需配置在此）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name command to be executed</span><br><span class="line">  10 21 *  *  * root reboot</span><br></pre></td></tr></table></figure>


<p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户数据备份、定时邮件提醒、自定义脚本等。配置文件<code>/var/spool/cron/usernamne</code>，用户亦可以用命令crontab定制自己的计划任务。如每隔一分钟给指定邮箱发信息，<code>crontab -u username -e</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAILTO&#x3D;&quot;yourmailaddress@**.com&quot;</span><br><span class="line">*&#x2F;1 * * * *  echo &#39;message&#39;</span><br></pre></td></tr></table></figure>
<p><em>ps</em>：crontab中任何程序产生的输出都会以邮件的形式发送给由MAILTO指定的对象，若未指定则发给任务运行的用户（可于<code>/var/spool/mail/username</code>中查看），此时可通过<code>.forward</code> 或配置<code>/etc/aliases</code> 发送到外部邮箱。</p>
<h3 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h3><p>用系统自带的postfix配置MTA太费事儿，所以采用163邮箱的SMTP服务。</p>
<p>  1.邮箱开启SMTP服务</p>
<p>  登录邮箱，在<code>设置</code>里打开<code>POP3/SMTP/IMAP</code>，勾选<code>POP3/SMTP服务</code>和<code>IMAP/SMTP服务</code>，并设置自己的<code>客户端授权密码</code>。</p>
<p>  2.centos安装mailx(相当于MUA)<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mailx</span><br></pre></td></tr></table></figure><br>  3.centos配置163邮箱信息，在文件 <code>/etc/mail.rc</code>末尾添加如下信息<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set from&#x3D;&quot;*********@163.com&quot;</span><br><span class="line">set smtp&#x3D;smtp.163.com</span><br><span class="line">set smtp-auth-user&#x3D;*********@163.com</span><br><span class="line">set smtp-auth-password&#x3D;客户端授权密码</span><br><span class="line">set smtp-auth&#x3D;login</span><br></pre></td></tr></table></figure></p>
<p>  <em>ps</em>:防火墙配置（vultr要联系客服“开光”25端口）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mail</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔有感</title>
    <url>/2020/01/13/hello-world/</url>
    <content><![CDATA[<p>一个不读书之人的胡思胡想</p>
<a id="more"></a>
<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
