<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Async/await</title>
    <url>/2021/04/14/Async-await/</url>
    <content><![CDATA[<p><a href="https://javascript.info/async-await" target="_blank" rel="noopener">Async&#x2F;await</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>TCP/IP协议族的网络层基础（6）——NAT和NAPT</title>
    <url>/2020/03/27/CP-IP%E4%B9%8BNAT/</url>
    <content><![CDATA[<p>转载：**<a href="https://blog.csdn.net/lvyibin890/article/details/80206979" target="_blank" rel="noopener">TCP&#x2F;IP协议族的网络层基础（6）——NAT和NAPT</a>**。</p>
<a id="more"></a>

<p>NAT技术（Network Address Translation，网络地址转换），是解决IP地址不够用的主要手段，是路由器的一个重要功能。</p>
<ul>
<li><span style="color:red">NAT能够将私有IP对外通信时转为公有IP，也就是一种将私有IP和全局IP相互转化的技术方法</span>。</li>
<li>公有IP要求是唯一的，但私有IP不需要；在不同的局域网中出现相同的私有IP是不受影响的</li>
<li>一般每个终端设置私有IP，而在路由器或必要的服务器上设置公有IP</li>
</ul>
<p>我们再来看看这个图</p>
<p><img src="/images/pasted-41.png" alt="upload successful"></p>
<p><strong>发送请求</strong></p>
<ul>
<li>我们在家里玩吃鸡游戏，就是在申请访问吃鸡的服务器</li>
<li>我们的主机有一个私有IP，打个比方就是192.168.1.201</li>
<li>对于这个主机，有一个给它分配私有IP的家用路由器，这个路由器的IP一般为192.168.1.1，这个是该路由器的对应LAN口IP</li>
<li>该路由器有对应的WAN口IP，此时我们访问吃鸡服务器，之间还有一个运营商提供给我们的路由器，运营商路由器的WAN口一般对应的是公有IP，在广域网中能够被访问到</li>
<li>在访问该路由器的过程中，家用路由器将我们本机的私有IP替换成它的WAN口IP发送给运营商路由器，所以看起来实际是WAN口IP来访问这个路由器</li>
<li>运营商再通过它的WAN口IP 122.77.241.4来通过公网访问吃鸡服务器，所以真正在吃鸡服务器看到是122.74.241.4这个IP在访问它，于是吃鸡服务器把响应返回给这个IP的节点，即返回给运营商路由器</li>
<li><span style="color:red">NAT路由器（以上的路由器都配有NAT技术）内部，有一张自动生成的，用于地址转换的表，注意，这张表不同于路由表（route命令查看的路由表）</span></li>
<li>当家用路由器10.1.1.2第一次向运营商路由器就会生成表中的映射关系</li>
</ul>
<p><strong>返回数据（NAPT）</strong><br>那么运营商服务器怎么知道是IP 为10.1.1.2的家用路由器在访问而不是IP为10.1.1.3的家用路由器在访问呢？<br>这时<span style="color:red">NAPT（Network Address Port Translation，网络地址端口转换）就来解决问题了，使用IP+port来建立这个关联关系</span></p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<ul>
<li>首先这个局域网下的两台客户机10.0.0.10和10.0.0.11都要通过应用程序（该应用程序的端口号是1025）访问同一个服务器上的应用程序，服务器上该应用程序的端口号是80</li>
<li>这两个请求同时到达了给客户机分配IP的NAT路由器（这种自动分配IP的的技术是DHCP），它的LAN口IP是10.0.0.1，WAN口IP是202.224.171.37</li>
<li>在这个路由器内部维护了一张转换表，使用IP+port的形式来解决到底是局域网内部的哪台主机的请求</li>
<li>两者到达NAT路由器的次序总有快慢，假设客户机10.0.0.10先到，那么它的请求中的源IP就被替换成202.224.171.37，它的端口号不变默认是1025（这是NAT技术）</li>
<li>好这个时候客户机10.0.0.11的请求来了，它的请求中的源IP也被替换成202.224.171.37，但是端口号1025已经被上一个客户机给占了啊，所以路由器就往后找一个没有使用过的端口号给该客户机（在上图中就是1026），这样两个请求对应的转换表就形成了</li>
<li>在服务器看来，这就是源IP为202.224.171.37上的两个应用程序来访问的我（分别是1025和1026），那就分别把对应的应答发送给源IP上的1025和1026端口应用程序</li>
<li>路由器接着根据转换表，发送给每个请求对应的客户机。​</li>
<li>这种关联关系也是NAT路由器自动维护的。例如在TCP的情况下，建立连接时，就会生成这个表项；在断开连接时，就会删除这个表项</li>
</ul>
<p><strong>NAT技术缺陷（因为太过于依赖这个转换表）</strong></p>
<ul>
<li>无法从NAT外部向内部服务器进行连接</li>
<li>装换表的生成和销毁都需要开销</li>
<li>通信过程中一旦NAT设备异常，即使存在热备，所有的TCP连接也会断开</li>
</ul>
<p><strong>NAT和代理服务器的区别</strong></p>
<ul>
<li>从应用上讲, NAT设备是网络基础设备之一, 解决的是IP不足的问题. 代理服务器则是更贴近具体应用, 比如通过代理服务器进行翻墙, 另外像迅游这样的加速器, 也是使用代理服务器.</li>
<li>从底层实现上讲, NAT是工作在网络层, 直接对IP地址进行替换. 代理服务器往往工作在应用层</li>
<li>从使用范围上讲, NAT⼀般在局域网的出口部署, 代理服务器可以在局域网做, 也可以在广域网做, 也可以跨网</li>
<li>从部署位置上看, NAT⼀般集成在防火墙, 路由器等硬件设备上, 代理服务器则是⼀个软件程序, 需要部署在服务器上</li>
</ul>
<p><strong>代理服务器的技术</strong></p>
<ul>
<li>翻墙：广域网中的代理</li>
<li>负载均衡：局域网中的代理</li>
</ul>
<p><strong>NAT与桥接模式的区别</strong></p>
<ul>
<li>桥接模式：此模式虚拟机就是局域网一台独立的主机，需要手动配置IP地址、子网掩码，而且还要和本机处于一个网段才行，这样才能够和本机进行通信。同时，配置好网关和DNS的地址之后，以实现通过局域网的网关或路由器访问互联网</li>
<li>NAT模式：此模式虚拟机借助NAT功能，通过本机的网络来访问互联网。NAT模式下的虚拟机的TCP&#x2F;IP配置信息是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手动修改，因此虚拟机就无法和局域网中的其他主机进行通信。</li>
<li>像我的虚拟机就是采用NAT模式网络连接，可以先在Windows下的cmd命令窗口输入窗口输入ipconfig，找到VMnet8选项，可以找到IPv4的地址和子网掩码</li>
</ul>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<p>我们可以在虚拟机中看一下虚拟机的IP地址和子网掩码  </p>
<p><img src="/images/pasted-44.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>tcp/ip</category>
      </categories>
      <tags>
        <tag>nat</tag>
      </tags>
  </entry>
  <entry>
    <title>Form Data &amp; Request Payload</title>
    <url>/2021/11/27/Form-Data-Request-Payload/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>简单来说,request headers里的Content-Type: application&#x2F;json 表明request body里是json数据; Content-Type: application&#x2F;x-www-form-urlencoded表明request body里是Form Data数据(以key1&#x3D;value1&amp;key2&#x3D;value2形式). 根据content-type的不同, 后端也要相应处理,或@RequestParam 处理表单数据, 或@RequestBody处理json数据等.<br><strong><a href="https://segmentfault.com/a/1190000018774494" target="_blank" rel="noopener">前后端联调之Form Data与Request Payload，你真的了解吗？</a></strong> &amp;nbsp;&amp;nbsp;<strong><a href="https://www.cnblogs.com/zoro-zero/p/11608491.html" target="_blank" rel="noopener">SpringBoot 传入JSON对象参数</a></strong></p>
]]></content>
      <tags>
        <tag>application/x-www-form-urlencoded</tag>
        <tag>application/json</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter和Interceptor的比较</title>
    <url>/2021/11/15/Filter%E5%92%8CInterceptor%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/5f5e5211bbdb" target="_blank" rel="noopener">Filter和Interceptor的比较</a>, &amp;nbsp;&amp;nbsp;&amp;nbsp;<a href="https://www.cnblogs.com/hellovoyager1/p/9152292.html" target="_blank" rel="noopener">Listener、Filter 和Interceptor 总结</a>, &amp;nbsp;&amp;nbsp;<a href="https://www.cnblogs.com/hhhshct/p/8808115.html" target="_blank" rel="noopener">springboot配置监听器、过滤器和拦截器</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>interceptor</tag>
        <tag>filter</tag>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC的实现原理—反射与工厂模式(转载)</title>
    <url>/2020/03/03/C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%80%94%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="反射与工厂模式实现IOC"><a href="#反射与工厂模式实现IOC" class="headerlink" title="反射与工厂模式实现IOC"></a>反射与工厂模式实现IOC</h3><p>   &amp;emsp;Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：<br>   <a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125; </span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">     public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Orange&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造工厂类</span><br><span class="line">&#x2F;&#x2F;也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了</span><br><span class="line">class Factory&#123;</span><br><span class="line">     public static fruit getInstance(String fruitName)&#123;</span><br><span class="line">         fruit f&#x3D;null;</span><br><span class="line">         if(&quot;Apple&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Apple();</span><br><span class="line">         &#125;</span><br><span class="line">         if(&quot;Orange&quot;.equals(fruitName))&#123;</span><br><span class="line">             f&#x3D;new Orange();</span><br><span class="line">         &#125;</span><br><span class="line">         return f;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">     public static void main(String[] a)&#123;</span><br><span class="line">         fruit f&#x3D;Factory.getInstance(&quot;Orange&quot;);</span><br><span class="line">         f.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   &amp;emsp;上面写法的缺点是当我们再添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改动就会很多。下面用反射机制实现工厂模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">     public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">         System.out.println(&quot;Apple&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a)&#123;</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(&quot;Reflect.Apple&quot;);</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  &amp;emsp;现在就算我们添加任意多个子类的时候，工厂类都不需要修改。使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。</p>
<p>   &amp;emsp;下面编写使用反射机制并结合属性文件的工厂模式（即IoC）。首先创建一个fruit.properties的资源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apple&#x3D;Reflect.Apple</span><br><span class="line">orange&#x3D;Reflect.Orange</span><br></pre></td></tr></table></figure>
<p>   &amp;emsp;然后编写主类代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface fruit&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements fruit&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;操作属性文件类</span><br><span class="line">class init&#123;</span><br><span class="line">    public static Properties getPro() throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;new Properties();</span><br><span class="line">        File f&#x3D;new File(&quot;fruit.properties&quot;);</span><br><span class="line">        if(f.exists())&#123;</span><br><span class="line">            pro.load(new FileInputStream(f));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pro.setProperty(&quot;apple&quot;, &quot;Reflect.Apple&quot;);</span><br><span class="line">            pro.setProperty(&quot;orange&quot;, &quot;Reflect.Orange&quot;);</span><br><span class="line">            pro.store(new FileOutputStream(f), &quot;FRUIT CLASS&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static fruit getInstance(String ClassName)&#123;</span><br><span class="line">        fruit f&#x3D;null;</span><br><span class="line">        try&#123;</span><br><span class="line">            f&#x3D;(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class hello&#123;</span><br><span class="line">    public static void main(String[] a) throws FileNotFoundException, IOException&#123;</span><br><span class="line">        Properties pro&#x3D;init.getPro();</span><br><span class="line">        fruit f&#x3D;Factory.getInstance(pro.getProperty(&quot;apple&quot;));</span><br><span class="line">        if(f!&#x3D;null)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;运行结果：Apple</p>
<h3 id="IOC容器的技术剖析"><a href="#IOC容器的技术剖析" class="headerlink" title="IOC容器的技术剖析"></a>IOC容器的技术剖析</h3><p> &amp;emsp;IOC中最基本的技术就是“反射(Reflection)”编程，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要生产的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。</p>
<p> &amp;emsp;目前C#、Java和PHP5等语言均支持反射，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚。反射的应用是很广泛的，很多的成熟的框架，比如像Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.NET框架都是把”反射“做为最基本的技术手段。</p>
<p>&amp;emsp;反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。</p>
<p>&amp;emsp;我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h3 id="使用IOC框架应该注意什么"><a href="#使用IOC框架应该注意什么" class="headerlink" title="使用IOC框架应该注意什么"></a>使用IOC框架应该注意什么</h3><p>&amp;emsp;使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<p>&amp;emsp;1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p>
<p>&amp;emsp;2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p>&amp;emsp;3）具体到IOC框架产品（比如Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p>
<p>&amp;emsp;4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</p>
<p>&amp;emsp;我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。<br>————————————————<br>版权声明：本文为CSDN博主「fuzhongmin05」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/fuzhongmin05/article/details/61614873" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>H5页面在微信浏览器中通过网页授权获取用户信息(openid、昵称、头像等)</title>
    <url>/2021/08/11/H5%E9%A1%B5%E9%9D%A2%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84openid/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>需要做一个Vue前端项目，UI选择buefy（一个基于Bulma的vue轻量级组件），其中一个H5页面涉及到，如果是在微信浏览器中，需要在后台服务器自动注册以及登录，即需要通过网页授权来获取用户信息（openid、昵称、头像等)。这儿只涉及前端的工作…</p>
<a id="more"></a>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>公众号准备：生产环境的微信公众号，需要按照官方文档（**<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" target="_blank" rel="noopener">微信网页开发授权</a><strong>）设置。开发环境可以前往</strong><a href="https://link.segmentfault.com/?url=https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">微信公众平台</a>**申请测试号。</p>
<p>注意：正式的公众号不需要关注，也可以通过网页授权获取用户信息，而测试号必须要关注！</p>
<h3 id="微信授权流程"><a href="#微信授权流程" class="headerlink" title="微信授权流程"></a>微信授权流程</h3><p>详细流程见官方文档（**<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" target="_blank" rel="noopener">微信网页开发授权</a>**）。</p>
<p>具体而言，网页授权流程分为四步：</p>
<ol>
<li><p>引导用户进入授权页面同意授权，获取code</p>
</li>
<li><p>通过code换取网页授权access_token（与基础支持中的access_token不同）</p>
</li>
<li><p>如果需要，开发者可以刷新网页授权access_token，避免过期</p>
</li>
<li><p>通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p>
</li>
</ol>
<p>时序图如下：</p>
<p><img src="/images/pasted-47.png" alt="upload successful"></p>
<h3 id="授权code的获取"><a href="#授权code的获取" class="headerlink" title="授权code的获取"></a>授权code的获取</h3><p>以上是大概流程，这里主要分析用户统一授权后，获取code的两个路径：前端截取及后端获取。</p>
<p>原理是：获取用户授权需要按照微信规定拼装链接，让用户点击访问，其中拼接的链接中有个redirect_uri参数(授权后重定向的回调链接地址)，微信服务器处理后会将redirect_uri拼接code等参数，浏览器会重定向该地址，也就形成了两个获取code的方法，前端在url截取code,后端也可以通过浏览器访问此链接获取code参数。</p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const appid &#x3D; &quot;wx3b0e58d4d2dbea9q&quot;;  &#x2F;&#x2F;公众号后台获取</span><br><span class="line">const redirectUri &#x3D; encodeURIComponent(&quot;http:&#x2F;&#x2F;245691q6b5.zicp.vip&quot;)&#x2F;&#x2F;微信会带code码访问这个链接</span><br><span class="line">const url &#x3D; &#96;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorizeappid&#x3D;$&#123;appid&#125;&amp;redirect_uri&#x3D;$&#123;redirectUri&#125;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;STATE#wechat_redirect&#96;</span><br></pre></td></tr></table></figure>
<h4 id="前端获取"><a href="#前端获取" class="headerlink" title="前端获取"></a>前端获取</h4><p>如果不是每次进入页面都要从微信获取code码时（用户信息），建议在前端获取，需要时才改变浏览器链接让用户访问链接获取授权，把code码传给后端获取用户信息。</p>
<p>也可以参看此代码：**<a href="https://www.cnblogs.com/congfeicong/p/11125575.html" target="_blank" rel="noopener">H5页面获取微信公众号的openid</a>**，或者如下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const appid &#x3D; &quot;wx3b0e58d4d2dbea9q&quot;;  &#x2F;&#x2F;公众号后台获取</span><br><span class="line">const redirectUri &#x3D; encodeURIComponent(&quot;http:&#x2F;&#x2F;245691q6b5.zicp.vip&quot;)&#x2F;&#x2F;微信会带code码访问这个链接</span><br><span class="line"></span><br><span class="line">const url&#x3D;&#96;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorizeappid&#x3D;$&#123;appid&#125;&amp;redirect_uri&#x3D;$&#123;redirectUri&#125;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;STATE#wechat_redirect&#96;</span><br><span class="line"></span><br><span class="line">const querystring &#x3D; getQueryString()</span><br><span class="line">let code &#x3D; querystring.code;</span><br><span class="line"></span><br><span class="line">if(!code)&#123;</span><br><span class="line">    location.href &#x3D; url;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    https.get(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;auth&#39;,&#123;code&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getQueryString() &#123;</span><br><span class="line">    const url &#x3D; location.search;</span><br><span class="line">    const rs &#x3D; &#123;&#125;</span><br><span class="line">    if(url.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        const querystring &#x3D; url.substr(1);</span><br><span class="line">        const kvArr &#x3D; querystring.split(&#39;&amp;&#39;);</span><br><span class="line">        kvArr.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">            const temp &#x3D; item.split(&#39;&#x3D;&#39;)</span><br><span class="line">            const key &#x3D; temp[0];</span><br><span class="line">            const val &#x3D; temp[1];</span><br><span class="line">            rs[key] &#x3D; val</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后端获取"><a href="#后端获取" class="headerlink" title="后端获取"></a>后端获取</h4><p>如果每次都要获取code码，就让用户只要进入页面就访问接口链接，但这时的redirectUri要配置成后端接口的链接，也就是说微信会带着code码访问后端接口，后端直接获取code码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;后端使用koa2</span><br><span class="line">&#x2F;&#x2F;Superagent时一个后端的http请求中间件</span><br><span class="line">router.get(&#39;&#x2F;auth&#39;, async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">    code &#x3D; ctx.querystring.split(&#39;&amp;&#39;)[0].split(&#39;&#x3D;&#39;)[1];</span><br><span class="line">    &#x2F;&#x2F; 使用code获取openid和access_token </span><br><span class="line">    await Superagent</span><br><span class="line">        .get(&#96;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;$&#123;appid&#125;&amp;secret&#x3D;$&#123;appsecret&#125;&amp;code&#x3D;$&#123;code&#125;&amp;grant_type&#x3D;authorization_code&#96;)</span><br><span class="line">        .then(res &#x3D;&gt; &#123;</span><br><span class="line">            let result &#x3D; JSON.parse(res.text)</span><br><span class="line">            access_token &#x3D; result.access_token</span><br><span class="line">            openid &#x3D; result.openid</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用ACCESS_TOKEN和openid获取userinfo</span><br><span class="line">    await Superagent</span><br><span class="line">        .get(&#96;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;$&#123;access_token&#125;&amp;openid&#x3D;$&#123;openid&#125;&amp;lang&#x3D;zh_CN&#96;)</span><br><span class="line">        .then(res &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;userinfo返回给前端</span><br><span class="line">            userinfo &#x3D; JSON.parse(res.text)</span><br><span class="line">            ctx.body &#x3D; res.text</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashtable、HashMap、ConcurrentHashMap</title>
    <url>/2021/12/01/Hashtable%E3%80%81HashMap%E3%80%81ConcurrentHashMap/</url>
    <content><![CDATA[<p><strong><a href="https://blog.csdn.net/Mr_YanMingXin/article/details/118601591" target="_blank" rel="noopener">详解Java中HashMap、HashTable、ConcurrentHashMap常见问题</a></strong> &amp;nbsp;;&amp;nbsp;<strong><a href="https://blog.csdn.net/amunamuna/article/details/107773902" target="_blank" rel="noopener">Hashtable、HashMap、ConcurrentHashMap等及常用阻塞队列</a></strong> &amp;nbsp;&amp;nbsp;</p>
]]></content>
  </entry>
  <entry>
    <title>IntelliJ IDEA激活</title>
    <url>/2021/03/20/IntelliJ-IDEA%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>可用方法：<a href="https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3" target="_blank" rel="noopener">IntelliJ IDEA 2020.3.3激活破解教程（亲测激活至 2099 年，长期更新）</a>，或者一直白嫖试用30天（<em>rm -rf ～&#x2F;.config&#x2F;Jetbrains&#x2F;IntelliJIdea2020.3&#x2F;eval&#x2F;</em> 可重置30天）。</p>
]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型详解：&lt;T&gt;和Class&lt;T&gt;的使用。泛型类，泛型方法的详细使用实例 </title>
    <url>/2021/12/17/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A-T-%E5%92%8CClass-T-%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82%E6%B3%9B%E5%9E%8B%E7%B1%BB%EF%BC%8C%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/jpfss/p/9928747.html" target="_blank" rel="noopener">Java泛型详解：<T>和Class<T>的使用。泛型类，泛型方法的详细使用实例 </T></T></a></p>
]]></content>
  </entry>
  <entry>
    <title>ProcessExecutor、ProcessBuilder、Runtime.getRuntime().exec(...) </title>
    <url>/2021/05/02/ProcessExecutor%E3%80%81ProcessBuilder%E3%80%81Runtime-getRuntime-exec/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>There are many approaches to take when running external processes from Java. There are the JRE options such as the Runtime.exec() 、 ProcessBuilder、  Apache Commons Exec and ZT Process Executor. 其中ZT Process Executor是一个更为强大的进程库（process library），能够通过使用一个单一的 ProcessExecutor 类来调用 java.lang.ProcessBuilder 和 Apache Commons Exec 中的接口。</p>
<a id="more"></a>
<h3 id="Runtime-amp-ProcessBuilder"><a href="#Runtime-amp-ProcessBuilder" class="headerlink" title="Runtime&amp;ProcessBuilder"></a>Runtime&amp;ProcessBuilder</h3><p>*Runtime.getInstance().exec (String cmd)<em>和</em>new ProcessBuilder(String cmd).start()*都可以产生子进程对象Process。通过调用Process对象的waitFor()方法可以使主进程进入等待状态，直至子进程执行完毕，再进行下一步工作。如果对子进程处理不当，有可能造成主进程阻塞，整个程序死掉。(A program is executed with command(). With waitFor() we can wait for the process to finish.)<br><strong>通过查看JDK源码可知，Runtime.exec最终是通过调用ProcessBuilder来真正执行操作的</strong>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Process exec(String command) throws IOException &#123;</span><br><span class="line">    return exec(command, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Process exec(String command, String[] envp, File dir)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    if (command.length() &#x3D;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Empty command&quot;);</span><br><span class="line"></span><br><span class="line">    StringTokenizer st &#x3D; new StringTokenizer(command);</span><br><span class="line">    String[] cmdarray &#x3D; new String[st.countTokens()];</span><br><span class="line">    for (int i &#x3D; 0; st.hasMoreTokens(); i++)</span><br><span class="line">        cmdarray[i] &#x3D; st.nextToken();</span><br><span class="line">    return exec(cmdarray, envp, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Process exec(String[] cmdarray, String[] envp, File dir)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    return new ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProcessExecutor-amp-ProcessBuilder"><a href="#ProcessExecutor-amp-ProcessBuilder" class="headerlink" title="ProcessExecutor&amp;ProcessBuilder"></a>ProcessExecutor&amp;ProcessBuilder</h3><p>ProcessExecutor is implemented as a wrapper of <em>ProcessBuilder</em> complementing it with additional features.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProcessExecutor &#123;</span><br><span class="line"></span><br><span class="line">  private static final Logger log &#x3D; LoggerFactory.getLogger(ProcessExecutor.class);</span><br><span class="line"></span><br><span class="line">  private static final boolean IS_OS_WINDOWS &#x3D; System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);</span><br><span class="line"></span><br><span class="line">  public static final Integer[] DEFAULT_EXIT_VALUES &#x3D; null;</span><br><span class="line"></span><br><span class="line">  private static final Integer NORMAL_EXIT_VALUE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static final boolean DEFAULT_REDIRECT_ERROR_STREAM &#x3D; true;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Process builder used by this executor.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private final ProcessBuilder builder &#x3D; new ProcessBuilder();</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Environment variables which are added (removed in case of &lt;code&gt;null&lt;&#x2F;code&gt; values) to the process being started.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private final Map&lt;String, String&gt; environment &#x3D; new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Set of accepted exit codes or &lt;code&gt;null&lt;&#x2F;code&gt; if all exit codes are allowed.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private Set&lt;Integer&gt; allowedExitValues;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>ProcessExecutor在后台运行进程（不阻塞当前代码对执行）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void runInBackground() throws IOException, InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    List&lt;Future&lt;ProcessResult&gt;&gt; tasks &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        Future&lt;ProcessResult&gt; future &#x3D; new ProcessExecutor().command(&quot;java&quot;, &quot;-version&quot;)</span><br><span class="line">                .start().getFuture();</span><br><span class="line">        tasks.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Future&lt;ProcessResult&gt; future : tasks) &#123;</span><br><span class="line">        ProcessResult processResult &#x3D; future.get(1, TimeUnit.SECONDS);</span><br><span class="line">        int exitValue &#x3D; processResult.getExitValue();</span><br><span class="line">        log.info(&quot;The exit value of the finished process is &#123;&#125;&quot;, exitValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：**<a href="https://github.com/zeroturnaround/zt-exec" target="_blank" rel="noopener">GitHub: ZT Process Executor</a>**</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Rust copy 、move、clone</title>
    <url>/2022/03/17/Rust-copy%E4%B8%8Emove%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch6/02_move_copy.html" target="_blank" rel="noopener">Rust Copy语义</a></p>
<a id="more"></a>

<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>比如下面的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">let s2 &#x3D; s1;</span><br></pre></td></tr></table></figure>
<p>上面已经分析过，值的所有权会从变量s1转移到变量s2，所有权的转移，涉及到的过程是拷贝到目标变量，同时重置原变量到未初始状态，整个过程就像是进行了一次数据的移动。但注意，上面示例中拷贝的是栈中的胖指针，而不是拷贝堆中的实际数据，因此这样的拷贝效率是相对较高的。</p>
<p>所有权转移之后，将只有新的所有者才会指向堆中的实际数据，而原变量将不再指向堆中实际数据，因此所有权转移之后仍然只有一个指针指向堆中数据。</p>
<p>Move不仅发生在变量赋值过程中，在函数传参、函数返回数据时也会Move，因此，如果将一个大对象(例如包含很多数据的数组，包含很多字段的struct)作为参数传递给函数，是否会让效率很低下？</p>
<p>按照上面的结论来说，确实如此。但Rust编译器会对Move语义的行为做出一些优化，简单来说，当数据量较大且不会引起程序正确性问题时，它会传递大对象的指针而非内存拷贝。</p>
<p>此外，对于胖指针类型的变量(如Vec、String)，即使发生了拷贝，其性能也不差，因为拷贝的只是它的胖指针部分。</p>
<p>总之，Move虽然发生了内存拷贝，但它的性能并不会太受影响。</p>
<p>此处部分结论参考：<em><a href="https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust" target="_blank" rel="noopener">https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust</a></em>。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>默认情况下，在将一个值保存到某个位置时总是进行值的移动(实际上是拷贝  如String 拷贝的值是指针)，使得只有目标位置才拥有这个值，而原始变量将变回未初始化状态，也就是暂时不可用的状态。这是Rust的移动语义</strong>。</p>
<p>Rust还有Copy语义，和Move语义几乎相同，唯一的区别是Copy后，原始变量仍然可用。</p>
<p>前面说过，Move实际上是进行了拷贝，只不过拷贝后让原始变量变回未初始化状态了，而Copy的行为，就是保留原始变量。</p>
<p>但Rust默认是使用Move语义，如果想要使用Copy语义，要求要拷贝的数据类型实现了Copy Trait。</p>
<p>例如，i32默认就已经实现了Copy Trait，因此它在进行所有权转移的时候，会自动使用Copy语义，而不是Move语义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 3;   &#x2F;&#x2F; 3是原始数据类型，它直接存储在栈中，所以x变量的值是3，x拥有3</span><br><span class="line">let n &#x3D; x;   &#x2F;&#x2F; Copy x的值(即3)到变量n，n现在拥有一个3，但x仍然拥有自己的3</span><br></pre></td></tr></table></figure>
<p>Rust中默认实现了Copy Trait的类型，包括但不限于：</p>
<ul>
<li>所有整数类型，比如u32</li>
<li>所有浮点数类型，比如f64</li>
<li>布尔类型，bool，它的值是true和false</li>
<li>字符类型，char</li>
<li>元组，当且仅当其包含的类型也都是Copy的时候。比如(i32, i32)是Copy的，但(i32, String)不是</li>
<li>共享指针类型或共享引用类型</li>
</ul>
<p>对于那些没有实现Copy的自定义类型，可以手动去实现Copy(要求同时实现Clone)，方式很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[derive(Copy, Clone)]</span><br><span class="line">struct Abc(i32, i32);</span><br></pre></td></tr></table></figure>
<p>下面是实现了Copy和未实现Copy时的一个对比示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Xyz(i32, i32);</span><br><span class="line"></span><br><span class="line">#[derive(Copy, Clone, Debug)]</span><br><span class="line">struct Def(i32, i32);</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let x &#x3D; Xyz(11, 22);</span><br><span class="line">  let y &#x3D; x;</span><br><span class="line">  &#x2F;&#x2F; println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F; 报错</span><br><span class="line">  println!(&quot;y: &#123;:?&#125;&quot;, y);</span><br><span class="line"></span><br><span class="line">  let d &#x3D; Def(33, 44);</span><br><span class="line">  let e &#x3D; d;</span><br><span class="line">  println!(&quot;d: &#123;:?&#125;&quot;, d);</span><br><span class="line">  println!(&quot;e: &#123;:?&#125;&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-51.png" alt="upload successful"></p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>虽然实现Copy Trait可以让原变量继续拥有自己的值，但在某些需求下，不便甚至不能去实现Copy。这时如果想要继续使用原变量，可以使用clone()方法手动拷贝变量的数据，同时不会让原始变量变回未初始化状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">  let s1 &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">  &#x2F;&#x2F; 克隆s1，克隆之后，变量s1仍然绑定原始数据</span><br><span class="line">  let s2 &#x3D; s1.clone();</span><br><span class="line">  println!(&quot;&#123;&#125;,&#123;&#125;&quot;, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但不是所有数据类型都可以进行克隆，只有那些实现了Clone Trait的类型才可以进行克隆(Trait类似于面向对象语言中的接口，如果不了解可先不管Trait是什么)，常见的数据类型都已经实现了Clone，因此它们可以直接使用clone()来克隆。</p>
<p>对于那些没有实现Clone Trait的自定义类型，需要手动实现Clone Trait。在自定义类型之前加上#[derive(Copy, Clone)]即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[derive(Copy, Clone)]</span><br><span class="line">struct Abc(i32, i32);</span><br></pre></td></tr></table></figure>
<p>这样Abc类型的值就可以使用clone()方法进行克隆。</p>
<p>要注意Copy和Clone时的区别，如果不考虑自己实现Copy trait和Clone trait，而是使用它们的默认实现，那么：</p>
<p>Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据<br>Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据<br>也就是说，Copy是浅拷贝，Clone是深拷贝，Rust会对每个字段每个元素递归调用clone()，直到最底部。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let vb0 &#x3D; vec![&quot;s1&quot;.to_string()];</span><br><span class="line">  let v &#x3D; vec![vb0];</span><br><span class="line">  println!(&quot;&#123;:p&#125;&quot;, &amp;v[0][0]);     &#x2F;&#x2F; 0x21c43a20c50</span><br><span class="line"></span><br><span class="line">  let vc &#x3D; v.clone();</span><br><span class="line">  println!(&quot;&#123;:p&#125;&quot;, &amp;vc[0][0]);  &#x2F;&#x2F; 0x21c43a20b70</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，使用Clone的默认实现时，clone()操作的性能是较低的。但可以自己实现自己的克隆逻辑，也不一定总是会效率低。比如Rc，它的clone用于增加引用计数，同时只拷贝少量数据，它的clone效率并不低。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>move</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>@PostConstruct注解原理解析</title>
    <url>/2021/11/16/PostConstruct%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/lay2017/p/11735802.html" target="_blank" rel="noopener">@PostConstruct注解原理解析</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>PostConstruct</tag>
      </tags>
  </entry>
  <entry>
    <title>Let’sEncrypt 证书自动更新脚本</title>
    <url>/2021/04/08/Let%E2%80%99sEncrypt-%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vps科学上网用的Let’sEncrypt免费证书，有效期一般是3个月，需要定期更新。写个脚本，定时更新。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Version:1.0</span><br><span class="line">#Author:zzl</span><br><span class="line">#Automatically renew Let&#39;s Encrypt certificates</span><br><span class="line">#A cron job will run this shell script everyday</span><br><span class="line">i&#x3D;0</span><br><span class="line">while [[ $i -lt 10]]</span><br><span class="line">do</span><br><span class="line">  let &quot;i++&quot;</span><br><span class="line">  if [ $(ps -C nginx --no-header | wc -l) -ne 0];then</span><br><span class="line">    service nginx stop</span><br><span class="line">    sleep 3s</span><br><span class="line">    if [ $(ps -C nginx --no-header | wc -l) -eq 0];then</span><br><span class="line">      break</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">certbot renew </span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure>
<p>或者直接用certbot renew command，详情如下<br>        <strong><a href="https://certbot.eff.org/docs/using.html?highlight=hooks#renewing-certificates" target="_blank" rel="noopener">Certbot documentation on renewing certificates</a></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certbot renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2022/04/01/Nacos/</url>
    <content><![CDATA[<p>Nacos(Dynamic Naming and Configuration Service)，Na为naming&#x2F;nameServer即注册中心,co为configuration即配置中心，service是指该注册&#x2F;配置中心都是以服务为核心。操作起来比eureka简单且功能强大。<br><strong><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">Nacos Spring Cloud 快速开始</a><strong>、</strong><a href="https://www.jianshu.com/p/39ade28c150d" target="_blank" rel="noopener">什么是Nacos？Nacos注册配置中心介绍</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>Rust引用</title>
    <url>/2022/03/17/Rust%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch3/07_reference_type.html" target="_blank" rel="noopener">Rust中的引用</a></p>
<a id="more"></a>

<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>Rust绝大多数时候不会自动地解除引用。但在某些环境下，Rust会自动进行解引用。</p>
<p>自动解引用的情况有(结论先总结在此，混脸熟，以后涉及到时再来)：</p>
<ol>
<li><p>使用.操作符时(包括取属性值和方法调用)，会隐式地尽可能解除或创建多层引用</p>
</li>
<li><p>使用比较操作符时，若比较的两边是相同类型的引用，则会自动解除引用到它们的值然后比较<br>对于(1)，Rust会自动分析func()的参数，并在需要的时候自动创建或自动解除引用。例如以abc.func()有可能会自动转换为&amp;abc.func()，反之，&amp;abc.func()也有可能会自动转换为abc.func()。</p>
</li>
</ol>
<p>对于(2)，例如有引用类型的变量n，那么n &gt; &amp;30和*n &gt; 30的效果是一样的。</p>
<p>————————————————《rust入门秘籍》</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>references</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本检测Nginx服务状态</title>
    <url>/1970/01/01/Shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8BNginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    service nginx start</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="脚本解析"><a href="#脚本解析" class="headerlink" title="脚本解析"></a>脚本解析</h3><p>以上是通过进程判断，也可以通过端口判断，如netstat -nlpt | grep nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# netstat -nlpt | grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8801&#x2F;nginx: master</span><br></pre></td></tr></table></figure>

<p>以下，以进程为例详解，ps -C nginx –no-header<br>这里涉及ps 的用法，我们一般用ps查看相关进程，一般都是用ps -ef | grep XX 或 ps -aux| grep XX 的模式<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br><span class="line">root     11660  5532  0 09:55 pts&#x2F;1    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>
<p>但是这样通常都会覆盖一个grep的进程。</p>
<p>我们可以用ps -ef|grep nginx|grep -v grep的方式排除grep的进程，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# ps -ef|grep nginx|grep -v grep</span><br><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>

<p>也可以直接用ps -C 或ps -c 的方式， -C 后面接命令的名字（推荐） ，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  8801 ?        00:00:00 nginx</span><br><span class="line">  8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>–no-header 就是去挑title,如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx --no-header</span><br><span class="line"> 8801 ?        00:00:00 nginx</span><br><span class="line"> 8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>wc -l 这个很熟悉了，行数计算</p>
<p>所以用这种方式可判断，如果<br>ps -C nginx –no-header|wc -l</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">值为0，即代表服务未启动</span><br><span class="line">值为非0，即代表服务已启动</span><br></pre></td></tr></table></figure>
<p>最后，killall keepalived 这个是以服务名称杀死进程，日常中也用的挺多的</p>
<p>上面那段完整的脚本意思即为：<br>判断nginx 服务是否启动<br>如果未启动，执行启动命令<br>再次判断，如果启动失败，关掉keepalived，进入从节点</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring设计思想-事务篇》2.数据库隔离级别</title>
    <url>/2020/03/12/Spring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E4%BA%8B%E5%8A%A1%E7%AF%87%E3%80%8B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>转载：**<a href="https://blog.csdn.net/luanlouis/article/details/95319795" target="_blank" rel="noopener">《Spring设计思想-事务篇》2.数据库隔离级别
</a><strong>，</strong><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">深入分析事务的隔离级别</a><strong>，</strong><a href="https://www.hollischuang.com/archives/923" target="_blank" rel="noopener">MySQL中的共享锁与排他锁</a>**</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对上述的四种事务隔离级别的阐述中，我们使用了从资源互斥访问的角度做了解释。资源互斥粒度控制的越细，客户端事务的并发能力就越高，但是与此同时，会相应地降低数据的一致性。</p>
<a id="more"></a>

<p>事务的并发数和数据数据一致性这两个是两个相反的理想指标。而数据库研发的方向就是尽可能提高同时提高两个指标，尽可能减少之间的反作用影响。</p>
<p>SERIALIZABLE 序列化读，隔离级别最高，客户端以互斥的方式访问数据库资源，统一时间内，同一个资源只能被一个客户端访问，好像客户端在排队请求访问，所以称为序列化读。<br>REPEATABLE_READ 可重复读，可重复读能够保证，一个客户端在一个事务内，多次访问同一个资源时，返回结果是一样的，顾名思义，称为可重复读，这种隔离级别可能会造成幻读现象。<br>READ_COMMITTED 读已提交，即客户端在一个事务内，每次查询读取的数据都是从数据库读取最新的已提交的数据；这种隔离界别可能会造成不可重复读和幻读现象。<br>READ_UNCOMMITTED 读未提交，即客户端在一个事务内，可以读取到其他客户端事务的尚未提交的数据；这种隔离级别可能会造成脏读、不可重复读、幻读 现象。</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
]]></content>
  </entry>
  <entry>
    <title> ThreadLocal 详解</title>
    <url>/2021/11/13/ThreadLocal-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html" target="_blank" rel="noopener">ThreadLocal原理</a>  ,&amp;nbsp;&amp;nbsp;&amp;nbsp; <a href="https://juejin.cn/post/6844903487193481224" target="_blank" rel="noopener">Java 之 ThreadLocal 详解: 内存泄漏</a></p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu 18.04 用户登录界面优化</title>
    <url>/1970/01/01/Ubuntu-18-04-%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>**<a href="https://blog.csdn.net/vselfdom/article/details/88546349" target="_blank" rel="noopener">Ubuntu 18.04 用户登录界面优化</a>**，备用。</p>
]]></content>
  </entry>
  <entry>
    <title>SkipList (跳跃表)的那点事儿</title>
    <url>/2021/02/23/SkipList-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/fNBjlpzqvNkmei0cHhNcog?article_exclude_marked=ea8284506ea5ccac099671313574ba5c" target="_blank" rel="noopener">SkipList 的那点事儿</a></p>
]]></content>
      <tags>
        <tag>SkipList</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04下通过zssh与服务器进行上传/下载文件操作</title>
    <url>/2021/11/29/Ubuntu18-04%E4%B8%8B%E9%80%9A%E8%BF%87zssh%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>把本地文件上传到远程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）打开远程终端，输入：rz -bye (打个招呼，表示要接受文件)</span><br><span class="line"> (2) ctrl+@,  （切换到本地，进入要上传的文件的目录）</span><br><span class="line">（3）sz filename （发送文件）</span><br></pre></td></tr></table></figure>
<p>下载文件的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）sz filename （打个招呼，表示要发送的文件）</span><br><span class="line"> (2) ctrl+@,（切换到本地，进入要接收该远程文件的路径下）</span><br><span class="line">（3）rz -ay   （接收完毕了哇）</span><br></pre></td></tr></table></figure>
<p><a href="https://www.it610.com/article/1280947627608784896.htm" target="_blank" rel="noopener">Ubuntu18.04下通过zssh与服务器进行上传&#x2F;下载文件操作</a></p>
]]></content>
      <tags>
        <tag>zssh</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu apt-get autoclean,clean,autoremove</title>
    <url>/2021/04/29/Ubuntu-apt-get-autoclean-clean-autoremove/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ubuntu移除安装包时用到的几个命令：autoclean,clean,autoremove</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get autoclean:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你的硬盘空间不大的话，可以定期运行这个程序，将已经删除了的软件包的.deb安装文件从硬盘中删<br>除掉。如果你仍然需要硬盘空间的话，可以试试apt-get clean，这会把你已安装的软件包的安装包也删除掉，当然多数情况下这些包没什么用了，因此这是个为硬盘腾地方的好办法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get clean:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似上面的命令，但它删除包缓存中的所有包。这是个很好的做法，因为多数情况下这些包没有用了。但如果你是拨号上网的话，就得重新考虑了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get autoremove:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包。</p>
</blockquote>
<p>其它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get remove 软件包名称：</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除已安装的软件包（保留配置文件）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get --purge remove 软件包名称：</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除已安装包（不保留配置文件)。</p>
</blockquote>
<p>This completely depends on what you want to achieve, they are separate for a reason. But lets see what they actually do:</p>
<blockquote>
<p>apt&#x2F;apt-get clean → cleans the packages and install script in &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;<br>apt&#x2F;apt-get autoclean → cleans obsolete deb-packages, less than clean<br>apt&#x2F;apt-get autoremove → removes orphaned packages which are not longer needed from the system, but not purges them, use the –purge option together with the command for that.  </p>
</blockquote>
<p>So it is up to you to decide if you want to combine one of the first two with the last one and you can do this like below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt autoremove &amp;&amp; sudo apt clean</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>apt-get</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark抓包原理（ARP劫持、MAC泛洪）及数据流追踪和图像抓取</title>
    <url>/2021/05/31/Wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86%EF%BC%88ARP%E5%8A%AB%E6%8C%81%E3%80%81MAC%E6%B3%9B%E6%B4%AA%EF%BC%89%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BF%BD%E8%B8%AA%E5%92%8C%E5%9B%BE%E5%83%8F%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<p>转载：<a href="https://cloud.tencent.com/developer/article/1626729" target="_blank" rel="noopener">Wireshark抓包原理（ARP劫持、MAC泛洪）及数据流追踪和图像抓取</a></p>
]]></content>
  </entry>
  <entry>
    <title>Using the Switch(true) Pattern in JavaScript</title>
    <url>/2021/04/13/Using-the-Switch-true-Pattern-in-JavaScript-https-seanbarry-dev-posts-switch-true-pattern/</url>
    <content><![CDATA[<p><a href="https://seanbarry.dev/posts/switch-true-pattern" target="_blank" rel="noopener">Using the Switch(true) Pattern in JavaScript</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Using the Switch(true) Pattern in JavaScript</title>
    <url>/1970/01/01/Using-the-Switch-true-Pattern-in-JavaScript/</url>
    <content><![CDATA[<p><a href="https://seanbarry.dev/posts/switch-true-pattern" target="_blank" rel="noopener">Using the Switch(true) Pattern in JavaScript</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>android studio http proxy for sdk </title>
    <url>/2020/02/02/andorid-studio-proxy-setting/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>闲来无事，研究一下安卓的开发，并记录一下开发工具android studio的配置，主要是安装时要下载android sdk，又因长城的原因，需要设置国内镜像，或者如果你能科学上网的话，设置http proxy也可。</p>
<a id="more"></a>

<h3 id="镜像设置"><a href="#镜像设置" class="headerlink" title="镜像设置"></a>镜像设置</h3><p>这里用的是电子科技大学的镜像网站：mirrors.dormforce.net 端口：80<br>通过File–&gt;Setting–&gt;Appearance &amp; Behavior –&gt;System Settings –&gt;Http Proxy，选择Auto-detect proxy settings，并且填写URL为：mirrors.dormforce.net :80，点击clear passwords<br><img src="/images/pasted-0.png" alt="upload successful"></p>
<h3 id="Http-proxy设置"><a href="#Http-proxy设置" class="headerlink" title="Http proxy设置"></a>Http proxy设置</h3><p>这个适合可以科学上网的同学，我用的是trojan,配置如下：<br>Manual proxy configuration–&gt;SOCKS–&gt;Host name:127.0.0.1 Port number:1080<br>完成后点击Check connection，输入网址*<a href="https://www.android.com/*%EF%BC%8C%E6%B5%8B%E8%AF%95%E8%BF%9E%E6%8E%A5%E3%80%82" target="_blank" rel="noopener">https://www.android.com/*，测试连接。</a></p>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p>通过上述两种之一的方式设置后，点击Android SDK,点击SDK Update Sites，下面勾选<em>『Force https:&#x2F;&#x2F;… sources to be fetched using http:&#x2F;&#x2F;…』</em>，点击Apply，完成后返回主页面即可。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio 真机调试</title>
    <url>/2020/02/10/android-run-on-a-real-device/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android studio调试的时候可以运行在模拟器，也可以在真机上运行，本文记录一下真机（MIUI10）调试的前期准备。</p>
<a id="more"></a>
<h3 id="Windows设置"><a href="#Windows设置" class="headerlink" title="Windows设置"></a>Windows设置</h3><p>打开AS，点击File–&gt;Setting–&gt;Appearance &amp; Behavior–&gt;System Setting–&gt;Android SDK，在SDK Platforms下勾选真机Android版本相应的SDK。</p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>在SDK Tools目录下勾选Google Usb Driver，点击Apply，AS会自动下载Usb驱动，并记下Android SDK location。</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>数据线连接手机，windows打开设备管理器，点击便携设备，</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<p>点击相应的设备MI 5 ，选择驱动程序，更新驱动程序，浏览我的计算机以查找更新驱动程序，输入目录：AS中记下的SDK目录\extras\google\usb_driver，并安装。<br><img src="/images/pasted-12.png" alt="upload successful"></p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<h3 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h3><p>首先要打开开发者模式（每款手机的开发者模式打开方式不同，大家自行搜索），以小米为例，“设置-我的设备-全部参数-多次点击MIUI版本（有提示），如此便进入“开发者模式”了，在“更多设置”找到开发者选项，打开“USB调试” “USB安装”，并把滚动条滚到最下面，关掉“启用MIUI优化”。</p>
<p>如此便可以进入android studio调试安装了。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android-studio</tag>
      </tags>
  </entry>
  <entry>
    <title>java自定义类equal重写</title>
    <url>/2020/02/27/ava-equal/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>判断两个对象在逻辑上是否相等，有时需要根据类的某些成员变量来判断两个实例是否相等，而继承Object中的equals方法比较的只是对象的引用是否指向同一块内存地址。这时候便需要重写equals()方法了。</p>
<a id="more"></a>
<p>比较的常用对象如int，float和String等，已重写了equals和hashcode方法，默认比较的是值，而其它自定义对象在用equal时都是比较的引用地址，故此有需要的时候需要重写equal方法。</p>
<h3 id="重写equal的要求"><a href="#重写equal的要求" class="headerlink" title="重写equal的要求"></a>重写equal的要求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;  </span><br><span class="line">        if(this &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(null &#x3D;&#x3D; obj) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">       if (obj instanceof Test)&#123;</span><br><span class="line">            Test o &#x3D; (Test) obj;</span><br><span class="line">            return this.id &#x3D;&#x3D; o.id;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重写equals方法的要求：<br>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。<br>2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。<br>3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。<br>4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。<br>5、非空性：对于任意非空引用x，x.equals(null)应该返回false。</p>
<h3 id="hashCode方法也要重写"><a href="#hashCode方法也要重写" class="headerlink" title="hashCode方法也要重写"></a>hashCode方法也要重写</h3><p>问什么说<strong>重写了equals方法都要进而重写Hashcode方法</strong>呢？</p>
<p>原因如下：当equals此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() &#x3D;&#x3D; obj2.hashCode()必须为true<br>(2)当obj1.hashCode() &#x3D;&#x3D; obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p>
<p>   &amp;emsp;&amp;emsp;hashcode是用于散列数据的快速存取，如利用HashSet&#x2F;HashMap&#x2F;Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。</p>
<p>   &amp;emsp;&amp;emsp;以HashMap为例说一下的原理，HashMap存储数据的时候，是取的key值的哈希值，然后计算数组下标，采用链地址法解决冲突，然后进行存储；取数据的时候，依然是先要获取到hash值，找到数组下标，然后for遍历链表集合，进行比较是否有对应的key。比较关心的有2点：<br>  &amp;emsp;&amp;emsp; 1.不管是put还是get的时候，都需要得到key的哈希值，去定位key的数组下标；<br>   &amp;emsp;&amp;emsp;2.在get的时候，需要调用equals方法比较是否有相等的key存储过。</p>
<p>   更详细具体的可以看<a href="https://www.jianshu.com/p/75d9c2c3d0c1" target="_blank" rel="noopener">这篇博文</a>或者<a href="https://www.cnblogs.com/silence-hust/p/4510574.html" target="_blank" rel="noopener">这一篇</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/03/03/ava-reflection/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java反射机制可以让我们在编译期（Compile Time）之外的运行期（Run Time）检查类、接口、变量以及方法的信息，即动态的调用某个对象的方法&#x2F;构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见，如spring的IOC对bean的注入管理。</p>
<a id="more"></a>


<h3 id="反射回顾"><a href="#反射回顾" class="headerlink" title="反射回顾"></a>反射回顾</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p>Oracle 官方对反射的解释是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</span><br><span class="line">The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</span><br></pre></td></tr></table></figure>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java 反射主要提供以下功能：</p>
<p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p>
<h3 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h3><p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;login&quot;</span><br><span class="line">               class&#x3D;&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;</span><br><span class="line">               method&#x3D;&quot;execute&quot;&gt;</span><br><span class="line">           &lt;result&gt;&#x2F;shop&#x2F;shop-index.jsp&lt;&#x2F;result&gt;</span><br><span class="line">           &lt;result name&#x3D;&quot;error&quot;&gt;login.jsp&lt;&#x2F;result&gt; </span><br><span class="line">&lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">反射调用的一个Log</a><br><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Java反射原理简析</a></p>
<p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
]]></content>
  </entry>
  <entry>
    <title>java底层机制（堆/栈/方法区/GC/类加载）</title>
    <url>/2020/03/08/ava%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载:<strong><a href="https://www.jianshu.com/p/ae97b692614e?from=timeline" target="_blank" rel="noopener">java底层机制</a><strong>、</strong><a href="https://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="noopener">《Java虚拟机原理图解》3、JVM运行时数据区</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>bash快捷键 光标移动</title>
    <url>/2020/01/16/bash-hot-key/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用xshell登录并操作系统的时候，光标移动的快捷键用起来很方便，记录一下，方便以后查询</p>
<a id="more"></a>
<h3 id="ctrl组合"><a href="#ctrl组合" class="headerlink" title="ctrl组合"></a>ctrl组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+a:光标移到行首。</span><br><span class="line"></span><br><span class="line">ctrl+b:光标左移一个字母</span><br><span class="line"></span><br><span class="line">ctrl+c:杀死当前进程。</span><br><span class="line"></span><br><span class="line">ctrl+d:退出当前 Shell。</span><br><span class="line"></span><br><span class="line">ctrl+e:光标移到行尾。</span><br><span class="line"></span><br><span class="line">ctrl+h:删除光标前一个字符，同 backspace 键相同。</span><br><span class="line"></span><br><span class="line">ctrl+k:清除光标后至行尾的内容。</span><br><span class="line"></span><br><span class="line">ctrl+l:清屏，相当于clear。</span><br><span class="line"></span><br><span class="line">ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history</span><br><span class="line"></span><br><span class="line">ctrl+u: 清除光标前至行首间的所有内容。</span><br><span class="line"></span><br><span class="line">ctrl+w: 移除光标前的一个单词</span><br><span class="line"></span><br><span class="line">ctrl+t: 交换光标位置前的两个字符</span><br><span class="line"></span><br><span class="line">ctrl+y: 粘贴或者恢复上次的删除</span><br><span class="line"></span><br><span class="line">ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符</span><br><span class="line"></span><br><span class="line">ctrl+f: 光标右移</span><br><span class="line"></span><br><span class="line">ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</span><br></pre></td></tr></table></figure>

<h3 id="esc组合"><a href="#esc组合" class="headerlink" title="esc组合"></a>esc组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esc+d: 删除光标后的一个词</span><br><span class="line"></span><br><span class="line">esc+f: 往右跳一个词</span><br><span class="line"></span><br><span class="line">esc+b: 往左跳一个词</span><br><span class="line"></span><br><span class="line">esc+t: 交换光标位置前的两个单词</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bash-hotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>vertx-plugin build vertx app with gradle</title>
    <url>/2021/05/06/build-vertx-app-with-gradle/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://plugins.gradle.org/plugin/io.vertx.vertx-plugin" target="_blank" rel="noopener">io.vertx.vertx-plugin</a> 介绍，gradle 添加vertx-plugin，脚本启动vertx application.</p>
<a id="more"></a>
<ol>
<li>build.gradle</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &#39;io.vertx.vertx-plugin&#39; version &#39;1.2.0&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group &#39;org.example&#39;</span><br><span class="line">version &#39;1.0-SNAPSHOT&#39;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">![upload successful](&#x2F;images&#x2F;pasted-45.png)</span><br><span class="line">    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.6.0&#39;</span><br><span class="line">    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine&#39;</span><br><span class="line">    compile &quot;io.vertx:vertx-core:4.0.3&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vertx &#123;</span><br><span class="line">  mainVerticle &#x3D; &quot;MainVerticle&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>idea Run&#x2F;Debug configurations</li>
</ol>
<p><img src="/images/pasted-46.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>vertx</category>
      </categories>
      <tags>
        <tag>vertx-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu自动挂载其他盘</title>
    <url>/2021/03/18/ceshi/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p>
<a id="more"></a>

<p>1、查询挂载硬盘UUID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p>
<p>2、打开文件&#x2F;etc&#x2F;fstab文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<p>在文档末尾添加相应磁盘的信息。格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p>
<p>3、重启生效</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>centos 免密切换root</title>
    <url>/2021/04/11/centos-switch-to-root-without-password/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>centos6上免密切换到root，原理、步骤。</p>
<a id="more"></a>
<h3 id="execute-ALL-sudo-commands-without-password"><a href="#execute-ALL-sudo-commands-without-password" class="headerlink" title="execute ALL sudo commands without password"></a>execute ALL sudo commands without password</h3><p>Type the following command as root user:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># visudo</span><br></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo visudo</span><br></pre></td></tr></table></figure>
<p>Append the following entry to run ALL command without a password for a user named marlena:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remo ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>
<p>Save and close the file in vim. It is also possible to grant access to the group name such as sysadm. Any member of sysadm group can run command without a password. The syntax is</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>
<p>Of course, you can force the sysadm group to run only given commands such as &#x2F;usr&#x2F;sbin&#x2F;reboot and systemctl:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%sysadm ALL&#x3D;(ALL) NOPASSWD: &#x2F;sbin&#x2F;reboot, systemctl</span><br></pre></td></tr></table></figure>
<p>参考：**<a href="https://www.cyberciti.biz/faq/how-to-sudo-without-password-on-centos-linux/" target="_blank" rel="noopener">How to sudo without password on CentOS Linux</a>**</p>
<h3 id="switch-to-root-without-password"><a href="#switch-to-root-without-password" class="headerlink" title="switch to root without password"></a>switch to root without password</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@lansetongxin2 &#x2F;]# vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>相应位置添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-34.png" alt="upload successful"><br>ps: By default on CentOS systems, members of the group wheel are granted with sudo access.</p>
<p>:wq 保存后，便可以免密切换到root(sudo su -)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remo@lansetongxin2 ~]$ sudo su #最好使用sudo su -完全切换，su会加载不出来环境变量</span><br></pre></td></tr></table></figure>

<p>ps: su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令。</p>
<h3 id="root-ALL-x3D-ALL-ALL详解"><a href="#root-ALL-x3D-ALL-ALL详解" class="headerlink" title="root ALL&#x3D;(ALL) ALL详解"></a>root ALL&#x3D;(ALL) ALL详解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>&#x2F;etc&#x2F;sudoers中的此行表示：root用户可以从所有终端执行，充当所有（任何）用户，并运行ALL（任何）命令。<br>第一部分是用户，第二部分是用户可以使用sudo命令的终端，第三部分是他可以充当哪些用户，最后一部分是使用时可以运行的命令sudo。</p>
<p>sudoers的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator ALL&#x3D; &#x2F;sbin&#x2F;poweroff</span><br></pre></td></tr></table></figure>
<p>以上命令，使用户操作员可以从任何终端，关闭命令电源。</p>
<p>您还可以为以下项创建别名：users - &gt; User_Alias，以其他用户身份运行命令 - &gt; Runas_Alias，主机 - &gt; Host_Alias 命令 - &gt; Cmnd_Alias</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User_Alias OPERATORS &#x3D; joe, mike, jude Runas_Alias OP &#x3D; root, operator Host_Alias OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0 Cmnd_Alias PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br></pre></td></tr></table></figure>
<p>正如您所看到的别名OPERATORS包括用户joe，mike和jude，别名OP包括用户root和operator，别名OFNET包括网络10.1.2.0（所有C类），命令别名PRINTING包含命令lpc和lprm。</p>
<p>因此，典型的sudoers文件可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> User_Alias     OPERATORS &#x3D; joe, mike, jude</span><br><span class="line"> Runas_Alias    OP &#x3D; root, operator</span><br><span class="line"> Host_Alias     OFNET &#x3D; 10.1.2.0&#x2F;255.255.255.0</span><br><span class="line"> Cmnd_Alias     PRINTING &#x3D; &#x2F;usr&#x2F;sbin&#x2F;lpc, &#x2F;usr&#x2F;bin&#x2F;lprm</span><br><span class="line"></span><br><span class="line">OPERATORS ALL&#x3D;ALL</span><br><span class="line"></span><br><span class="line">#The users in the OPERATORS group can run any command from</span><br><span class="line"> any terminal.</span><br><span class="line"></span><br><span class="line">linus ALL&#x3D;(OP) ALL</span><br><span class="line"></span><br><span class="line"># The user linus can run any command from any terminal as any </span><br><span class="line">user in the OP group (root or operator).</span><br><span class="line"></span><br><span class="line">user2 OFNET&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># user user2 may run any command from any machine in the </span><br><span class="line">OFNET network, as any user.</span><br><span class="line"></span><br><span class="line">user3 ALL&#x3D; PRINTING</span><br><span class="line"></span><br><span class="line"># user user3 may run lpc and lprm from any machine.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>在编辑器中打开 sudoers 文件后，您需要向下滚动到编辑器的末尾并在其中添加以下代码！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>
<p>用您的用户名替换“ yujiaao ”！（例如：anderson ALL &#x3D;（ALL）NOPASSWD：ALL），命令NOPASSWD将在终端中运行SUDO命令时跳过密码验证。</p>
<p>如何在为特定命令运行sudo时跳过密码：<br>您可以允许某些命令使用密码运行sudo，使用以下命令来实现它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yujiaao ALL&#x3D;(ALL) NOPASSWD:&#x2F;bin&#x2F;cp,&#x2F;bin&#x2F;install,bin&#x2F;remove</span><br></pre></td></tr></table></figure>
<p>完成编辑后，请保存文件并退出终端。</p>
<p>NOPASSWD 是一个“标签”，表示不会请求密码。它有一个名为的伴随命令 PASSWD，是默认行为。标签与规则的其余部分相关，除非在其后面的“双胞胎”标签上被否决。<br>例如，我们可以有这样的一行：</p>
<p>在 &#x2F;etc&#x2F;sudoers文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GROUPTWO    ALL &#x3D; NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;updatedb, PASSWD: &#x2F;bin&#x2F;kill</span><br></pre></td></tr></table></figure>
<p>另一个有用的标签NOEXEC，可用于防止某些程序中的某些危险行为。</p>
<p>例如，某些程序（如“less”）可以通过在其界面中键入以下内容来生成其他命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!command_to_run</span><br></pre></td></tr></table></figure>
<p>这基本上执行用户赋予它的任何命令，具有“less”运行的相同权限，这可能非常危险。</p>
<p>为了限制这一点，我们可以使用这样的一行：</p>
<p>在 &#x2F;etc&#x2F;sudoers文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username  ALL &#x3D; NOEXEC: &#x2F;usr&#x2F;bin&#x2F;less</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>trojan科学上网</title>
    <url>/2020/01/29/gfw/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直用的ssr科学上网，侥幸挺过了去年国庆等的各种严打，一直傲娇地活跃到年底，没想到值此新春佳节之际，终于不出预料地被封了，丧事喜办，旧的不去新的不来，正好试试trojan，希望他能接过前辈的火种，超神带我飞，直直挺到2021吖，本文记录一下vps、windows pc以及android手机的配置。</p>
<a id="more"></a>
<h3 id="vps配置"><a href="#vps配置" class="headerlink" title="vps配置"></a>vps配置</h3><h4 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h4><p>系统centos7，网上荡来的一键安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;atrandys&#x2F;trojan&#x2F;master&#x2F;trojan_mult.sh &amp;&amp; chmod +x trojan_mult.sh &amp;&amp; .&#x2F;trojan_mult.sh</span><br></pre></td></tr></table></figure>
<p>根据脚本提示，该输入数字输入数字，该输入域名输入域名，一撸到底，成功后屏幕会显示一个客户端的链接，弃之不用。</p>
<h4 id="bbr加速"><a href="#bbr加速" class="headerlink" title="bbr加速"></a>bbr加速</h4><p>先查看系统内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p>低于4.10的需升级内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo&#x3D;elrepo-kernel install kernel-ml -y</span><br></pre></td></tr></table></figure>
<p>安装完毕后查看已安装内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F\&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;etc&#x2F;grub2.cfg</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 : CentOS Linux 7 Rescue f128bc3705574dfab442f23fb7245e0b (5.5.0-1.el7.elrepo.x86_64)</span><br><span class="line">1 : CentOS Linux (5.5.0-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (3.10.0-1062.9.1.el7.x86_64) 7 (Core)</span><br><span class="line">3 : CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)</span><br><span class="line">4 : CentOS Linux (0-rescue-7bd68357fb1f47688c0f1b0a48330334) 7 (Core)</span><br></pre></td></tr></table></figure>
<p>根据序号设置默认内核：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub2-set-default 1</span><br></pre></td></tr></table></figure>
<p>重启服务器。<br>修改sysctl配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;net.core.default_qdisc&#x3D;fq&#39; | tee -a &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &#39;net.ipv4.tcp_congestion_control&#x3D;bbr&#39; |  tee -a &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>检查是否加载BBR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>如果输出结果包含tcp_bbr，则表示开启成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp_bbr   20480  35</span><br></pre></td></tr></table></figure>
<p>值此，VPS配置完毕。</p>
<h3 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h3><p>下载v2rayN客户端：<a href="https://github.com/2dust/v2rayN/releases/download/3.5/v2rayN.zip" target="_blank" rel="noopener">v2rayN</a><br>运行v2rayN.exe，服务器–&gt;Add [trojan]server–&gt;输入VPS IP，密码以及端口443–&gt;右击任务栏上v2rayN,启用Http代理，Http模式选择pac。<br>密码可以在vps（cat &#x2F;usr&#x2F;src&#x2F;trojan&#x2F;server.conf）trojan配置文件中查看。<br>至此，便可以在浏览器里科学上网了，至于其他电脑程序要科学上网，可以配置本机socks5代理，监听1080端口。</p>
<h3 id="android配置"><a href="#android配置" class="headerlink" title="android配置"></a>android配置</h3><p>现在只找到<a href="https://github.com/trojan-gfw/igniter/releases/download/v0.1.0-pre-alpha13/app-release.apk" target="_blank" rel="noopener">Igniter</a>，不太好用，静待更新。。。</p>
]]></content>
      <tags>
        <tag>trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 定时任务（cron）通过第三方邮件服务器（MTA）发送邮件</title>
    <url>/2020/01/13/corn-mail/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时会需要把一些日志或者任务结果发送到用户邮箱，特此记录一下定时任务和邮箱信息的配置。</p>
<a id="more"></a>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>守护进程 crond定期(每分钟)检查是否有要执行的任务，任务调度分为两类：<strong>系统任务调度</strong>和<strong>用户任务调度</strong>。</p>
<p><strong>系统任务调度</strong>：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。配置文件<code>/etc/crontab</code>。（若要配置定时reboot任务，需配置在此）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name command to be executed</span><br><span class="line">  10 21 *  *  * root reboot</span><br></pre></td></tr></table></figure>


<p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户数据备份、定时邮件提醒、自定义脚本等。配置文件<code>/var/spool/cron/usernamne</code>，用户亦可以用命令crontab定制自己的计划任务。如每隔一分钟给指定邮箱发信息，<code>crontab -u username -e</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAILTO&#x3D;&quot;yourmailaddress@**.com&quot;</span><br><span class="line">*&#x2F;1 * * * *  echo &#39;message&#39;</span><br></pre></td></tr></table></figure>
<p><em>ps</em>：crontab中任何程序产生的输出都会以邮件的形式发送给由MAILTO指定的对象，若未指定则发给任务运行的用户（可于<code>/var/spool/mail/username</code>中查看），此时可通过<code>.forward</code> 或配置<code>/etc/aliases</code> 发送到外部邮箱。</p>
<h3 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h3><p>用系统自带的postfix配置MTA太费事儿，所以采用163邮箱的SMTP服务。</p>
<p>  1.邮箱开启SMTP服务</p>
<p>  登录邮箱，在<code>设置</code>里打开<code>POP3/SMTP/IMAP</code>，勾选<code>POP3/SMTP服务</code>和<code>IMAP/SMTP服务</code>，并设置自己的<code>客户端授权密码</code>。</p>
<p>  2.centos安装mailx(相当于MUA)<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mailx</span><br></pre></td></tr></table></figure><br>  3.centos配置163邮箱信息，在文件 <code>/etc/mail.rc</code>末尾添加如下信息<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set from&#x3D;&quot;*********@163.com&quot;</span><br><span class="line">set smtp&#x3D;smtp.163.com</span><br><span class="line">set smtp-auth-user&#x3D;*********@163.com</span><br><span class="line">set smtp-auth-password&#x3D;客户端授权密码</span><br><span class="line">set smtp-auth&#x3D;login</span><br></pre></td></tr></table></figure></p>
<p>  <em>ps</em>:防火墙配置（vultr要联系客服“开光”25端口）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mail</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔有感</title>
    <url>/2020/01/13/hello-world/</url>
    <content><![CDATA[<p>一个不读书之人的胡思胡想</p>
<a id="more"></a>
<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/01/18/git-command/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前使用SVN,切换到分布式版本控制系统Git，此笔记记录一下学习心得，备询。**<a href="https://gist.github.com/guweigang/9848271" target="_blank" rel="noopener">git命令大全</a><strong>，贴个链接，比较</strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank" rel="noopener">适合初次接触者</a><strong>，</strong><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1" target="_blank" rel="noopener">动画演示Git命令</a>**</p>
<a id="more"></a>
<h3 id="git配置代理"><a href="#git配置代理" class="headerlink" title="git配置代理"></a>git配置代理</h3><p>天朝特色，使用git clone下载同性交友网站（github）的仓库时，巨慢！如果可以科学上网的话，设置一下代理，加一下速…<br>本文用的trojan科学上网，利用它的socks5代理加速。配置命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;</span><br></pre></td></tr></table></figure>

<p>取消代理的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="git提交到多个remote"><a href="#git提交到多个remote" class="headerlink" title="git提交到多个remote"></a>git提交到多个remote</h3><p>本地生成博客页面，git部署到VPS远端，也顺便也部署到github。下面就通过把本地的文件提交到两个git远端(Remote)的事例，了解git命令的使用。<br>切换到指定目录（以目录hexo下的.deploy_git文件夹为例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init        &#x2F;&#x2F;初始化一个git的本地仓库(以前hexo deploy的时候已经有了本地仓库，配置信息在隐藏文件夹.git里)</span><br><span class="line">git add myfile. &#x2F;&#x2F;将myfile加入暂存区index（</span><br><span class="line">git commit -m “first commit” &#x2F;&#x2F;把暂存区的文件提交到本地仓库</span><br><span class="line">git remote add Name1 git@vps的IP:hexo.git &#x2F;&#x2F;增加一个新的远程仓库，并命名为Name1</span><br><span class="line">git push -u Name1 master &#x2F;&#x2F;把分支master的内容push到远程仓库</span><br><span class="line">git remote add Name2 git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line"> &#x2F;&#x2F;添加第二个远程仓库，并命名为Name2</span><br><span class="line">git push -u Name2 master &#x2F;&#x2F;将分支master的内容push到第二个远程仓库</span><br></pre></td></tr></table></figure>
<p>至此，就将本地文件提交到两个远端仓库了。<br>ps:由于我的github的yourname.github.io仓库里已经有了文件，所以push的时候会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: failed to push some refs to &#39;git@github.com:yourname&#x2F;yourname.github.io.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>
<p>解决方法：<br>$ git push -f Name2 master</p>
<h3 id="git-pull冲突"><a href="#git-pull冲突" class="headerlink" title="git pull冲突"></a>git pull冲突</h3><p>从github上fork了一个项目，并clone到本地，做了一些删改后，想要提交到github个人仓库，但发现作者项目更新了，便把fork来的项目通过New pull request和原项目同步更新了。这时本地在用git pull更新项目时，遇到了下面的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge: xxx&#x2F;xxx&#x2F;xxx </span><br><span class="line">Please, commit your changes or stash them before you can merge. </span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>解决方法两种：</p>
<h4 id="覆盖本地修改"><a href="#覆盖本地修改" class="headerlink" title="覆盖本地修改"></a>覆盖本地修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>这种会放弃本地修改的代码，看情况使用。</p>
<h4 id="使用git-stash"><a href="#使用git-stash" class="headerlink" title="使用git stash"></a>使用git stash</h4><p>这种会保留自己本地修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<p>最后就可以diff一下文件看看自动合并的情况，并对解决冲突文件做相应修改后提交即可。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>idea下gradle报jdk版本错误</title>
    <url>/2020/03/05/idea-gradle-jdk/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>idea下用gradle编译项目的时候报错如下：“Could not target platform: ‘Java SE 13’ using tool chain: ‘JDK 11 (11)’.”</p>
<a id="more"></a>
<p>确认project采用的jdk 13,build.gradle里也是13，应该是Gradle用的版本不匹配，最后在File–&gt;Setting–&gt;Build Tools–&gt;Gradle里，找到配置项。</p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>int&amp;Integer、 double&amp;Double&amp;BigDecimal</title>
    <url>/2022/03/09/int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/guodongdidi/p/6953217.html" target="_blank" rel="noopener">int和Integer的区别</a>&amp;nbsp;&amp;nbsp;<a href="http://www.louisvv.com/archives/2514.html" target="_blank" rel="noopener">double、Double与BigDecimal</a></p>
]]></content>
  </entry>
  <entry>
    <title>intellij-idea的快捷键</title>
    <url>/2020/12/23/intellij-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p><a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">Intellij-idea的快捷键</a></p>
]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>@interface 简介</title>
    <url>/2021/11/11/interface/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zhangbeizhen18/article/details/87885441/" target="_blank" rel="noopener">自定义注释@interface的用法理解</a></p>
]]></content>
  </entry>
  <entry>
    <title>spring boot注解基本了解</title>
    <url>/2020/03/06/java-annotation/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里放两篇对Java注解的文章，以备后面查询。<a href="https://www.jianshu.com/p/d74ed7374841" target="_blank" rel="noopener"><strong>Spring Boot 注解—基本知识</strong></a>以及<a href="https://www.cnblogs.com/liaojie970/p/7879917.html" target="_blank" rel="noopener"><strong>Java注释@interface的用法</strong></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin 构造函数</title>
    <url>/2020/05/17/kotlin-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>转载：**<a href="https://www.cnblogs.com/Jetictors/p/7758828.html" target="_blank" rel="noopener">Kotlin——中级篇（一）：类（class）详解</a><strong>、</strong><a href="https://www.jianshu.com/p/5db34354d812" target="_blank" rel="noopener">kotlin之构造函数(constructor)
</a>**<br>1、在Kotlin中，允许有一个主构造函数和多个二级构造函数（辅助构造函数）。其中主构造函数是类头的一部分。</p>
<p>2、如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用this关键字对同一类的另一个构造函数进行委派</p>
<a id="more"></a>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test constructor(num: Int)&#123;</span><br><span class="line">    constructor(num : Int, num2: Int) : this(num) &#123;</span><br><span class="line">        println(num + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：二级构造函数中的参数1(num)，是委托了主构造函数的参数num。</span><br></pre></td></tr></table></figure>

<p>3、在JVM上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用Kotlin与诸如Jackson或JPA的库，通过无参数构造函数创建类实例。<br>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>js  0 == &#39;&#39; 引出的判等</title>
    <url>/2021/12/08/js-0-%E5%BC%95%E5%87%BA%E7%9A%84%E5%88%A4%E7%AD%89/</url>
    <content><![CDATA[<p><strong><a href="https://segmentfault.com/a/1190000021394035" target="_blank" rel="noopener">javascript中的假值相等判断(false,null,undefined,NaN,数字0,空字符串)</a></strong> &amp;nbsp;&amp;nbsp;&amp;nbsp;<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">JavaScript 中的相等性判断</a></strong></p>
<a id="more"></a>

<table class="standard-table">
 <caption>判等</caption>
 <thead>
  <tr>
   <th scope="col" style="text-align: center;">x</th>
   <th scope="col" style="text-align: center;">y</th>
   <th scope="col" style="width: 10em; text-align: center;"><code>==</code></th>
   <th scope="col" style="width: 10em; text-align: center;"><code>===</code></th>
   <th scope="col" style="width: 10em; text-align: center;"><code>Object.is</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>undefined</code></td>
   <td><code>undefined</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>null</code></td>
   <td><code>null</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>true</code></td>
   <td><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>false</code></td>
   <td><code>false</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>"foo"</code></td>
   <td><code>"foo"</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>0</code></td>
   <td><code>0</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
  <tr>
   <td><code>+0</code></td>
   <td><code>-0</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>0</code></td>
   <td><code>false</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>""</code></td>
   <td><code>false</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>""</code></td>
   <td><code>0</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>"0"</code></td>
   <td><code>0</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>"17"</code></td>
   <td><code>17</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>[1,2]</code></td>
   <td><code>"1,2"</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>new String("foo")</code></td>
   <td><code>"foo"</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>null</code></td>
   <td><code>undefined</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>null</code></td>
   <td><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>undefined</code></td>
   <td><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>{ foo: "bar" }</code></td>
   <td><code>{ foo: "bar" }</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>new String("foo")</code></td>
   <td><code>new String("foo")</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>0</code></td>
   <td><code>null</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>0</code></td>
   <td><code>NaN</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>"foo"</code></td>
   <td><code>NaN</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
  </tr>
  <tr>
   <td><code>NaN</code></td>
   <td><code>NaN</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(255, 144, 144); text-align: center;"><code>false</code></td>
   <td style="background-color: rgb(144, 255, 144); text-align: center;"><code>true</code></td>
  </tr>
 </tbody>
</table>

]]></content>
  </entry>
  <entry>
    <title>json web token(jwt)</title>
    <url>/2020/05/02/json-web-token-jwt/</url>
    <content><![CDATA[<p>转载：**<a href="https://learnku.com/articles/22616" target="_blank" rel="noopener">别再使用 JWT 作为 Session 系统！问题重重且很危险。
</a>**<br>结论：无状态 JWT Tokens 无法被单独地销毁或更新，取决于你如何存储，可能还会导致长度问题、安全隐患。有状态 JWT Tokens 在功能方面与 Session cookies 无异，但缺乏生产环境的验证、经过大量 Review 的实现，以及良好的客户端支持。<br>JWT 特别有效的使用例子通常是作为一次性的授权令牌。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>linux sort uniq命令</title>
    <url>/2021/02/26/linux-sort-uniq%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><a href="https://www.linuxjournal.com/content/back-basics-sort-and-uniq" target="_blank" rel="noopener">Back to Basics: Sort and Uniq</a></p>
]]></content>
  </entry>
  <entry>
    <title>java中的乱码</title>
    <url>/2020/12/08/java%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://developer.ibm.com/zh/languages/java/articles/j-lo-chinesecoding/" target="_blank" rel="noopener">深入分析 Java 中的中文编码问题</a>、<a href="https://blog.csdn.net/u010234516/article/details/52853214" target="_blank" rel="noopener">锟斤拷？UTF-8与GBK互转，为什么会乱码？</a></p>
<p>附图一张:</p>
<a id="more"></a>
<p><img src="/images/crazyCode.jpg" alt="upload successful"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 后台运行、输出重定向</title>
    <url>/2021/04/02/linux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux termianl中，命令脚本的后台运行以及输出的重定向，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &gt; my.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;myshell.sh &amp;&gt; my.log &amp;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>当启动一个服务后，希望命令在后台运行时，可以通过在命令末尾增加 &amp; ，例如：.&#x2F;test.sh &amp;，执行上述命令后，脚本开始在后台运行，并且命令行回显为 [1] 12532 ,这里的 1表示后台进程的编号，可以通过命令 fg 1 把进程切换回前台运行。</p>
<p>此时，虽然命令已经后台运行了，我们可以在控制台输入其他命令，但是脚本每秒打印的 x 会不断的输出到控制台，影响我们其他命令的执行，这时，我也需要用输出重定向把命令的执行结果输出的文件中。</p>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>一个程序执行后，系统会生成三个句柄，分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#x3D;stdin（标准输入）</span><br><span class="line">1&#x3D;stdout（标准输出）</span><br><span class="line">2&#x3D;stderr（错误输出）</span><br></pre></td></tr></table></figure>
<p>默认情况下，三个句柄都指向当前会话的命令行控制台。命令转到后台执行后，stdin关闭，stdout和stderr还是指向控制台。</p>
<p>通过在命令后使用输出重定向符 &gt; 实现对输出的重定向。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log &amp;</span><br></pre></td></tr></table></figure>
<p>表示把stdout重定向到当前目录的run.log文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;run.py &gt; run.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>表示把stdout和stderr都重定向到run.log，其中 2&gt;&amp;1 表示把stderr重定向到stdout。另外，其中&gt; run.log表示标准输出重定向到文件run.log中且是<strong>覆盖重写，如果想要追加方式写入，则是&gt;&gt; run.log</strong>。</p>
<p>Linux下还有一个特殊的文件&#x2F;dev&#x2F;null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到&#x2F;dev&#x2F;null。 </p>
<p>如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到&#x2F;dev&#x2F;null， 例如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls 1&gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
<p>还有一种做法是将错误重定向到标准输出，然后再重定向到 &#x2F;dev&#x2F;null，例如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 &#x2F;dev&#x2F;null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了&#x2F;dev&#x2F;null，因此标准错误也会重定向到&#x2F;dev&#x2F;null，于是一切静悄悄:-) </p>
<p>另外+: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command &amp;&gt; make_log</span><br></pre></td></tr></table></figure>
<p>意思是把标准输出和错误输出都重定向, <em>command&gt;out</em> 只重定向标准输出!!!!! </p>
<p><em>&gt;log</em> 表示把标准输出重新定向到文件log中 </p>
<p><em>&amp;&gt; log</em> 表示把标准输出和错误输出都定向到文件log中，相当于 <em>&gt;log 2&gt;&amp;1</em></p>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>通过 &amp; 虽然可以把命令以后台进程的方式执行，但是如果SSH会话中断退出，和此会话相关的所有进程都会终止。<br>如果我们是登录服务器去启动一个服务程序，总不能启动后一直把SSH会话开着，而且会话到期会自动终止。</p>
<p>这是，我们可以使用 nohup（no hung up）来执行进程，此命令确保会话挂断后，命令可以继续运行。以nohup运行的命令，系统默认自动把stdout和stderr重定向到当前目录的nohup.out文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;run.py &amp;</span><br></pre></td></tr></table></figure>
<h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><p>&amp;：已后台进程执行命令，但是会话关闭后，进程会结束。</p>
<p>nohup：确保进程不挂断的执行，但是没有后台执行的功能，所以一般nohup和&amp;需要配合一起使用。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux 查看登录历史 操作用户</title>
    <url>/2021/02/26/linux-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E5%8E%86%E5%8F%B2-%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>linux 查看登录历史 操作用户</p>
<a id="more"></a>
<h2 id="linux查看用户登录，操作历史等"><a href="#linux查看用户登录，操作历史等" class="headerlink" title="linux查看用户登录，操作历史等"></a>linux查看用户登录，操作历史等</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">who 命令：显示当前当登录的用户的信息</span><br><span class="line">who -b命令：显示系统最近一次的启动时间</span><br><span class="line">w 命令：显示登录的用户及其当前执行的任务</span><br><span class="line">last 命令：显示当前与过去登录系统的用户的信息</span><br><span class="line">lastb 命令：显示所有登录系统失败的用户的信息</span><br><span class="line">lastlog 命令：显示用户最后一次登录的信息</span><br><span class="line">history 命令：查看操作历史</span><br><span class="line">history -c命令：清除操作历史</span><br><span class="line">pkill -kill -u test ： 强制test用户下线</span><br></pre></td></tr></table></figure>
<h2 id="linux清除系统日志、历史记录、登录信息"><a href="#linux清除系统日志、历史记录、登录信息" class="headerlink" title="linux清除系统日志、历史记录、登录信息"></a>linux清除系统日志、历史记录、登录信息</h2><h3 id="清楚日志"><a href="#清楚日志" class="headerlink" title="清楚日志"></a>清楚日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;wtmp &#x2F;&#x2F;清除用户登录记录</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;btmp &#x2F;&#x2F;清除尝试登录记录</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;lastlog &#x2F;&#x2F;清除最近登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;secure &#x2F;&#x2F;登录信息</span><br><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;syslog &#x2F;&#x2F;记录系统日志的服务</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;xferlog</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;auth.log</span><br><span class="line">echo&gt;&#x2F;var&#x2F;log&#x2F;user.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;adm&#x2F;sylog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;maillog</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;openwebmail.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; &#x2F;var&#x2F;log&#x2F;mail.info</span><br><span class="line">echo&gt;&#x2F;var&#x2F;run&#x2F;utmp</span><br></pre></td></tr></table></figure>
<h3 id="清除操作过的命令记录"><a href="#清除操作过的命令记录" class="headerlink" title="清除操作过的命令记录"></a>清除操作过的命令记录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &gt; .bash_history &#x2F;&#x2F;清除保存的用户操作历史记录</span><br><span class="line">history -cw &#x2F;&#x2F;清除所有历史</span><br></pre></td></tr></table></figure>
<h3 id="Linux查看History记录加时间戳小技巧"><a href="#Linux查看History记录加时间戳小技巧" class="headerlink" title="Linux查看History记录加时间戳小技巧"></a>Linux查看History记录加时间戳小技巧</h3><p>熟悉bash的都一定知道使用history可以输出你曾经输入过的历史命令，例如  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@servyou_web ~]# history | more</span><br><span class="line">.&#x2F;test.sh</span><br><span class="line">vim test.sh</span><br><span class="line">.&#x2F;test.sh</span><br></pre></td></tr></table></figure>
<p>但是这里只显示了命令，并没有显示执行命令的时间，因为保存历史命令的~&#x2F;.bash_history里并没有保存时间。</p>
<p>通过设置环境变量 export HISTTIMEFORMAT&#x3D;”%F %T whoami “ 给history加上时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@servyou_web ~]# export HISTTIMEFORMAT&#x3D;&quot;%F %T whoami &quot;</span><br><span class="line">[root@servyou_web ~]# history | tail</span><br><span class="line">2011-06-22 19:17:29 root 15 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 16 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 17 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 18 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 19 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 20 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:17:29 root 21 2011-06-22 19:13:02 root .&#x2F;test.sh</span><br><span class="line">2011-06-22 19:17:29 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:22 root 22 2011-06-22 19:13:02 root vim test.sh</span><br><span class="line">2011-06-22 19:25:28 root history | tail</span><br></pre></td></tr></table></figure>
<p>可以看到，历史命令的时间戳已经加上了，但是.bash_history里并没有加上这个时间戳。其实这个时间记录是保存在当前shell进程内存里的，如果你logout并且重新登录的话会发现你上次登录时执行的那些命令的时间戳都为同一个值，即当时logout时的时间。</p>
<p>尽管如此，对于加上screen的bash来说，这个时间戳仍然可以长时间有效的，毕竟只要你的server不重启，screen就不会退出，因而这些时间就能长时间保留。你也可以使用echo ‘export HISTTIMEFORMAT&#x3D;”%F %T whoami “‘ &gt;&gt; &#x2F;etc&#x2F;profile 然后source一下就OK。</p>
<p><a href="https://blog.51cto.com/study2008/2301555" target="_blank" rel="noopener">source</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux小技巧</title>
    <url>/2021/04/16/linux%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="linux小技巧"><a href="#linux小技巧" class="headerlink" title="linux小技巧"></a>linux小技巧</h3><p>linux有用的小技巧，随时添加。</p>
<p>源链接：**<u><a href="https://mp.weixin.qq.com/s/KZcnlW4RRZowPUelsRQAGA" target="_blank" rel="noopener">15 个 Linux 实用技巧</a></u>**</p>
<a id="more"></a>
<h3 id="命令不记录到history"><a href="#命令不记录到history" class="headerlink" title="命令不记录到history"></a>命令不记录到history</h3><p>我们在所要执行的命令前，加一个空格，那这条命令就不会被 history 保存到历史记录</p>
<p>有时候，执行的命令中包含敏感信息，这个小技巧就显得非常实用了，你也不会再因为忘记执行 history -c 而烦恼了。</p>
<h3 id="快速搜索历史命令"><a href="#快速搜索历史命令" class="headerlink" title="快速搜索历史命令"></a>快速搜索历史命令</h3><p>在 Linux 下经常会敲很多的命令，我们要怎么快速查找并执行历史命令呢？</p>
<p>通过上下键来翻看历史命令，No No No，可以通过执行 Ctrl + r，然后键入要所搜索的命令关键词，进行搜索，回车就可以执行，非常高效。</p>
<h3 id="历史命令使用技巧"><a href="#历史命令使用技巧" class="headerlink" title="历史命令使用技巧"></a>历史命令使用技巧</h3><p>分享几个历史命令的使用技巧，能够提高你的工作效率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!：重复执行上条命令；</span><br><span class="line">!N：重复执行 history 历史中第 N 条命令，N 可以通过 history 查看；</span><br><span class="line">!pw：重复执行最近一次，以pw开头的历史命令，这个非常有用，小编使用非常高频；</span><br><span class="line">!$：表示最近一次命令的最后一个参数；</span><br></pre></td></tr></table></figure>
<p>猜测大部分同学没用过 !$，这里简单举个例子，让你感受一下它的高效用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c</span><br><span class="line">$ mv !$ !$.bak</span><br><span class="line"># 相当于</span><br><span class="line">$ mv &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c &#x2F;root&#x2F;sniffer&#x2F;src&#x2F;main.c.bak</span><br></pre></td></tr></table></figure>
<p>当前工作目录是 root，想把 main.c 改为 main.c.bak。正常情况你可能需要敲 2 遍包含 main.c 的长参数，当然你也可能会选择直接复制粘贴。</p>
<p>而我通过使用 !$ 变量，可以很轻松优雅的实现改名。</p>
<h3 id="优雅的删除、修改乱码名字的文件"><a href="#优雅的删除、修改乱码名字的文件" class="headerlink" title="优雅的删除、修改乱码名字的文件"></a>优雅的删除、修改乱码名字的文件</h3><p>在 Linux 系统中，会经常碰到名称乱码的文件。想要删除它，却无法通过键盘输入名字，有时候复制粘贴乱码名称，终端可能识别不了，该怎么办？</p>
<p>不用担心，下边来展示下 find 是如何优雅的解决问题的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls  -i</span><br><span class="line">138957 a.txt  138959 T.txt  132395 ڹ��.txt</span><br><span class="line"></span><br><span class="line">$ find . -inum 132395 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>命令中，-inum 指定的是文件的 inode 号，它是系统中每个文件对应的唯一编号，find 通过编号找到后，执行删除操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find -inum 节点号 -exec rm &#123;&#125; \; &#x2F;&#x2F;删除</span><br><span class="line">find -inum 节点号 -exec mv &#123;&#125; newname \; &#x2F;&#x2F;重命名</span><br><span class="line">find -inum 节点号 -exec cat &#123;&#125; \; &#x2F;&#x2F;查看内容</span><br></pre></td></tr></table></figure>

<h3 id="Linux上获取你的公网IP地址"><a href="#Linux上获取你的公网IP地址" class="headerlink" title="Linux上获取你的公网IP地址"></a>Linux上获取你的公网IP地址</h3><p>在办公或家庭环境，我们的虚拟机或服务器上配置的通常是内网 IP 地址，我们如何知道，在与外网通信时，我们的公网出口 IP 是神马呢？</p>
<p>这个在 Linux 上非常简单，一条命令搞定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl ip.sb</span><br><span class="line">$ curl ifconfig.me</span><br></pre></td></tr></table></figure>
<p>上述两条命令都可以</p>
<h3 id="动态实时查看日志"><a href="#动态实时查看日志" class="headerlink" title="动态实时查看日志"></a>动态实时查看日志</h3><p>通过 tail 命令 -f 选项，可以动态地监控日志文件的变化，非常实用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -f test.log</span><br></pre></td></tr></table></figure>
<p>如果想在日志中出现 Failed 等信息时立刻停止 tail 监控，可以通过如下命令来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tail -f test.log | sed &#39;&#x2F;Failed&#x2F; q&#39;</span><br></pre></td></tr></table></figure>
<h3 id="快速清空文件的方法"><a href="#快速清空文件的方法" class="headerlink" title="快速清空文件的方法"></a>快速清空文件的方法</h3><p>快速清空一个文件，有 N 种方法，我比较喜欢下边这种，因为它最短</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &gt; access.log</span><br></pre></td></tr></table></figure>
<p>不过瘾？好吧，我也顺便总结下，其它几种最常见的清空文件的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">: &gt; access.log</span><br><span class="line">true &gt; access.log</span><br><span class="line">cat &#x2F;dev&#x2F;null &gt; access.log</span><br><span class="line">echo -n &quot;&quot; &gt; access.log</span><br><span class="line">echo &gt; access.log</span><br><span class="line">truncate -s 0 access.log</span><br></pre></td></tr></table></figure>
<p>简单解释下， : 在 shell 中是一个内置命令，表示 no-op，大概就是空语句的意思，所以 : 的那个用法，就是执行命令后，什么都没有输出，将空内容覆盖到文件。</p>
<h3 id="快速生成大文件"><a href="#快速生成大文件" class="headerlink" title="快速生成大文件"></a>快速生成大文件</h3><p>有时候，在 Linux 上，我们需要一个大文件，用于测试上传或下载的速度，通过 dd 命令可以快速生成一个大文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;file.img bs&#x3D;1M count&#x3D;1024</span><br></pre></td></tr></table></figure>
<p>上述命令，生成一个文件名为 file.img 大小为 1G 的文件。</p>
<h3 id="安全擦除硬盘数据"><a href="#安全擦除硬盘数据" class="headerlink" title="安全擦除硬盘数据"></a>安全擦除硬盘数据</h3><p>介绍一种擦除硬盘数据的方法，高效，安全。可以通过 dd 命令，轻松实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;urandom of&#x3D;&#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure>
<p>使用 &#x2F;dev&#x2F;urandom 生成随机数据，将生成的数据写入 sda 硬盘中，相当于安全的擦除了硬盘数据。</p>
<h3 id="快速制作系统盘"><a href="#快速制作系统盘" class="headerlink" title="快速制作系统盘"></a>快速制作系统盘</h3><p>在 Linux 下制作系统盘，老毛桃神么工具都弱爆了，直接一条命令搞定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd if&#x3D;ubuntu-server-amd64.iso of&#x3D;&#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>
<p>哈哈，是不是很爽，sdb 可以 U 盘，也可以是普通硬盘</p>
<h3 id="查看某个进程的运行时间"><a href="#查看某个进程的运行时间" class="headerlink" title="查看某个进程的运行时间"></a>查看某个进程的运行时间</h3><p>可能，大部分同学只会使用 ps aux，其实可以通过 -o 参数，指定只显示具体的某个字段，会得到更清晰的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -p 10167 -o etimes,etime</span><br><span class="line">ELAPSED     ELAPSED</span><br><span class="line">1712055 19-19:34:15</span><br></pre></td></tr></table></figure>
<p>通过 etime 获取该进程的运行时间，可以很直观地看到，进程运行了 19 天</p>
<p>同样，可以通过 -o 指定 rss 可以只获取该进程的内存信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -p 10167 -o rss</span><br><span class="line">  RSS</span><br><span class="line"> 2180</span><br></pre></td></tr></table></figure>

<h3 id="时间戳的快速转换"><a href="#时间戳的快速转换" class="headerlink" title="时间戳的快速转换"></a>时间戳的快速转换</h3><p>时间操作，对程序员来说就是家常便饭。有时候希望能够将时间戳，转换为日期时间，在 Linux 命令行上，也可以快速的进行转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ date -d@1234567890 +&quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2009-02-14 07:31:30</span><br></pre></td></tr></table></figure>
<p>当然，也可以在命令行上，查看当前的时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ date +%s</span><br><span class="line">1617514141</span><br></pre></td></tr></table></figure>
<h3 id="优雅的计算程序运行时间"><a href="#优雅的计算程序运行时间" class="headerlink" title="优雅的计算程序运行时间"></a>优雅的计算程序运行时间</h3><p>在 Linux 下，可以通过 time 命令，很容易获取程序的运行时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time .&#x2F;test</span><br><span class="line">real    0m1.003s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.000s</span><br></pre></td></tr></table></figure>
<p>可以看到，程序的运行时间为: 1.003s。细心的同学，会看到 real 貌似不等于 user + sys，而且还远远大于，这是怎么回事呢？</p>
<p>先来解释下这三个参数的含义：</p>
<ul>
<li>real：表示的钟表时间，也就是从程序执行到结束花费的时间；</li>
<li>user：表示运行期间，cpu 在用户空间所消耗的时间；</li>
<li>sys：表示运行期间，cpu 在内核空间所消耗的时间；</li>
</ul>
<p>由于 user 和 sys 只统计 cpu 消耗的时间，程序运行期间会调用 sleep 发生阻塞，也可能会等待网络或磁盘 IO，都会消耗大量时间。因此对于类似情况，real 的值就会大于其它两项之和。</p>
<p>另外，也会遇到 real 远远小于 user + sys 的场景，这是什么鬼情况？</p>
<p>这个更好理解，如果程序在多个 cpu 上并行，那么 user 和 sys 统计时间是多个 cpu 时间，实际消耗时间 real 很可能就比其它两个之和要小了</p>
<h3 id="命令行查看ascii码"><a href="#命令行查看ascii码" class="headerlink" title="命令行查看ascii码"></a>命令行查看ascii码</h3><p>我们在开发过程中，通常需要查看 ascii 码，通过 Linux 命令行就可以轻松查看，而不用去 Google 或 Baidu</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ man ascii</span><br></pre></td></tr></table></figure>


<h3 id="如何批量下载网页资源"><a href="#如何批量下载网页资源" class="headerlink" title="如何批量下载网页资源"></a>如何批量下载网页资源</h3><p>有时，同事会通过网页的形式分享文件下载链接，在 Linux 系统，通过 wget 命令可以轻松下载，而不用写脚本或爬虫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget -r -nd -np --accept&#x3D;pdf http:&#x2F;&#x2F;fast.dpdk.org&#x2F;doc&#x2F;pdf-guides&#x2F;</span><br><span class="line"># --accept：选项指定资源类型格式 pdf</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>本地Hexo生成的博客部署到VPS</title>
    <url>/2020/01/17/localblog-git-vps/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为了科学上网搭建了vps，顺便跑一下自己的博客，但vps只有500M内存，所以决定本地windows跑hexo生成网页，然后git到vps，记录一下本地和vps的git配置。</p>
<a id="more"></a>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>本地windows安装Node.js hexo git，过程不提。</p>
<h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><p>安装后打开 Git Bash 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的电子邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>由于 Hexo 的 Git 部署不支持使用密码登陆，所以需要配置 SSH 公钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">cd .ssh</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>由此便在系统当前用户文件夹下生成了私钥 id_rsa 和公钥 id_rsa.pub。</p>
<p>在上面建立的.ssh文件中新建config文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">vim config</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host 服务器IP</span><br><span class="line">HostName 服务器IP</span><br><span class="line">User git</span><br><span class="line">Port 端口号</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<h4 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h4><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>打开位于 hexo 文件夹下的 _config.yml，修改 deploy 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@vps的IP:hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="VPS-配置"><a href="#VPS-配置" class="headerlink" title="VPS 配置"></a>VPS 配置</h3><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<h4 id="为用户git添加-sudo-权限"><a href="#为用户git添加-sudo-权限" class="headerlink" title="为用户git添加 sudo 权限"></a>为用户git添加 sudo 权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 &#x2F;etc&#x2F;sudoers</span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>找到以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>添加修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">git     ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>假如是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>则修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL) ALL</span><br><span class="line">git     ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure>
<p>保存,退出</p>
<p>然后修改回文件的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<h4 id="关闭-git-用户-shell-权限"><a href="#关闭-git-用户-shell-权限" class="headerlink" title="关闭 git 用户 shell 权限"></a>关闭 git 用户 shell 权限</h4><p>至此我们可以在本地通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@VPS IP</span><br></pre></td></tr></table></figure>
<p>ssh 连接服务器，登录到服务器上，对服务器进行各种操作，这通常很不安全，也不合适，我们只需要能对仓库操作就可以了，不需要更大的权限。</p>
<p>因此我们关闭 git 用户 shell 权限，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<p>找到git用户的一行：<em>git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</em><br>改为：<em>git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</em></p>
<p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
<h4 id="初始化-git-仓库"><a href="#初始化-git-仓库" class="headerlink" title="初始化 git 仓库"></a>初始化 git 仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git                &#x2F;&#x2F;切换到git用户目录</span><br><span class="line">mkdir blog.git              &#x2F;&#x2F;创建git仓库文件夹，以blog.git为例</span><br><span class="line">cd blog.git                 &#x2F;&#x2F;进入仓库目录</span><br><span class="line">git init --bare             &#x2F;&#x2F;使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区</span><br></pre></td></tr></table></figure>
<p>注意：裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以.git 结尾。</p>
<h4 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git                &#x2F;&#x2F;切换到git用户目录</span><br><span class="line">mkdir .ssh                  &#x2F;&#x2F;创建.ssh目录</span><br><span class="line">cd .ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure>
<p>然后将本地的公钥复制到 authorized_keys 文件里 (公钥即上文生成的公钥，可通过 <em>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</em> 查看)。</p>
<p>注意：收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <em>&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys</em> 文件里，一行一个。</p>
<h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll &#x2F;home&#x2F;git&#x2F;</span><br><span class="line">ll &#x2F;var&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure>
<p>确保 blog.git、.ssh、blog 目录的用户组权限为 git:git，若不是，执行下列命令：</p>
<p>修改用户权限的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R git.git &#x2F;home&#x2F;git&#x2F;blog.git&#x2F;</span><br><span class="line">chown -R git.git &#x2F;home&#x2F;git&#x2F;.ssh&#x2F;</span><br><span class="line">chown -R git.git &#x2F;var&#x2F;www&#x2F;blog&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="配置-Git-Hooks"><a href="#配置-Git-Hooks" class="headerlink" title="配置 Git Hooks"></a>配置 Git Hooks</h4><p>创建 post-receive 文件<br>git 用户下执行（这里由于禁止了git用户shell权限，所以我用 root 用户执行上述命令，然后更改了文件所有者为 git.git）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;git&#x2F;blog.git&#x2F;hooks     &#x2F;&#x2F;切换到hooks目录下</span><br><span class="line">vim post-receive            &#x2F;&#x2F;创建文件</span><br></pre></td></tr></table></figure>
<p>复制下面的内容到 post-receive 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;post-receive hook is running...&quot;</span><br><span class="line"></span><br><span class="line">GIT_REPO&#x3D;&#x2F;home&#x2F;git&#x2F;blog.git</span><br><span class="line">TMP_GIT_CLONE&#x3D;&#x2F;tmp&#x2F;blog</span><br><span class="line">PUBLIC_WWW&#x3D;&#x2F;var&#x2F;www&#x2F;blog</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;&#x2F;*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;&#x2F;* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接将裸仓库克隆到 Web 根目录下呢？我之前也一直被这个问题困扰，感觉先&gt;克隆到 tmp 目录再拷贝到 Web 根目录是多此一举。后来我觉得可能是出于项目安全的&gt;考虑，在执行 cp 命令的时候，.git 作为隐藏目录不会被拷贝到 Web 根目录下，也就&gt;避免了将整个仓库历史暴露在 Web 服务中。</p>
</blockquote>
<p>赋予可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<p>ok，至此配置完毕，可以本地hexo d直接发布到vps了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的html标签应用及常用语法</title>
    <url>/2021/04/19/markdown%E5%86%85%E5%AE%B9%E6%8A%98%E5%8F%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Markdown 是一种轻量级标记语言，非常适合网络书写。同时，Markdown支持嵌入html标签，我们就可以借此实现markdown不具有的某些功能，如代码折叠和文字样式等。</p>
<p><strong><a href="http://connorlin.github.io/2016/05/06/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93)/" target="_blank" rel="noopener">Markdown的常用语法(个人总结) | ConnorLin’s Blog </a></strong></p>
<a id="more"></a>
<h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;</span><br><span class="line">  	&lt;font color&#x3D;&quot;#0000ff&quot; &gt;点击时的区域标题：点击查看详细内容&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;&#x2F;summary&gt;</span><br><span class="line">  &lt;p&gt; - 测试 测试测试&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt;  title，value，callBack可以缺省  &lt;&#x2F;code&gt;  &lt;&#x2F;pre&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>summary：折叠语法展示的摘要</p>
</li>
<li><p>details：折叠语法标签</p>
</li>
<li><p>pre：以原有格式显示元素内的文字是已经格式化的文本。</p>
</li>
<li><p>blockcode：表示程序的代码块。</p>
</li>
<li><p>code：指定代码范例。</p>
</li>
</ul>
<p>效果如下：</p>
<details>
  <summary><font color="#0000ff">点击时的区域标题：点击查看详细内容</font></summary>
  <p> - 测试 测试测试</p>
  <pre><code>  title，value，callBack可以缺省  </code>  </pre>
</details>

<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style&#x3D;&#39;color:red&#39;&gt;This is red&lt;&#x2F;span&gt;   &#x2F;&#x2F;字体颜色</span><br><span class="line">&lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;&#x2F;rt&gt; &lt;&#x2F;ruby&gt; &#x2F;&#x2F; 特殊字</span><br><span class="line">&lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;F9&lt;&#x2F;kbd&gt;  &#x2F;&#x2F; 按键标识</span><br><span class="line">&lt;span style&#x3D;&quot;font-size:2rem; background:yellow;&quot;&gt;**Bigger**&lt;&#x2F;span&gt; &#x2F;&#x2F;字体大小和背景</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot; color&#x3D;&quot;red&quot; size&#x3D;&quot;6&quot;&gt;字体及字体颜色和大小&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;&quot;#0000ff&quot;&gt;字体颜色&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;p align&#x3D;&quot;left&quot;&gt;居左文本&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;center&quot;&gt;居中文本&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;right&quot;&gt;居右文本&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>使用span或者font标签，同时用style属性控制样式。</p>
<p>效果如下：<br><span style="color:red">This is red</span>   &#x2F;&#x2F;字体颜色</p>
<p><ruby> 漢 <rt> ㄏㄢˋ </rt> </ruby> &#x2F;&#x2F; 特殊字</p>
<p><kbd>Ctrl</kbd>+<kbd>F9</kbd>  &#x2F;&#x2F; 按键标识</p>
<p><span style="font-size:2rem; background:yellow;"><strong>Bigger</strong></span> &#x2F;&#x2F;字体大小和背景</p>
<p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font></p>
<p><font color="#0000ff">字体颜色</font></p>
<p align="left">居左文本</p>

<p align="center">居中文本</p>

<p align="right">居右文本</p>

<p>参考来源：<br>**<a href="https://www.cnblogs.com/buwuliao/p/9578918.html" target="_blank" rel="noopener">【MarkDown】使用Html样式和折叠语法</a>**、<br><strong><a href="http://connorlin.github.io/2016/05/06/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93)/" target="_blank" rel="noopener">Markdown的常用语法(个人总结) | ConnorLin’s Blog </a></strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2021/04/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>linux常用的命令，随时添加。</p>
<a id="more"></a>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>The type command is used to display information about the command type. It will show you how a given command would be interpreted if typed on the command line.<br>一般情况下，type命令被用于判断另外一个命令是否是内置命令，但是它实际上有更多的用法。  </p>
<ol>
<li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是：</p>
<blockquote>
<p>type ls 的输出是 ls 是 `ls –color&#x3D;auto&#39; 的别名</p>
</blockquote>
<blockquote>
<p>type if 的输出是 if 是 shell 关键字</p>
</blockquote>
<blockquote>
<p>type type 的输出是 type 是 shell 内嵌</p>
</blockquote>
<blockquote>
<p>type frydsh 的输出是 bash: type: frydsh: 未找到</p>
</blockquote>
</li>
<li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是的另一种方法（适用于脚本编程）：</p>
<blockquote>
<p>type -t ls 的输出是 alias</p>
</blockquote>
<blockquote>
<p>type -t if 的输出是 keyword</p>
</blockquote>
<blockquote>
<p>type -t type 的输出是 builtin</p>
</blockquote>
<blockquote>
<p>type -t gedit 的输出是 file</p>
</blockquote>
<blockquote>
<p>type -t frydsh 没有输出</p>
</blockquote>
</li>
<li><p>显示一个名字的所有可能：</p>
<blockquote>
<p>type -a kill 的输出是 kill 是 shell 内嵌 和 kill 是 &#x2F;bin&#x2F;kill</p>
</blockquote>
<blockquote>
<p>type -at kill 的输出是 builtin 和 file</p>
</blockquote>
</li>
<li><p>查看一个命令的执行路径（如果它是外部命令的话）：</p>
<blockquote>
<p>type -p gedit 的输出是 &#x2F;usr&#x2F;bin&#x2F;gedit</p>
</blockquote>
<blockquote>
<p>type -p kill 没有输出（因为kill是内置命令）</p>
</blockquote>
</li>
<li><p>强制搜索外部命令：</p>
<blockquote>
<p>type -P kill 的输出是 &#x2F;bin&#x2F;kill</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="ll-amp-ls"><a href="#ll-amp-ls" class="headerlink" title="ll&amp;ls"></a>ll&amp;ls</h3><p>ll is aliased to &#39;ls -alF&#39;<br><img src="/images/pasted-35.png" alt="upload successful"></p>
<p>ls 几个重要参数：</p>
<ul>
<li>-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li>
<li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>
<li>-r 将文件以相反次序显示(原定依英文字母次序)</li>
<li>-t 将文件依建立时间之先后次序列出</li>
<li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li>
<li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li>
<li>-R 若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
<p>详细参数ls –help 查看。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>
<p>查看，其中-S sort by file size</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -Sl 由大到小排序</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -Slr 从小到大排序</span><br></pre></td></tr></table></figure>
<p>-h，表示”–human-readable”，单位是k或者M ，比较容易看清楚结果。</p>
<p>显示子目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -R</span><br></pre></td></tr></table></figure>
<p>ls按时间排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lt 从新到旧</span><br><span class="line">ls -lrt 从旧到新</span><br></pre></td></tr></table></figure>

<p>参考：**<u><a href="https://linux.cn/article-5109-1.html" target="_blank" rel="noopener">Linux中的15个基本‘ls’命令示例</a></u>**</p>
<hr>
<h3 id="xdg-open"><a href="#xdg-open" class="headerlink" title="xdg-open"></a>xdg-open</h3><p>有时需要从terminal打开doc pdf jpg等文件，可以用xdg-open命令。</p>
<p>xdg-open command in the Linux system is used to open a file or URL in the user’s preferred application.<br>The URL will be opened in the user’s preferred web browser if a URL is provided. The file will be opened in the preferred application for files of that type if a file is provided. xdg-open supports ftp, file, https and http URLs. This can be used inside a desktop session only. It is not recommended to use xdg-open as root. Here, the zero is an indication of success while non-zero show the failure.</p>
<p>Syntax:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xdg-open &#123;file | URL&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sort-uniq"><a href="#sort-uniq" class="headerlink" title="sort uniq"></a>sort uniq</h3><p>字如其义：排序和去重</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>sort</strong> - sort lines of text files(对文本文件的行进行排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将它们按升序输出。</span><br></pre></td></tr></table></figure>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<p><strong>OPTION:</strong></p>
<ul>
<li>-b, –ignore-leading-blanks ignore leading blanks</li>
<li>-d, –dictionary-order consider only blanks and alphanumeric characters</li>
<li>-f, –ignore-case fold lower case to upper case characters</li>
<li>-g, –general-numeric-sort compare according to general numerical value</li>
<li>-i, –ignore-nonprinting consider only printable characters</li>
<li>-M, –month-sort compare (unknown) &lt; <code>JAN&#39; &lt; ... &lt; </code>DEC’</li>
<li>-n, –numeric-sort compare according to string numerical value</li>
<li>-r, –reverse reverse the result of comparisons</li>
</ul>
<p><strong>Other option:</strong></p>
<ul>
<li>-c, –check check whether input is sorted; do not sort</li>
<li>-k, –key&#x3D;POS1[,POS2] start a key at POS1, end it at POS2 (origin 1)</li>
<li>-m, –merge merge already sorted files; do not sort</li>
<li>-o, –output&#x3D;FILE write result to FILE instead of standard output</li>
<li>-s, –stable stabilize sort by disabling last-resort comparison</li>
<li>-S, –buffer-size&#x3D;SIZE use SIZE for main memory buffer</li>
<li>-t, –field-separator&#x3D;SEP use SEP instead of non-blank to blank transition</li>
<li>-T, –temporary-directory&#x3D;DIR use DIR for temporaries, not $TMPDIR or&#x2F;tmp;<br>multiple options specify multiple directories</li>
<li>-u, –unique with -c, check for strict ordering;<br>without -c, output only the first of an equal run</li>
<li>-z, –zero-terminated end lines with 0 byte, not newline</li>
<li>–help 显示此帮助信息并退出</li>
<li>–version 输出版本号信息并退出</li>
</ul>
<h4 id="sort的-o选项"><a href="#sort的-o选项" class="headerlink" title="sort的-o选项"></a>sort的-o选项</h4><p>由于sort默认是把结果输出到标准输出，所以需要用重定向才能将结果写入文件，形如sort oldfile &gt; newfile<br>但是，如果你想把排序结果输出到原文件中，用重定向可就不行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ericshenMacPro@root duweixin]$ sort -r duweixin.txt &gt; duweixin.txt</span><br><span class="line">[ericshenMacPro@root duweixin]$ cat duweixin.txt</span><br><span class="line">[ericshenMacPro@root duweixin]$</span><br></pre></td></tr></table></figure>
<p>看，竟然将duweixin清空了。</p>
<p>加上-o选项，解决了这个问题，让你放心的将结果写入原文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ericshenMacPro@root duweixin]$ cat number.txt</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">[ericshenMacPro@root duweixin]$ sort -r number.txt -o number.txt</span><br><span class="line">[ericshenMacPro@root duweixin]$ cat number.txt</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="sort的-t选项和-k选项"><a href="#sort的-t选项和-k选项" class="headerlink" title="sort的-t选项和-k选项"></a>sort的-t选项和-k选项</h4><p>如果有一个文件的内容是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ericshenMacPro@root duweixin]$ cat facebook.txt</span><br><span class="line">banana:30:5.5</span><br><span class="line">apple:10:2.5</span><br><span class="line">pear:90:2.3</span><br><span class="line">orange:20:3.4</span><br></pre></td></tr></table></figure>
<p>这个文件有三列，列与列之间用冒号隔开了，第一列表示水果类型，第二列表示水果数量，第三列表示水果价格。</p>
<p>那么我想以水果数量来排序，也就是以第二列来排序，如何利用sort实现？</p>
<p>幸好，sort提供了-t选项，后面可以设定间隔符。（是不是想起了cut和paste的-d选项，共鸣～～）</p>
<p>指定了间隔符之后，就可以用-k来指定列数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ericshenMacPro@root duweixin]$ sort -n -k 2 -t : facebook.txt</span><br><span class="line">apple:10:2.5</span><br><span class="line">orange:20:3.4</span><br><span class="line">banana:30:5.5</span><br><span class="line">pear:90:2.3</span><br></pre></td></tr></table></figure>
<p>我们使用冒号作为间隔符，并针对第二列来进行数值升序排序，结果很令人满意。</p>
<p>有时候学习脚本，你会发现sort命令后面跟了一堆类似-k1,2，或者-k1.2<br>-k3.4的东东，有些匪夷所思。今天，我们就来搞定它—-k选项！</p>
<h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>一、准备素材</p>
<p>第一个域是公司名称，第二个域是公司人数，第三个域是员工平均工资。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat duweixin.net.txt</span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br></pre></td></tr></table></figure>
<p>二、 我想让这个文件按公司的字母顺序排序，也就是按第一个域进行排序：（这个duweixin.net.txt文件有三个域）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -t ‘ ‘ -k 1 duweixin.net.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br></pre></td></tr></table></figure>
<p>就直接用-k 1设定就可以了。（其实此处并不严格，稍后你就会知道）</p>
<p>三、我想让duweixin.net.txt按照公司人数排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -n -t ‘ ‘ -k 2 duweixin.net.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure>
<p>但是，此处出现了问题，那就是baidu和sohu的公司人数相同，都是100人，这个时候怎么办呢？按照默认规矩，是从第一个域开始进行升序排序，因此baidu排在了sohu前面。</p>
<p>四、我想让facebook.txt按照公司人数排序 ，人数相同的按照员工平均工资升序排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -n -t ‘ ‘ -k 2 -k 3 duweixin.net.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure>
<p>加了一个-k2 -k3就解决了问题。对滴，sort支持这种设定，就是说设定域排序的优先级，先以第2个域进行排序，如果相同，再以第3个域进行排序。</p>
<p>五、我想让facebook.txt按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -n -t ‘ ‘ -k 3r -k 2 duweixin.net.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>此处有使用了一些小技巧，你仔细看看，在-k 3后面偷偷加上了一个小写字母r。你想想，再结合我们上一篇文章，能得到答案么？揭晓：r和-r选项的作用是一样的，就是表示逆序。因为sort默认是按照升序排序的，所以此处需要加上r表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序，举个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -t ‘ ‘ -k 3nr -k 2n duweixin.net.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F&#39;|&#39; &#39;&#123;print $2&#125;&#39; nginx_access.log | uniq -c  | sort -n -r | head -n 10   #查询访问次数前10的ip地址。uniq -c 表示统计各行在文件中出现的次数</span><br><span class="line">   2582 120.26.40.76</span><br><span class="line">    826 120.26.40.76</span><br><span class="line">    716 120.26.40.76</span><br><span class="line">    525 120.26.40.76</span><br><span class="line">    424 120.26.40.76</span><br><span class="line">    325 120.26.40.76</span><br><span class="line">    235 120.26.40.76</span><br><span class="line">    233 120.26.40.76</span><br><span class="line">    226 120.26.40.76</span><br><span class="line">    120 120.26.40.76</span><br></pre></td></tr></table></figure>




<p>参考：**<a href="https://segmentfault.com/a/1190000005713784" target="_blank" rel="noopener">linux sort 多列正排序，倒排序</a>**</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p><strong>uniq</strong> - report or omit repeated lines(报告或省略重复的行)</p>
<p>描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq 命令删除文件中的重复行。uniq 命令读取由 InFile 参数指定的标准输入或文件。该命令首先比较相邻的行，然后除去第二行和该行的后续副本。重复的行一定相邻。（在发出 uniq 命令之前，请使用 sort 命令使所有重复行相邻。uniq命令这种方式估计是想节省系统资源）最后，uniq 命令将最终单独的行写到标准输出或由 OutFile 参数指定的文件。InFile 和 OutFile 参数必须指定不同的文件。</span><br></pre></td></tr></table></figure>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [InFile [OutFile]]</span><br></pre></td></tr></table></figure>
<p><strong>OPTION:</strong></p>
<ul>
<li>-c :在输出行前面加上每行在文件中出现的次数</li>
<li>-d :仅显示重复行</li>
<li>-u :仅显示不重复的行</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat fruit.txt </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">apple</span><br><span class="line">$ uniq fruit.txt  #可以看到apple不是邻近的，所以无法去重</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">apple</span><br><span class="line">$ uniq -d fruit.txt   </span><br><span class="line">$</span><br><span class="line">$ sort fruit.txt   #先排序，将相同的行安排在一起</span><br><span class="line">apple</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange    </span><br><span class="line">$ sort fruit.txt | uniq  #排序后，去重</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ awk -F&#39;|&#39; &#39;&#123;print $2&#125;&#39;nginx_access.log | sort -n  |uniq -c | sort -n | tail -n 10     #只有先sort后在uniq才能生效</span><br><span class="line">     28 122.192.13.58</span><br><span class="line">     31 183.212.188.57</span><br><span class="line">     31 223.104.4.82</span><br><span class="line">     35 223.104.4.61</span><br><span class="line">     36 112.20.81.240</span><br><span class="line">     71 183.209.48.38</span><br><span class="line">     86 122.96.43.243</span><br><span class="line">    216 183.208.16.53</span><br><span class="line">    616 49.77.231.174</span><br><span class="line">   6268 120.26.40.76</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>uniq必须得和sort一起使用才能够达到所需要的结果。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><strong><a href="https://www.linuxjournal.com/content/back-basics-sort-and-uniq" target="_blank" rel="noopener">Back to Basics: Sort and Uniq</a></strong></p>
<hr>
<h3 id="tar-amp-gzip"><a href="#tar-amp-gzip" class="headerlink" title="tar&amp;gzip"></a>tar&amp;gzip</h3><p>Linux下常见的压缩包格式有5种:zip tar.gz tar.bz2 tar.xz tar.Z</p>
<p>其中tar是种打包格式,gz和bz2等后缀才是指代压缩方式:gzip和bzip2。</p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>The Linux “tar” stands for tape archive, which is used by large number of Linux&#x2F;Unix system administrators to deal with tape drives backup. </p>
<p><strong>OPTION:</strong></p>
<ul>
<li>c – create a archive file.</li>
<li>x – extract a archive file.</li>
<li>v – show the progress of archive file.</li>
<li>f – filename + of archive file.</li>
<li>t – viewing content of archive file.</li>
<li>j  – filter archive through bzip2.</li>
<li>z – filter archive through gzip.</li>
<li>r – append or update files or directories to existing archive file.</li>
<li>W – Verify a archive file.</li>
<li>wildcards – Specify patterns in unix tar command.</li>
</ul>
<p>其中j,z参数代表在压缩时需要注意选择压缩格式。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Create tar Archive File</span><br><span class="line"></span><br><span class="line"> tar -cvf tecmint-14-09-12.tar &#x2F;home&#x2F;tecmint&#x2F;</span><br><span class="line"> </span><br><span class="line">2. Create tar.gz Archive File</span><br><span class="line"></span><br><span class="line">tar cvzf MyImages-14-09-12.tar.gz &#x2F;home&#x2F;MyImages</span><br><span class="line"></span><br><span class="line">3. Create tar.bz2 Archive File</span><br><span class="line"></span><br><span class="line"> tar cvfj Phpfiles-org.tar.bz2 &#x2F;home&#x2F;php</span><br></pre></td></tr></table></figure>

<p>事实上, <span style="color:red">从1.15版本开始tar就可以自动识别压缩的格式</span>,故不需人为区分压缩格式就能正确解压或者查看里面的内容。如解压文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf filename.tar</span><br><span class="line">tar -xvf filename.tar.gz  </span><br><span class="line">tar -xvf filename.tar.bz2  </span><br><span class="line">tar -xvf filename.tar.xz  </span><br><span class="line">tar -xvf filename.tar.Z</span><br></pre></td></tr></table></figure>
<p>抑或查看打包内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -tvf filename.tar</span><br><span class="line">tar -tvf filename.tar.gz  </span><br><span class="line">tar -tvf filename.tar.bz2  </span><br><span class="line">tar -tvf filename.tar.xz  </span><br><span class="line">tar -tvf filename.tar.Z</span><br></pre></td></tr></table></figure>
<h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>Gzip is one of the most popular compression algorithms that allow you to reduce the size of a file and keep the original file mode, ownership, and timestamp.</p>
<p>Gzip also refers to the .gz file format and the gzip utility which is used to compress and decompress files.</p>
<p>In this tutorial, we will show you how to use the gzip command.</p>
<h5 id="gzip-Command-Syntax"><a href="#gzip-Command-Syntax" class="headerlink" title="gzip Command Syntax"></a>gzip Command Syntax</h5><p>The general syntax for the gzip command is as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<p>Gzip compresses only single files and creates a compressed file for each given file. By convention, the name of a file compressed with Gzip should end with either .gz or .z.</p>
<p>If you want to compress multiple files or directory into one file, first you need to create a Tar archive and then compress the .tar file with Gzip. A file that ends in .tar.gz or .tgz is a Tar archive compressed with Gzip.</p>
<p>Gzip is most often used to compress text files, Tar archives, and web pages. <span style="color:red">Do not use Gzip to compress images, audio, PDF documents, and other binary files as they are already compressed</span>.</p>
<p><em>gzip</em> can compress only regular files. The <em>symbolic links</em> are ignored.</p>
<h5 id="Compressing-Files-with-gzip"><a href="#Compressing-Files-with-gzip" class="headerlink" title="Compressing Files with gzip"></a>Compressing Files with gzip</h5><p>To compress a single file invoke the gzip command followed by the filename:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip filename</span><br></pre></td></tr></table></figure>

<p>gzip will create a file filename.gz and delete the original file.</p>
<p>By default, gzip keeps the original file timestamp, mode, ownership, and name in the compressed file.</p>
<p>Keep the original file<br>If you want to keep the input (original) file, use the -k option:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -k filename</span><br></pre></td></tr></table></figure>
<p>Another option to keep the original file is to use the -c option which tells gzip to write on standard output and redirect the output to a file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -c filename &gt; filename.gz</span><br></pre></td></tr></table></figure>
<h5 id="Verbose-output"><a href="#Verbose-output" class="headerlink" title="Verbose output"></a>Verbose output</h5><p>Use the -v option if you want to see the percentage reduction and the names of the files that are being processed:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -v filename</span><br></pre></td></tr></table></figure>
<p>filename:      7.5% – replaced with filename.gz</p>
<h5 id="Compress-multiple-files"><a href="#Compress-multiple-files" class="headerlink" title="Compress multiple files"></a>Compress multiple files</h5><p>You can also pass multiple files as arguments to the command. For example, to compress the files named file1, file2, file3, you would run the following command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>The command above will create three compressed files, file1.gz, file2.gz, file3.gz.</p>
<h5 id="Compress-all-files-in-a-directory"><a href="#Compress-all-files-in-a-directory" class="headerlink" title="Compress all files in a directory"></a>Compress all files in a directory</h5><p>To compress all files in a given directory, use the -r option:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -r directory</span><br></pre></td></tr></table></figure>
<p><em>gzip</em> will recursively traverse through the whole directory structure and compress all the files in the directory and it’s subdirectories.</p>
<h5 id="Change-the-compression-level"><a href="#Change-the-compression-level" class="headerlink" title="Change the compression level"></a>Change the compression level</h5><p>gzip allows you to specify a range of compression levels, from 1 to 9. -1 or –fast means fastest compression speed with minimal compression ratio, -9 or –best indicates the slowest compression speed with maximum compression ratio. The default compression level is -6.</p>
<p>For example, to get maximum compression, you would run:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -9 filename</span><br></pre></td></tr></table></figure>
<p>Compression is a CPU-intensive task, the higher the compression level, the longer the process takes.</p>
<h5 id="Using-standard-input"><a href="#Using-standard-input" class="headerlink" title="Using standard input"></a>Using standard input</h5><p>To create a .gz file from the stdin, pipe the output of the command to gzip. For example, to create a Gzipped MySQL database backup you would run:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump database_name | gzip -c &gt; database_name.sql.gz</span><br></pre></td></tr></table></figure>
<p>The output of the mysqldump command will be input for gzip.</p>
<h5 id="Decompressing-Files-with-gzip"><a href="#Decompressing-Files-with-gzip" class="headerlink" title="Decompressing Files with gzip"></a>Decompressing Files with gzip</h5><p>To decompress a .gz file , use the -d option:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d filename.gz</span><br></pre></td></tr></table></figure>
<p>Another command that you can use to decompress a Gzip file is gunzip . This command is basically an alias to gzip -d:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunzip filename.gz</span><br></pre></td></tr></table></figure>
<p>You might find it easier to remember gunzip than gzip -d.</p>
<h5 id="Keep-the-compressed-file"><a href="#Keep-the-compressed-file" class="headerlink" title="Keep the compressed file"></a>Keep the compressed file</h5><p>Same as when compressing a file, the -k option tells gzip to keep the input file, in this case, that is the compressed file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -dk filename.gz</span><br></pre></td></tr></table></figure>
<h5 id="Decompress-multiple-files"><a href="#Decompress-multiple-files" class="headerlink" title="Decompress multiple files"></a>Decompress multiple files</h5><p>To decompress multiple files at once pass the filenames to gzip as arguments:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d file1.gz file2.gz file3.gz</span><br></pre></td></tr></table></figure>
<h5 id="Decompress-all-files-in-a-directory"><a href="#Decompress-all-files-in-a-directory" class="headerlink" title="Decompress all files in a directory"></a>Decompress all files in a directory</h5><p>When used with -d and -r options, gzip decompresses all files in a given directory recursively:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -dr directory</span><br></pre></td></tr></table></figure>
<h5 id="List-the-Compressed-File-Contents"><a href="#List-the-Compressed-File-Contents" class="headerlink" title="List the Compressed File Contents"></a>List the Compressed File Contents</h5><p>When used with the -l option, gzip shows statistics about the given compressed files:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -l filename</span><br></pre></td></tr></table></figure>
<p>The output will include the uncompressed file name, the compressed and uncompressed size, and the compression ratio:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">       130                 107   7.5% filename</span><br></pre></td></tr></table></figure>
<p>To get more information, add the -v option:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -lv filename</span><br><span class="line">method  crc     date  time           compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">defla a9b9e776 Sep  3 21:20                 130                 107   7.5% filename</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="du-amp-df"><a href="#du-amp-df" class="headerlink" title="du&amp;df"></a>du&amp;df</h3><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>du command (short for disk usage) is useful command which is used to find disk usage for files &amp; directories. du command when used with various options provides results in many formats.</p>
<p><strong>Syntax :</strong>  </p>
<blockquote>
<p>du [OPTION]… [FILE]…<br>du [OPTION]… –files0-from&#x3D;F</p>
</blockquote>
<p><strong>Options :</strong></p>
<blockquote>
<ul>
<li>-0, –null : end each output line with NULL</li>
<li>-a, –all : write count of all files, not just directories</li>
<li>–apparent-size&gt; : print apparent sizes, rather than disk usage.</li>
<li>-B, –block-s&gt;ize&gt;&#x3D;SIZE : scale sizes to SIZE before printing on console</li>
<li>-c, –total : pro&gt;duce grand total</li>
<li>-d, –max-depth&#x3D;N :   print the total for a directory (or file, with –all) only if it is N or fewer levels below the command line argument;  –max-depth&#x3D;0 is the same as –summarize</li>
<li>-h, –human-readable : print sizes in human readable format</li>
<li>-S, -separate-dirs : for directories, don’t include size of subdirectories</li>
<li>-s, –summarize : display only total for each directory</li>
<li>–time : show time of last modification of any file or directory.</li>
<li>–exclude&#x3D;PATTERN : exclude files that match PATTERN</li>
</ul>
</blockquote>
<p>Some of the examples are mentioned below:-</p>
<ol>
<li><p>To find out summary of disk usage for a directory with all its sub-directories</p>
<p> $ du &#x2F;hexo</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:&#x2F;mnt&#x2F;Secert&#x2F;hexo$ du &#x2F;var</span><br><span class="line">4	&#x2F;var&#x2F;lib&#x2F;misc</span><br><span class="line">44	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;yaml</span><br><span class="line">240	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main&#x2F;64x64</span><br><span class="line">132	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main&#x2F;48x48</span><br><span class="line">376	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main</span><br></pre></td></tr></table></figure>
<p>Output of the command shows all the files &amp; directories in &#x2F;home with block size.</p>
<ol start="2">
<li><p>Disk usage with file&#x2F;directory sizes in human readable format I.e. in kb, mb etc</p>
<p> $ du -h &#x2F;var</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:&#x2F;mnt&#x2F;Secert&#x2F;hexo$ du -h &#x2F;var</span><br><span class="line">4.0K	&#x2F;var&#x2F;lib&#x2F;misc</span><br><span class="line">44K	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;yaml</span><br><span class="line">240K	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main&#x2F;64x64</span><br><span class="line">132K	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main&#x2F;48x48</span><br><span class="line">376K	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-main</span><br><span class="line">8.0K	&#x2F;var&#x2F;lib&#x2F;app-info&#x2F;icons&#x2F;ubuntu-bionic-updates-multiverse&#x2F;64x64</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>Total disk size of a directory</p>
<p> $ du -s &#x2F;home&#x2F;zzl</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:&#x2F;$ du -s &#x2F;home&#x2F;zzl&#x2F;</span><br><span class="line">8572584	&#x2F;home&#x2F;zzl&#x2F;</span><br><span class="line">zzl@zzl-J:&#x2F;$ du -sh &#x2F;home&#x2F;zzl&#x2F;</span><br><span class="line">8.2G	&#x2F;home&#x2F;zzl&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>To print sizes till particular level, use -d option with level no.<br> $ du -d 1 &#x2F;home&#x2F;zzl<br> or du –maxdepth&#x3D;1 &#x2F;home&#x2F;zzl</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:&#x2F;$ du -d 1 &#x2F;home&#x2F;zzl&#x2F;</span><br><span class="line">136	&#x2F;home&#x2F;zzl&#x2F;.m2</span><br><span class="line">2635600	&#x2F;home&#x2F;zzl&#x2F;.local</span><br><span class="line">868	&#x2F;home&#x2F;zzl&#x2F;snap</span><br><span class="line">8	&#x2F;home&#x2F;zzl&#x2F;.pip</span><br></pre></td></tr></table></figure>
<p>Now try with level 2, you will get some extra directories.<br>    $ du -d 2 &#x2F;home&#x2F;zzl<br>    or du –maxdepth&#x3D;2 &#x2F;home&#x2F;zzl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:&#x2F;$ du -d 2 &#x2F;home&#x2F;zzl&#x2F;</span><br><span class="line">132	&#x2F;home&#x2F;zzl&#x2F;.m2&#x2F;repository</span><br><span class="line">136	&#x2F;home&#x2F;zzl&#x2F;.m2</span><br><span class="line">65548	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;lib</span><br><span class="line">1695880	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;idea-IU-203.7717.56</span><br><span class="line">32	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;bin</span><br><span class="line">100756	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;Telegram</span><br><span class="line">636576	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;share</span><br><span class="line">48	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;etc</span><br><span class="line">136756	&#x2F;home&#x2F;zzl&#x2F;.local&#x2F;redis-6.2.1</span><br><span class="line">2635600	&#x2F;home&#x2F;zzl&#x2F;.local</span><br><span class="line">320	&#x2F;home&#x2F;zzl&#x2F;snap&#x2F;gnome-system-monitor</span><br></pre></td></tr></table></figure>

<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>The df command (short for disk free), is used to display information related to file systems about total space and available space.</p>
<p><strong>Syntax :</strong></p>
<blockquote>
<p>df [OPTION]… [FILE]…  </p>
</blockquote>
<p><strong>Options :</strong></p>
<blockquote>
<ul>
<li>-a, –all : includes pseudo, duplicate and inaccessible file systems.</li>
<li>-B, –block-size&#x3D;SIZE : scales sizes by SIZE before printing them.</li>
<li>-h, –human-readable : print sizes in power of 1024</li>
<li>-H, –si: print sizes in power of 1000</li>
<li>-i, –inodes : list inode information instead of block usage</li>
<li>-l, –local : limit listing to local file systems</li>
<li>-P, –portability : use POSIX output format</li>
<li>–sync : invoke sync before getting usage info</li>
<li>–total : elide all entries insignificant to available space, and produce grand total</li>
<li>-t, –type&#x3D;TYPE : limit listing to file systems of type TYPE</li>
<li>-T, –print-type : print file system type</li>
</ul>
</blockquote>
<p>If no file name is given, it displays the space available on all currently mounted file systems.<br>For example :</p>
<p>df<br>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:~$ df</span><br><span class="line">Filesystem     1K-blocks      Used Available Use% Mounted on</span><br><span class="line">udev             3998520         0   3998520   0% &#x2F;dev</span><br><span class="line">tmpfs             804612      2108    802504   1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p7  33203920  13543756  17943788  44% &#x2F;</span><br><span class="line">tmpfs            4023048    710744   3312304  18% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs               5120         4      5116   1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            4023048         0   4023048   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;loop0        261760    261760         0 100% &#x2F;snap&#x2F;gnome-3-34-1804&#x2F;36</span><br><span class="line">&#x2F;dev&#x2F;loop2         66688     66688         0 100% &#x2F;snap&#x2F;gtk-common-themes&#x2F;1515</span><br><span class="line">&#x2F;dev&#x2F;loop3          1024      1024         0 100% &#x2F;snap&#x2F;gnome-logs&#x2F;100</span><br><span class="line">&#x2F;dev&#x2F;loop1         56832     56832         0 100% &#x2F;snap&#x2F;core18&#x2F;1988</span><br><span class="line">&#x2F;dev&#x2F;loop4           384       384         0 100% &#x2F;snap&#x2F;gnome-characters&#x2F;570</span><br><span class="line">&#x2F;dev&#x2F;loop7          2304      2304         0 100% &#x2F;snap&#x2F;gnome-system-monitor&#x2F;148</span><br><span class="line">&#x2F;dev&#x2F;loop6        101632    101632         0 100% &#x2F;snap&#x2F;core&#x2F;10908</span><br><span class="line">&#x2F;dev&#x2F;loop5         33152     33152         0 100% &#x2F;snap&#x2F;snapd&#x2F;11588</span><br><span class="line">&#x2F;dev&#x2F;loop8        101632    101632         0 100% &#x2F;snap&#x2F;core&#x2F;10958</span><br><span class="line">&#x2F;dev&#x2F;loop9           640       640         0 100% &#x2F;snap&#x2F;gnome-logs&#x2F;103</span><br><span class="line">&#x2F;dev&#x2F;loop10         2304      2304         0 100% &#x2F;snap&#x2F;gnome-system-monitor&#x2F;157</span><br><span class="line">&#x2F;dev&#x2F;loop13         2560      2560         0 100% &#x2F;snap&#x2F;gnome-calculator&#x2F;884</span><br><span class="line">&#x2F;dev&#x2F;loop11       224256    224256         0 100% &#x2F;snap&#x2F;gnome-3-34-1804&#x2F;66</span><br><span class="line">&#x2F;dev&#x2F;loop12        63616     63616         0 100% &#x2F;snap&#x2F;gtk-common-themes&#x2F;1506</span><br><span class="line">&#x2F;dev&#x2F;loop14        56832     56832         0 100% &#x2F;snap&#x2F;core18&#x2F;1997</span><br><span class="line">&#x2F;dev&#x2F;loop15          384       384         0 100% &#x2F;snap&#x2F;gnome-characters&#x2F;708</span><br><span class="line">&#x2F;dev&#x2F;loop16        33152     33152         0 100% &#x2F;snap&#x2F;snapd&#x2F;11402</span><br><span class="line">&#x2F;dev&#x2F;loop17         2560      2560         0 100% &#x2F;snap&#x2F;gnome-calculator&#x2F;748</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p1    262144     36868    225276  15% &#x2F;boot&#x2F;efi</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p8  34464424   8620596  24063400  27% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;sda2      244073468 183912216  60161252  76% &#x2F;mnt&#x2F;Workspace</span><br><span class="line">&#x2F;dev&#x2F;sda1      244308988 193341424  50967564  80% &#x2F;mnt&#x2F;Secert</span><br><span class="line">tmpfs             804608        16    804592   1% &#x2F;run&#x2F;user&#x2F;121</span><br><span class="line">tmpfs             804608        28    804580   1% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">overlay         33203920  13543756  17943788  44% &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;de94e0676e57477d87aba630ff494dd43ad714de367cf5031e544f25bb613f64&#x2F;merged</span><br></pre></td></tr></table></figure>
<p><strong>df usage Examples with options :</strong></p>
<ol>
<li><p>If you want to display all the file system, use -a option.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -a</span><br></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzl@zzl-J:~$ df -a</span><br><span class="line">Filesystem     1K-blocks      Used Available Use% Mounted on</span><br><span class="line">sysfs                  0         0         0    - &#x2F;sys</span><br><span class="line">proc                   0         0         0    - &#x2F;proc</span><br><span class="line">udev             3998520         0   3998520   0% &#x2F;dev</span><br><span class="line">devpts                 0         0         0    - &#x2F;dev&#x2F;pts</span><br><span class="line">tmpfs             804612      2108    802504   1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;nvme0n1p7  33203920  13543884  17943660  44% &#x2F;</span><br><span class="line">securityfs             0         0         0    - &#x2F;sys&#x2F;kernel&#x2F;security</span><br><span class="line">tmpfs            4023048    705236   3317812  18% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs               5120         4      5116   1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            4023048         0   4023048   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">cgroup                 0         0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;unified</span><br><span class="line">cgroup                 0         0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd</span><br><span class="line">pstore                 0         0         0    - &#x2F;sys&#x2F;fs&#x2F;pstore</span><br><span class="line">efivarfs               0         0         0    - &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars</span><br><span class="line">cgroup                 0         0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct</span><br></pre></td></tr></table></figure>
<p>The above is not complete output, but you can see that the information shown is extended to info provided by df command.</p>
</li>
<li><p>Use -h option to display size in power of 1024</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h &#x2F;home&#x2F;mandeep</span><br></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda10       76G   65G  7.0G  91% &#x2F;home</span><br></pre></td></tr></table></figure></li>
<li><p>Use -H option to display sizes in power of 1000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -H &#x2F;home&#x2F;mandeep</span><br></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda10       81G   70G  7.5G  91% &#x2F;home</span><br></pre></td></tr></table></figure>
<p>You can observe the size section of two command with -h and -H option for difference.</p>
</li>
<li><p>To get complete grand total, use –total option</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df --total</span><br></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">udev             3996816        0   3996816   0% &#x2F;dev</span><br><span class="line">tmpfs             804624    10072    794552   2% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sda9       68117056 18036336  46597536  28% &#x2F;</span><br><span class="line">tmpfs            4023116    50140   3972976   2% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs               5120        4      5116   1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs            4023116        0   4023116   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;loop0         88832    88832         0 100% &#x2F;snap&#x2F;simplescreenrecorder&#x2F;1</span><br><span class="line">&#x2F;dev&#x2F;loop2         85888    85888         0 100% &#x2F;snap&#x2F;core&#x2F;3748</span><br><span class="line">&#x2F;dev&#x2F;loop3         85888    85888         0 100% &#x2F;snap&#x2F;core&#x2F;3604</span><br><span class="line">&#x2F;dev&#x2F;loop1         83328    83328         0 100% &#x2F;snap&#x2F;core&#x2F;3887</span><br><span class="line">&#x2F;dev&#x2F;sda10      78873504 67529320   7314540  91% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;sda1         507904    30908    476996   7% &#x2F;boot&#x2F;efi</span><br><span class="line">tmpfs             804624       12    804612   1% &#x2F;run&#x2F;user&#x2F;121</span><br><span class="line">tmpfs             804624       64    804560   1% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">total          162304440 86000792  68790820  56% -</span><br></pre></td></tr></table></figure>
<p>Observe the last row of above table output, it specifies grand total.</p>
</li>
<li><p>Use -T option to display file type<br>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -T &#x2F;home&#x2F;mandeep</span><br></pre></td></tr></table></figure>
<p>Output :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem     Type 1K-blocks     Used Available Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda10     ext4  78873504 67528128   7315732  91% &#x2F;home</span><br></pre></td></tr></table></figure>
<p>You can see the file type for &#x2F;home&#x2F;mandeep is ext4.</p>
</li>
<li><p>And for more help, you can use –help option.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df --help</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis mysql in (#{list}) 只能查询/删除第一条的问题</title>
    <url>/2021/12/30/mybatis-mysql-in-list-%E5%8F%AA%E8%83%BD%E6%9F%A5%E8%AF%A2-%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%9D%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/do-your-best/p/9513194.html" target="_blank" rel="noopener">mysql in (#{list}) 只能查询&#x2F;删除第一条的问题</a></p>
]]></content>
  </entry>
  <entry>
    <title>netstat 命令</title>
    <url>/2022/02/15/netstat-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntu|awk &#39;&#123;pring $5&#125;&#39;|cut -d : -f 1|sort|uniq -c</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>-n 显示数字IP, -t tcp连接, -u udp连接, -a 全部连接…</p>
<p><strong><a href="https://blog.csdn.net/qq_42014600/article/details/90372315" target="_blank" rel="noopener">netstat详解</a></strong></p>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>-F 指定分割符(如 awk -F: ), 如不显示指定字段分隔符，awk的默认字段分隔符为任意空白字符，包括制表符、空格符、换行符等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$0表示整行文本</span><br><span class="line">$1表示文本行中第一个数据字段</span><br><span class="line">$2表示文本行中第二个数据字段</span><br><span class="line">$n表示文本行中第n个数据字段</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://blog.csdn.net/u010502101/article/details/81839519" target="_blank" rel="noopener">awk详解</a></strong></p>
<h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>cut -[n]b file</p>
<p>cut -c file</p>
<p>cut -d[分隔符] -f[域] file</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b(bytes) ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</span><br><span class="line">-c(characters) ：以字符为单位进行分割。</span><br><span class="line">-d ：自定义分隔符，默认为制表符。</span><br><span class="line">-f(filed) ：与-d一起使用，指定显示哪个区域。</span><br><span class="line">-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的</span><br><span class="line">范围之内，该字符将被写出；否则，该字符将被排除。</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://blog.csdn.net/u011003120/article/details/52190187" target="_blank" rel="noopener">cut用法</a></strong></p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>　报告或删除文件中重复的行。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -c, --count           在每行前加上表示相应行目出现次数的前缀编号</span><br><span class="line">-d, --repeated        只输出重复的行</span><br><span class="line">-D, --all-repeated[&#x3D;delimit-method    显示所有重复的行</span><br><span class="line">                      delimit-method&#x3D;&#123;none(default),prepend,separate&#125;</span><br><span class="line">                      以空行为界限</span><br><span class="line">-f, --skip-fields&#x3D;N   比较时跳过前N 列</span><br><span class="line">-i, --ignore-case     在比较的时候不区分大小写</span><br><span class="line">-s, --skip-chars&#x3D;N    比较时跳过前N 个字符</span><br><span class="line">-u, --unique          只显示唯一的行</span><br><span class="line">-z, --zero-terminated 使用&#39;\0&#39;作为行结束符，而不是新换行</span><br><span class="line">-w, --check-chars&#x3D;N   对每行第N 个字符以后的内容不作对照</span><br><span class="line">    --help            显示此帮助信息并退出</span><br><span class="line">    --version         显示版本信息并退出</span><br></pre></td></tr></table></figure></p>
<p> <strong><a href="https://www.cnblogs.com/ftl1012/p/uniq.html" target="_blank" rel="noopener">uniq详解</a></strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux command</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio多语言(中英)适配</title>
    <url>/2020/02/14/ndroid-studio%E4%B8%AD%E8%8B%B1%E6%96%87%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>strings.xml在目录res相应的value文件夹下,用来显示文本，避免硬编码，要添加新的语言支持，就要在不同的 value 文件夹下（如value 、values-zh-rCN）添加不同语言的 string.xml 文件。本文以简体中文为例,描述一下Android studio下相应strings.xml(zh-rCN)的生成方式，其他语言类似。</p>
<a id="more"></a>
<h3 id="手动建立文件"><a href="#手动建立文件" class="headerlink" title="手动建立文件"></a>手动建立文件</h3><p>选中res文件夹，右键New–&gt;Android Resource Directory,然后选中Locale,如下图所示：</p>
<p><img src="/images/pasted-17.png" alt="upload successful"><br>选择相应语言和相应区域：</p>
<p><img src="/images/pasted-18.png" alt="upload successful"><br>文件夹名称（values-zh-rCN）自动生成，最后在该文件夹生成strings.xml即可。项目视图如下：</p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p>打开Translations Editor（双击打开strings.xml，窗口右上角点击Open Editor），点击Add Locale，在下拉菜单中选择相应语言区域，系统会自动生成相应文件夹以及strings.xml文件。</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu下使用微信、QQ等</title>
    <url>/2021/03/18/new/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu下使用微信，网页版的登录不了，只能考虑客户端了。考虑了下，还是在docker里，无论怎么折腾，也不会污染系统。</p>
<a id="more"></a>
<p>网上教程多如牛毛，但不是坑，就是坑，找了个自己能用的，记录下备用<br>1、安装docker docker-compose，网上教程一大把，自己搜<br>2、执行如下命令<br>首先要允许所有用户访问X11服务,运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></table></figure>
<p>拉取镜像（注意docker设置国内镜像地址，用科大的就行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull bestwu&#x2F;wechat</span><br></pre></td></tr></table></figure>
<p>在你指定的文件夹下创建 docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">  wechat:</span><br><span class="line">    image: bestwu&#x2F;wechat</span><br><span class="line">    container_name: wechat</span><br><span class="line">    devices:</span><br><span class="line">      - &#x2F;dev&#x2F;snd</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;tmp&#x2F;.X11-unix:&#x2F;tmp&#x2F;.X11-unix</span><br><span class="line">      - $PWD&#x2F;WeChatFiles:&#x2F;WeChatFiles</span><br><span class="line">    environment:</span><br><span class="line">      - DISPLAY&#x3D;unix$DISPLAY</span><br><span class="line">      - QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">      - GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">      - AUDIO_GID&#x3D;26 # 可选 默认63（在终端用getent group video | cut -d: -f3查） 主机audio gid 解决声音设备访问权限问题</span><br><span class="line">      - GID&#x3D;1000 # 可选 默认1000 主机当前用户 gid 解决挂载目录访问权限问题</span><br><span class="line">      - UID&#x3D;1000 # 可选 默认1000 主机当前用户 uid 解决挂载目录访问权限问题</span><br><span class="line">    ipc: host</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>pac.txt---url通配规则</title>
    <url>/2020/01/30/pac/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>科学上网PAC模式，有时会需要自己在pac.txt里添加一些被墙的URL，记录一下url通配的规则，以备以后使用。</p>
<a id="more"></a>
<ol>
<li>通配符支持。比如 .example.com&#x2F; 实际书写时可省略 * ， 如 .example.com&#x2F; ， 和 *.example.com&#x2F; 效果一样</li>
<li>正则表达式支持。以 \ 开始和结束， 如 [\w]+://example.com\</li>
<li>例外规则 @@ ，如 @@.example.com&#x2F; 满足 @@ 后规则的地址不使用代理</li>
<li>匹配地址开始和结尾 | ，如 |<a href="http://example.com/" target="_blank" rel="noopener">http://example.com</a> 、 example.com| 分别表示以 <a href="http://example.com/" target="_blank" rel="noopener">http://example.com</a> 开始和以 example.com 结束的地址</li>
<li>|| 标记，如 ||example.com 则 <a href="http://example.com/" target="_blank" rel="noopener">http://example.com</a> 、 <a href="https://example.com/" target="_blank" rel="noopener">https://example.com</a> 、 <a href="ftp://example.com/">ftp://example.com</a> 等地址均满足条件</li>
<li>注释 ! 。 如 !我是注释<br>v2rayN需重启生效。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>spring 线程安全</title>
    <url>/2020/03/09/pring-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>转载：<a href="https://www.cnblogs.com/kismetv/p/8757260.html" target="_blank" rel="noopener"><strong>Spring中获取request的几种方法，及其线程安全性分析</strong></a>、**<a href="https://www.jianshu.com/p/e04491f3550f" target="_blank" rel="noopener">Spring 如何保证线程安全
</a><strong>、</strong><a href="https://blog.csdn.net/cs408/article/details/48972653" target="_blank" rel="noopener">Spring中Singleton模式的线程安全
</a>**</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&amp;emsp;每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作</p>
<a id="more"></a>
<p>数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧。并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该栈帧并释放掉。</p>
<p>&amp;emsp;注意：Java栈中的数据是线程私有的，一个线程是无法访问另一个线程的Java栈的数据。这也就是为什么多线程编程时，两个相同线程执行同一方法时，对方法内的局部变量是不需要数据同步的原因。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx conf location</title>
    <url>/2022/03/23/nginx-conf-location-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="root-alias"><a href="#root-alias" class="headerlink" title="root alias"></a>root alias</h4><ul>
<li>root的处理结果是：root路径＋location路径</li>
<li>alias的处理结果是：使用alias路径替换location路径</li>
</ul>
<a id="more"></a>

<p>nginx指定文件路径有两种方式root和alias，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p>
<p>alias 指定的目录是准确的，给location指定一个目录。</p>
<p>root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录。也就是</p>
<p>以root方式设置资源路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法: root path;</span><br><span class="line">配置块: http、server、location、if</span><br></pre></td></tr></table></figure>
<p>如果server,location同时配置，优先采用location内的root路径，</p>
<p>以alias 方式设置资源路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法: alias path;</span><br><span class="line">配置块: location</span><br></pre></td></tr></table></figure>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">	alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#若按照上述配置的话，则访问&#x2F;img&#x2F;目录里面的文件时，ningx会自动去&#x2F;var&#x2F;www&#x2F;image&#x2F;目录找文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">	root &#x2F;var&#x2F;www&#x2F;image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#若按照这种配置的话，则访问&#x2F;img&#x2F;目录下的文件时，nginx会去&#x2F;var&#x2F;www&#x2F;image&#x2F;img&#x2F;目录下找文件</p>
<p>注意： </p>
<ol>
<li>使用alias时，目录名后面一定要加”&#x2F;“。</li>
<li>使用alias标签的目录块中不能使用rewrite的break。</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中</li>
</ol>
<h4 id="nginx-location配置详细解释"><a href="#nginx-location配置详细解释" class="headerlink" title="nginx location配置详细解释"></a>nginx location配置详细解释</h4><p>语法详解<br>语法规则： location [&#x3D;|<del>|</del>*|^~] &#x2F;uri&#x2F; { … }</p>
<ul>
<li>&#x3D; 开头表示精确匹配</li>
<li>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为&#x2F;static&#x2F;20%&#x2F;aa，可以被规则^~ &#x2F;static&#x2F; &#x2F;aa匹配到（注意是空格）。以xx开头</li>
<li>~ 开头表示区分大小写的正则匹配 以xx结尾</li>
<li>~* 开头表示不区分大小写的正则匹配 以xx结尾</li>
<li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配 的正则</li>
<li>&#x2F; 通用匹配，任何请求都会匹配到。</li>
</ul>
<p>例子，有如下匹配规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">   #规则A  访问根目录&#x2F;， 比如http:&#x2F;&#x2F;localhost&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">location &#x3D; &#x2F;login &#123;</span><br><span class="line">   #规则B  http:&#x2F;&#x2F;localhost&#x2F;login 将匹配规则B，http:&#x2F;&#x2F;localhost&#x2F;register 则匹配规则H</span><br><span class="line">&#125;</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;</span><br><span class="line">   #规则C  http:&#x2F;&#x2F;localhost&#x2F;static&#x2F;a.html 将匹配规则C</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">   #规则D，注意：是根据括号内的大小写进行匹配。括号内全是小写，只匹配小写</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.png$ &#123;</span><br><span class="line">   #规则E  http:&#x2F;&#x2F;localhost&#x2F;a.gif, http:&#x2F;&#x2F;localhost&#x2F;b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用， </span><br><span class="line">      http:&#x2F;&#x2F;localhost&#x2F;static&#x2F;c.png 则优先匹配到 规则C</span><br><span class="line">      http:&#x2F;&#x2F;localhost&#x2F;a.PNG 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</span><br><span class="line">&#125;</span><br><span class="line">location !~ \.xhtml$ &#123;</span><br><span class="line">   #规则F  访问 http:&#x2F;&#x2F;localhost&#x2F;a.xhtml 不会匹配规则F和规则G，</span><br><span class="line">&#125;</span><br><span class="line">location !~* \.xhtml$ &#123;</span><br><span class="line">   #规则G  访问 http:&#x2F;&#x2F;localhost&#x2F;a.xhtml 不会匹配规则F和规则G，</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   #规则H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;a.XHTML不会匹配规则G，（因为!）。规则F，规则G属于排除法，符合匹配规则也不会匹配到，所以想想看实际应用中哪里会用到。</span><br><span class="line"></span><br><span class="line">访问 http:&#x2F;&#x2F;localhost&#x2F;category&#x2F;id&#x2F;1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候nginx转发请求给后端应用[服务器](https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;服务器&amp;tn&#x3D;24004469_oem_dg&amp;rsv_dl&#x3D;gh_pl_sl_csd)，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</span><br><span class="line"></span><br><span class="line">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x3D; &#x2F;api&#x2F; &#123;   # 访问http:&#x2F;&#x2F;localhost&#x2F;api&#x2F;xxx.xxx  会被代理到192.168.0.1&#x2F;xxx.xxx</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;192.168.0.1&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;                              &#x2F;&#x2F;以xx开头</span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;     &#x2F;&#x2F;以xx结尾</span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try-files详解"><a href="#try-files详解" class="headerlink" title="try_files详解"></a>try_files详解</h4><ul>
<li>格式1：try_files file … uri;  </li>
<li>格式2：try_files file … &#x3D;code;</li>
</ul>
<p><a href="https://www.cnblogs.com/jedi1995/p/10900224.html" target="_blank" rel="noopener">nginx配置选项try_files详解</a></p>
<h4 id="proxy-pass详解"><a href="#proxy-pass详解" class="headerlink" title="proxy_pass详解"></a>proxy_pass详解</h4><p>在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加&#x2F;，表示绝对根路径；如果没有&#x2F;，表示相对路径，把匹配的路径部分也给代理走。<br>假设下面四种情况分别用 <a href="http://192.168.1.1/proxy/test.html" target="_blank" rel="noopener">http://192.168.1.1/proxy/test.html</a> 进行访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第二种（相对于第一种，最后少一个 &#x2F; ）</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;proxy&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa&#x2F;test.html</span><br><span class="line"></span><br><span class="line">第四种（相对于第三种，最后少一个 &#x2F; ）</span><br><span class="line">location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http:&#x2F;&#x2F;127.0.0.1&#x2F;aaatest.html</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/b010c9302cd0" target="_blank" rel="noopener">nginx 之 proxy_pass详解</a></p>
<h4 id="80端口重定向到443端口"><a href="#80端口重定向到443端口" class="headerlink" title="80端口重定向到443端口"></a>80端口重定向到443端口</h4><p>nginx 80端口重定向到443端口，也就是http访问自动跳转到https</p>
<p>配置如下：<br>一、按照如下格式修改nginx.conf 配置文件，80端口会自动转给443端口，这样就强制使用SSL证书加密了。访问http的时候会自动跳转到https上面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.域名.com;</span><br><span class="line">    rewrite ^(.*)$ https:&#x2F;&#x2F;$&#123;server_name&#125;$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.域名.com;</span><br><span class="line">    root &#x2F;home&#x2F;wwwroot;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;server.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;certs&#x2F;server.key;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>alias</tag>
        <tag>root</tag>
        <tag>location</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>rust --堆栈(内存)</title>
    <url>/2022/02/08/rust-%E7%9A%84%E5%A0%86%E6%A0%88-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>类型的值默认都分布在栈中(即便是动态类型的数据，但也通过胖指针改变了该类型的值的表现形式)，所以<strong>创建某个变量的引用时，引用的是栈中的那个值</strong>.   </p>
<a id="more"></a>

<h4 id="Rust将哪些数据存放于栈中？"><a href="#Rust将哪些数据存放于栈中？" class="headerlink" title="Rust将哪些数据存放于栈中？"></a>Rust将哪些数据存放于栈中？</h4><p>Rust中各种类型的值默认都存储在栈中，除非显式地使用Box::new()将它们存放在堆上。</p>
<p>但数据要存放在栈中，要求其数据类型的大小已知。对于静态大小的类型，可直接存储在栈上。</p>
<p>例如如下类型的数据存放在栈中：</p>
<ul>
<li>裸指针(一个机器字长)、普通引用(一个机器字长)、胖指针(除了指针外还包含其他元数据信息，智能指针也是一种带有额外功能的胖指针，而胖指针实际上又是Struct结构)</li>
<li>布尔值</li>
<li>char</li>
<li>各种整数、浮点数</li>
<li>数组(Rust数组的元素数据类型和数组长度都是固定不变的)</li>
<li>元组</li>
</ul>
<p>对于动态大小的类型(如Vec、String)，则数据部分分布在堆中(被称为allocate buffer)，并在栈中留下胖指针(Struct方式实现)指向实际的数据，栈中的那个胖指针结构是静态大小的(换句话说，动态类型以Vec为例，Vec类型的值理应是那些连续的元素，但因为这样的连续内存的大小是不确定的，所以改变了它的行为，它的值是那个栈中的胖指针，而不是存储在allocatge buffer中的实际数据)。</p>
<p>以上分类需要注意几点：</p>
<ul>
<li>将栈中数据赋值给变量时，数据直接存放在栈中。比如i32类型的33，33直接存放在栈内，而不是在堆中存放33并在栈中存放指向33的指针</li>
<li>因为类型的值默认都分布在栈中(即便是动态类型的数据，但也通过胖指针改变了该类型的值的表现形式)，所以<strong>创建某个变量的引用时，引用的是栈中的那个值</strong></li>
<li>有些数据是0字节的，不需要占用空间，比如()</li>
<li>尽管【容器】结构中(如数组、元组、Struct)可以存放任意数据，但保存在容器中的要么是原始类型的栈中值，要么是指向堆中数据的引用，所以这些容器类型的值也在栈中。例如，对于struct User {name: String}，name字段存储的是String类型的胖指针，String类型实际的数据则在堆中</li>
<li>尽管Box::new(T)可以将类型T的数据放入堆中，但Box类型本身是一个struct，它是一个胖指针(更严格地说是智能指针)，它在栈中</li>
</ul>
<p>实际上，对于理解来说，只有Box才能让数据存放到堆中，但对于实现上，只有调用alloc才能申请堆内存并将数据存放在堆中。比如，自己想实现一个类型，将某些数据明确存放在堆中，那么必须要在实现代码中调用alloc来分配堆内存，但同时，要实现的这个类型本身，它的值是在栈中的。</p>
<p>(5).Rust除了使用堆栈，还使用全局内存区(静态变量区和字面量区)。</p>
<p>Rust编译器会将全局内存区的数据直接嵌入在二进制程序文件中，当启动并加载程序时，嵌入在全局内存区的数据被放入内存的某个位置。</p>
<p>全局内存区的数据是编译期间就可确定的，且存活于整个程序运行期间。</p>
<p>字符串字面量、static定义的静态变量(相当于全局变量)都会硬编码嵌入到二进制程序的全局内存区。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">  let _s &#x3D; &quot;hello&quot;;     &#x2F;&#x2F; (1)</span><br><span class="line">  let _ss &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; (2)</span><br><span class="line">  let _arr &#x3D; [&quot;hello&quot;;3];    &#x2F;&#x2F; (3)</span><br><span class="line">  let _tuple &#x3D; (&quot;hello&quot;,);   &#x2F;&#x2F; (4)</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的几个变量都使用了字符串字面量，且使用的都是相同的字面量”hello”，在编译期间，它们会共用同一个”hello”，该”hello”会硬编码到二进制程序文件中。当程序被加载到内存时，该被放入到全局内存区，它在全局内存区有自己的内存地址，当运行到以上各行代码时：</p>
<ul>
<li>代码(1)、(3)、(4)，将根据地址取得其引用，并分别保存到变量_s、_arr各元素、_tuple元素中</li>
<li>代码(2)，将根据地址取得数据并将其拷贝到堆中(转换为Vec<u8>的方式存储，它是String类型的底层存储方式)</u8></li>
</ul>
<h4 id="Rust中允许使用const定义常量。"><a href="#Rust中允许使用const定义常量。" class="headerlink" title="Rust中允许使用const定义常量。"></a>Rust中允许使用const定义常量。</h4><p>常量将在编译期间直接以硬编码的方式内联(inline)插入到使用常量的地方。</p>
<p>所谓内联，即将它代表的值直接替换到使用它的地方。</p>
<p>比如，定义了常量ABC&#x3D;33，在第100行和第300行处都使用了常量ABC，那么在编译期间，会将33硬编码到第100行和第300行处。</p>
<p>Rust中，除了const定义的常量会被内联，某些函数也可以被内联。将函数进行内联，表示将该函数对应的代码体直接展开并插入到调用该函数的地方，这样就没有函数调用的开销(比如没有调用函数时申请栈帧、在寄存器保存某些变量等的行为)，效率会更高一些。但只有那些频繁调用的短函数才适合被内联，并且内联会导致程序的代码膨胀。</p>
<p>原地址: <strong><a href="https://rust-book.junmajinlong.com/ch5/02_rust_mem.html" target="_blank" rel="noopener">Rust如何使用堆和栈</a></strong></p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring设计思想》AOP设计基本原理</title>
    <url>/2020/03/11/pring%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%8BAOP%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>转载：**<a href="https://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">《Spring设计思想》AOP设计基本原理
</a><strong>、</strong><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）
</a>**</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>cors--springboot shiro 前后端分离跨域</title>
    <url>/2020/05/18/rs-spring-shiro-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后端分离，采用stateless JWT，服务器就无法控制客户端的登录，而stateful jwt本质上跟session一样，所以采用shiro的session管理，简单方便。由此涉及后续的session的管理、跨域、shiro跳转等问题。</p>
<a id="more"></a>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>浏览器的同源策略，就是指必须在同一个协议，域名，端口号下</p>
<p>有哪些是不受同源策略限制:</p>
<ul>
<li>页面上的链接，比如 a 链接。</li>
<li>重定向。</li>
<li>表单提交。</li>
<li>跨域资源的引入，比如：script, img, link, iframe。</li>
</ul>
<p>既然有同源策略的限制，那么就会产生跨域问题，就是指不同源的脚本在数据交互的时候，会报错，这个过程就是跨域。</p>
<h3 id="跨域的两种方案"><a href="#跨域的两种方案" class="headerlink" title="跨域的两种方案"></a>跨域的两种方案</h3><h4 id="沿用Cookie"><a href="#沿用Cookie" class="headerlink" title="沿用Cookie"></a>沿用Cookie</h4><p>沿用传统的cookie session方式，就需要前后端分别设置，可以让前端的request带上后端域名对应的cookie</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>客户端需要设置Ajax请求属性withCredentials 为true，让Ajax请求都带上Cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">           url:url,</span><br><span class="line">           type:&quot;GET&quot;,</span><br><span class="line">           xhrFields:&#123;</span><br><span class="line">               withCredentials:true</span><br><span class="line">           &#125;,</span><br><span class="line">           success:function(res)&#123; </span><br><span class="line">               console.log(res);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>首先服务端在使用cors协议时需要设置响应消息头<em>Access-Control-Allow-Credentials</em>的值为<em>true</em>，即允许在ajax访问时携带cookie(如上，前端也要设置withCredentials为true)。另外为了安全，在cors标准里不允许Access-Control-Allow-Origin设置为*,而是必须指定明确的、与请求网页一致的域名，cookie也依然遵循“同源策略”，只有用目标服务器域名设置的cookie才会上传，而且使用document.cookie也无法读取目标服务器域名下的cookie。接下来我们来看看实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">]</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)     &#x2F;&#x2F; 此时，不允许为*</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">&#x2F;&#x2F;            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义http-header"><a href="#自定义http-header" class="headerlink" title="自定义http header"></a>自定义http header</h4><p>绕过cookie，自定义http header传输token(本项目token即sessionId)，这种方式适合前端不支持cookie的时候，具体设置在后文中。</p>
<h3 id="session管理"><a href="#session管理" class="headerlink" title="session管理"></a>session管理</h3><p>采用第二种方式，就需要绕过传统的sessionid传输方式：通过请求头里的cookie传输（浏览器的cookie是跟着域名走的）。客户端登录，服务端通过JSON返回sessionid，客户端保存，后续每次请求要在请求头中添加加token字段，服务端shiro根据请求头的token字段获取sessionid。<br>shiroConfiguration中的securityManager配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        manager.sessionManager &#x3D; sessionManager()</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun sessionManager(): SessionManager? &#123;</span><br><span class="line">        val mySessionManager &#x3D; MySessionManager()</span><br><span class="line">        mySessionManager.setSessionDAO(sessionDAO())</span><br><span class="line">        return mySessionManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要是在MySessionManager里重写DefaultWebSessionManager的getSessionId方法和retrieveSession方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.apache.shiro.session.Session</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey</span><br><span class="line">import org.apache.shiro.web.servlet.ShiroHttpServletRequest</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line">import org.apache.shiro.web.util.WebUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import java.io.Serializable</span><br><span class="line">import java.lang.Boolean</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class MySessionManager : DefaultWebSessionManager&#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var log &#x3D; LoggerFactory.getLogger(this.javaClass.name)</span><br><span class="line">        private val AUTHORIZATION &#x3D; &quot;auth-token&quot;</span><br><span class="line">        private val HEADER_SESSION_ID_SOURCE &#x3D; &quot;header request&quot;</span><br><span class="line">        private val MY_SESSION_ATTRIBUTE &#x3D; &quot;MY_SESSION_ATTRIBUTE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override fun getSessionId(request: ServletRequest, response: ServletResponse?): Serializable? &#123;</span><br><span class="line">        val id &#x3D; WebUtils.toHttp(request).getHeader(AUTHORIZATION)</span><br><span class="line">        &#x2F;&#x2F;如果请求头中有 Authorization 字段， 则其值为sessionId</span><br><span class="line">        return if (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, HEADER_SESSION_ID_SOURCE)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id)</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE)</span><br><span class="line">            id</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;否则按默认规则从cookie取sessionId</span><br><span class="line">            super.getSessionId(request, response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(UnknownSessionException::class)</span><br><span class="line">    protected override fun retrieveSession(sessionKey: SessionKey?): Session? &#123;</span><br><span class="line">        val sessionId &#x3D; getSessionId(sessionKey) ?: return null</span><br><span class="line">        val request: ServletRequest &#x3D; WebUtils.getRequest(sessionKey)</span><br><span class="line">        return if (request.getAttribute(MY_SESSION_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">            log.debug(&quot;Get Session from request!&quot;)</span><br><span class="line">            request.getAttribute(MY_SESSION_ATTRIBUTE) as Session</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.debug(&quot;Get Session from redis!&quot;)</span><br><span class="line">            val s: Session &#x3D; retrieveSessionFromDataSource(sessionId)</span><br><span class="line">            if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;session ID was provided, meaning one is expected to be found, but we couldn&#39;t find one:</span><br><span class="line">                val msg &#x3D; &quot;Could not find session with ID [$sessionId]&quot;</span><br><span class="line">                throw UnknownSessionException(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            request.setAttribute(MY_SESSION_ATTRIBUTE, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>  对于简单请求，浏览器直接在ruquest头之中，增加一个Origin字段，相应地，服务器会在response头中添加Access-Control-Allow-Origin等字段，如此便是一次成功的跨域请求。</p>
<p><img src="/images/pasted-24.png" alt="upload successful"><br>只要同时满足以下两大条件，就属于简单请求。</p>
<p>请求方法是以下三种方法之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br></pre></td></tr></table></figure>
<p>HTTP的头信息不超出以下几种字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight），预检的请求方法（Request Method）为OPTION。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>自定义过滤器，针对请求头中有Origin字段的，response头中添加相应字段，针对OPITION请求,response返回200状态码。<br>新建CorsFilter类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.StringUtils</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import org.springframework.http.HttpStatus</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod</span><br><span class="line">import javax.servlet.*</span><br><span class="line">import javax.servlet.http.HttpServletRequest</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@WebFilter(urlPatterns &#x3D; arrayOf(&quot;&#x2F;*&quot;),filterName &#x3D; &quot;crosFilter&quot;)</span><br><span class="line">class CorsFilter : Filter &#123;</span><br><span class="line"></span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var logger &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun init(filterConfig: FilterConfig)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) &#123;</span><br><span class="line">        var httpresponse &#x3D; response as HttpServletResponse</span><br><span class="line">        var httprequest &#x3D; request as HttpServletRequest</span><br><span class="line">        &#x2F;&#x2F; 允许哪些Origin发起跨域请求</span><br><span class="line">        var orgin &#x3D; request . getHeader (&quot;Origin&quot;)</span><br><span class="line">        &#x2F;&#x2F;header有Origin字段，说明客户端跨域</span><br><span class="line">        if (!StringUtils.isEmpty(orgin))&#123;</span><br><span class="line">            logger.info(&quot;处理跨域请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, orgin)</span><br><span class="line">            &#x2F;&#x2F; 允许请求的方法</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httprequest.method)</span><br><span class="line">            &#x2F;&#x2F;多少秒内,不需要再发送预检验请求，可以缓存该结果</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)</span><br><span class="line">            &#x2F;&#x2F; 表明它允许跨域请求包含xxx头</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Headers&quot;,httprequest.getHeader(&quot;Access-Control-Request-Headers&quot;))</span><br><span class="line">            &#x2F;&#x2F;是否允许浏览器携带用户身份信息（cookie）</span><br><span class="line">            httpresponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;prefight请求</span><br><span class="line">        if (request.getMethod().equals(RequestMethod.OPTIONS.name)) &#123;</span><br><span class="line">            logger.info(&quot;处理prefight请求，请求URl：$&#123;httprequest.requestURL&#125;&quot;)</span><br><span class="line">            response.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain?.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun destroy()  &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立WebFilterConfig类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean</span><br><span class="line">import org.springframework.context.annotation.Bean</span><br><span class="line">import org.springframework.context.annotation.Configuration</span><br><span class="line">import javax.servlet.Filter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1：自定义过滤器，可以采取Filter加@WebFilter和启动类加@ServletComponentScan的方式，过滤器的执行顺序按照类名排序</span><br><span class="line"> * 故而采用如下FilterRegistrationBean的方式，可以自定义顺序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">class WebFilterConfig&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    fun crosResFilter(): FilterRegistrationBean&lt;*&gt;? &#123;</span><br><span class="line">        val filterRegistrationBean: FilterRegistrationBean&lt;Filter?&gt; &#x3D; FilterRegistrationBean&lt;Filter?&gt;()</span><br><span class="line">        val corsFilter &#x3D; CorsFilter()</span><br><span class="line">        filterRegistrationBean.setFilter(corsFilter)</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;) &#x2F;&#x2F;配置过滤规则</span><br><span class="line">        filterRegistrationBean.setName(&quot;corsFilter&quot;) &#x2F;&#x2F;设置过滤器名称</span><br><span class="line">        filterRegistrationBean.order &#x3D; 1 &#x2F;&#x2F;执行次序</span><br><span class="line">        return filterRegistrationBean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此便能愉快的跨域访问了。</p>
<h3 id="shiro跳转"><a href="#shiro跳转" class="headerlink" title="shiro跳转"></a>shiro跳转</h3><p>由于shiro对前后端分离支持不是很理想，如访问需认证的路径，若未登录会直接跳转至登录页面（默认是&#x2F;login.jsp），这中情况我们需要直接返回未认证的JSON数据，由前端控制路由。<br>新建MyFormAuthenticationFilter，继承shiro的FormAuthenticationFilter（对应过滤authc的路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.customer.config.shiro</span><br><span class="line"></span><br><span class="line">import com.example.customer.util.JsonUtils</span><br><span class="line">import com.example.customer.util.constants.ErrorEnum</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line">import javax.servlet.ServletRequest</span><br><span class="line">import javax.servlet.ServletResponse</span><br><span class="line">import javax.servlet.http.HttpServletResponse</span><br><span class="line"></span><br><span class="line">class MyFormAuthenticationFilter : FormAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    constructor() : super()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val log &#x3D; LoggerFactory.getLogger(this.javaClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun onAccessDenied(request: ServletRequest?, response: ServletResponse?): Boolean &#123;</span><br><span class="line">        return if (isLoginRequest(request, response)) &#123;</span><br><span class="line">            if (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                executeLogin(request, response)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (log.isTraceEnabled) &#123;</span><br><span class="line">                    log.trace(&quot;Login page view.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;allow them to see the login page ;)</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var resp &#x3D; response as HttpServletResponse</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +</span><br><span class="line">                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不再跳转，直接返回Json信息</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.getWriter().write(JsonUtils.errorJson(ErrorEnum.E_401).toString())</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在shiro过滤链中，添加自定义过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class ShiroConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * shiro过滤器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun shiroFilter(manager: SecurityManager) : ShiroFilterFactoryBean&#123;</span><br><span class="line">        val factoryBean &#x3D; ShiroFilterFactoryBean()</span><br><span class="line">        &#x2F;&#x2F;设置securityManager</span><br><span class="line">        factoryBean.securityManager &#x3D; manager</span><br><span class="line">        &#x2F;&#x2F;自定义过滤器,修改认证失败跳转</span><br><span class="line">        val filters &#x3D; mutableMapOf&lt;String,Filter&gt;()</span><br><span class="line">        filters.put(&quot;myauthc&quot;,myFormAuthenticationFilter())</span><br><span class="line">        factoryBean.filters &#x3D;  filters</span><br><span class="line"></span><br><span class="line">        val filterChainDefinitionMap: MutableMap&lt;String, String&gt; &#x3D; LinkedHashMap()</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;static&#x2F;**&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 静态资源匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;doLogin&quot;] &#x3D; &quot;anon&quot; &#x2F;&#x2F; 登录匿名访问</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;login&#x2F;logout&quot;] &#x3D; &quot;logout&quot; &#x2F;&#x2F; 用户退出，只需配置logout即可实现该功能</span><br><span class="line">        filterChainDefinitionMap[&quot;&#x2F;**&quot;] &#x3D; &quot;myauthc&quot; &#x2F;&#x2F; 其他路径均需要身份认证，一般位于最下面，优先级最低</span><br><span class="line">        &#x2F;&#x2F; 如果不设置默认会自动寻找Web工程根目录下的&quot;&#x2F;login.jsp&quot;页面</span><br><span class="line">        &#x2F;&#x2F;身份认证失败，不直接Shiro跳转至默认登录页，而是跳转至未认证接口，返回Json数据，前后端分离中登录界面跳转应由前端路由控制</span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F; factoryBean.setLoginUrl(&quot;&#x2F;login&#x2F;unauth&quot;);</span><br><span class="line">        &#x2F;&#x2F; 权限认证失败，跳转后续处理</span><br><span class="line"> &#x2F;&#x2F;       factoryBean.setUnauthorizedUrl(&quot;&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap)</span><br><span class="line"></span><br><span class="line">        return factoryBean</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private fun myFormAuthenticationFilter(): MyFormAuthenticationFilter&#123;</span><br><span class="line">        return MyFormAuthenticationFilter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *securityManager配置</span><br><span class="line">     * 不指定名字的话，自动创建一个方法名第一个字母小写的bean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    fun securityManager() : DefaultWebSecurityManager&#123;</span><br><span class="line">        val manager &#x3D; DefaultWebSecurityManager()</span><br><span class="line">        manager.setRealm(getRealm())</span><br><span class="line">        SecurityUtils.setSecurityManager(manager)</span><br><span class="line">        return manager</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
        <category>shiro</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>cors</tag>
        <tag>shiro</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本检查nginx服务状态</title>
    <url>/2021/04/08/shell%E8%84%9A%E6%9C%AC%E6%A3%80%E6%9F%A5nginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    service nginx start</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="脚本解析"><a href="#脚本解析" class="headerlink" title="脚本解析"></a>脚本解析</h3><p>以上是通过进程判断，也可以通过端口判断，如netstat -nlpt | grep nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# netstat -nlpt | grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8801&#x2F;nginx: master</span><br></pre></td></tr></table></figure>

<p>以下，以进程为例详解，ps -C nginx –no-header<br>这里涉及ps 的用法，我们一般用ps查看相关进程，一般都是用ps -ef | grep XX 或 ps -aux| grep XX 的模式<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br><span class="line">root     11660  5532  0 09:55 pts&#x2F;1    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>
<p>但是这样通常都会覆盖一个grep的进程。</p>
<p>我们可以用ps -ef|grep nginx|grep -v grep的方式排除grep的进程，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# ps -ef|grep nginx|grep -v grep</span><br><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>

<p>也可以直接用ps -C 或ps -c 的方式， -C 后面接命令的名字（推荐） ，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  8801 ?        00:00:00 nginx</span><br><span class="line">  8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>–no-header 就是去挑title,如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx --no-header</span><br><span class="line"> 8801 ?        00:00:00 nginx</span><br><span class="line"> 8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>wc -l 这个很熟悉了，行数计算</p>
<p>所以用这种方式可判断，如果<br>ps -C nginx –no-header|wc -l</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">值为0，即代表服务未启动</span><br><span class="line">值为非0，即代表服务已启动</span><br></pre></td></tr></table></figure>
<p>最后，killall keepalived 这个是以服务名称杀死进程，日常中也用的挺多的</p>
<p>上面那段完整的脚本意思即为：<br>判断nginx 服务是否启动<br>如果未启动，执行启动命令<br>再次判断，如果启动失败，关掉keepalived，进入从节点</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust是基于表达式的语言</title>
    <url>/2022/03/16/rust-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://rust-book.junmajinlong.com/ch1/01_expression.html" target="_blank" rel="noopener">Rust是基于表达式的语言</a></p>
<a id="more"></a>

<p>除了在表达式尾部加分号的代码是语句之外，还有另外一种情况的代码是语句而非表达式：<strong>用于声明或定义</strong>。例如let声明变量、fn定义函数、struct声明结构体等。</p>
<p>Rust很多地方都会结合表达式和语句来做变量赋值。例如，if结构也是一个表达式，所以它有返回值，可以将if的返回值赋值给变量，而<strong>它的返回值来自于它的大括号</strong>：当大括号最后执行的一条代码不加分号结尾时，该代码的计算结果就是if结构的返回值。</p>
<p>————————————————《rust入门秘籍》</p>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <url>/2020/03/11/spring-struts2-action%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B/</url>
    <content><![CDATA[<p>转载：**<a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）
</a>**</p>
]]></content>
  </entry>
  <entry>
    <title>spring security 处理filter chain抛出的异常</title>
    <url>/2021/12/15/spring-security-%E5%A4%84%E7%90%86filter-chain%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>springboot异常处理默认会redirect &#x2F;error,但前后分离后, 异常处理就要返回json<br>异常一种是controller抛出的异常, 可以通过@RestControllerAdvice @ExceptionHandler全局处理,<br>另一种是spring security filter chain 抛出的异常,由于在@RestControllerAdvice之前,所以需要其它方式处理.<br>1: 自定义MyErrorController ,overriding default Spring Boot &#x2F;error handler<br>2:在filter chain里第一的位置新增自定义filter,处理后面没有处理掉的异常.</p>
<p><strong><a href="https://blog.csdn.net/muyuanjin67/article/details/120373168" target="_blank" rel="noopener">Spring和SpringSecurity 的全局异常处理</a></strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,<strong><a href="https://stackoverflow.com/questions/34595605/how-to-manage-exceptions-thrown-in-filters-in-spring" target="_blank" rel="noopener">How to manage exceptions thrown in filters in Spring?</a></strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,<strong><a href="https://www.jianshu.com/p/f528fe2377e2" target="_blank" rel="noopener">Spring security restful like 服务下的异常处理</a></strong></p>
]]></content>
      <tags>
        <tag>spring security</tag>
        <tag>filter chain</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本监测nginx服务状态</title>
    <url>/1970/01/01/shell%E8%84%9A%E6%9C%AC%E7%9B%91%E6%B5%8Bnginx%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候我们需要对某个服务状态进行监控，下面就是个脚本例子。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    service nginx start</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="脚本解析"><a href="#脚本解析" class="headerlink" title="脚本解析"></a>脚本解析</h3><p>以上是通过进程判断，也可以通过端口判断，如netstat -nlpt | grep nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# netstat -nlpt | grep nginx</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8801&#x2F;nginx: master</span><br></pre></td></tr></table></figure>

<p>以下，以进程为例详解，ps -C nginx –no-header<br>这里涉及ps 的用法，我们一般用ps查看相关进程，一般都是用ps -ef | grep XX 或 ps -aux| grep XX 的模式<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br><span class="line">root     11660  5532  0 09:55 pts&#x2F;1    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>
<p>但是这样通常都会覆盖一个grep的进程。</p>
<p>我们可以用ps -ef|grep nginx|grep -v grep的方式排除grep的进程，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@newyork ~]# ps -ef|grep nginx|grep -v grep</span><br><span class="line">root      8801     1  0 09:06 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">root      8802  8801  0 09:06 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>

<p>也可以直接用ps -C 或ps -c 的方式， -C 后面接命令的名字（推荐） ，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  8801 ?        00:00:00 nginx</span><br><span class="line">  8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>–no-header 就是去挑title,如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# ps -C nginx --no-header</span><br><span class="line"> 8801 ?        00:00:00 nginx</span><br><span class="line"> 8802 ?        00:00:00 nginx</span><br></pre></td></tr></table></figure>
<p>wc -l 这个很熟悉了，行数计算</p>
<p>所以用这种方式可判断，如果<br>ps -C nginx –no-header|wc -l</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">值为0，即代表服务未启动</span><br><span class="line">值为非0，即代表服务已启动</span><br></pre></td></tr></table></figure>
<p>最后，killall keepalived 这个是以服务名称杀死进程，日常中也用的挺多的</p>
<p>上面那段完整的脚本意思即为：<br>判断nginx 服务是否启动<br>如果未启动，执行启动命令<br>再次判断，如果启动失败，关掉keepalived，进入从节点</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 密码登录脚本</title>
    <url>/2021/03/19/ssh-%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脚本密码登录服务器</p>
<a id="more"></a>

<p>1、安装expect<br>使用以下代码检测expect是否已经安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;usr&#x2F;bin | grep expect</span><br></pre></td></tr></table></figure>
<p>如果显示为空，则使用以下命令安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure>
<p>2、 制作脚本<br>合适位置建个sh文件，脚本中写入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spawn ssh root@127.0.0.1 -p 22</span><br><span class="line">expect &quot;*Are you sure you want to continue connecting (yes&#x2F;no)?&quot;</span><br><span class="line">send &quot;yes\r&quot;</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>node升级提示(sudo: npm: command not found)</title>
    <url>/2021/08/12/sudo-npm-command-not-found/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>重拿前端项目，要把以前ubuntu的node、npm升级到最新版本，按照网上找来的方法，输入：<em>sudo npm install n -g</em>，结果提示：<em>sudo : npm :command not found</em>。</p>
<a id="more"></a>

<h3 id="node、npm升级"><a href="#node、npm升级" class="headerlink" title="node、npm升级"></a>node、npm升级</h3><p>正常情况下，先安装工具<em>n</em>，然后通过它升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line"></span><br><span class="line">sudo n stable  # 安装最新版本</span><br></pre></td></tr></table></figure>
<p>但出现了前言里的错误，不加sudo，权限不够，加了又无法识别命令。</p>
<p><img src="/images/pasted-50.png" alt="upload successful"></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>这是什么原因呢？<br>输入<em>which npm</em>可以得到*&#x2F;home&#x2F;zzl&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v12.21.0&#x2F;bin&#x2F;npm*，这个是普通用户的目录。<br>而sudo执行的是&#x2F;usr&#x2F;bin目录，这是root用户的目录,<br>所以使用sudo命令是识别不到这个命令的，我们可以使用软链接来处理这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;mydata&#x2F;nodejs&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;mydata&#x2F;nodejs&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure>
<p>将上面左边的命令位置，替换用which npm查询出来的就行了。</p>
<p><strong>当然我用了which node之后就意识到我以前是用的nvm管理node的版本，差点儿就用n在另外的位置重新下了个版本，而且还发现以前用apt-get下了个更早的版本，每个工具下载的位置都不同，混乱不堪，统统删了，以后只用nvm管理node版本！教训啊～</strong></p>
]]></content>
  </entry>
  <entry>
    <title>锁、synchronized、CAS、volatile</title>
    <url>/2020/04/06/synchronized%E3%80%81CAS%E3%80%81volatile/</url>
    <content><![CDATA[<p>转载：**<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a><strong>、</strong><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a><strong>、</strong><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析
</a><strong>、</strong><a href="https://www.cnblogs.com/theRhyme/p/12129120.html" target="_blank" rel="noopener">从原子类和UNSAFE来理解JAVA内存模型，ATOMICINTEGER的INCREMENTANDGET方法和UNSAFE部分源码介绍，VALUEOFFSET偏移量的理解</a><strong>、</strong><a href="https://www.cnblogs.com/theRhyme/p/9396834.html" target="_blank" rel="noopener">JAVA内存模型中VOLATILE关键字的作用
</a><strong>、</strong><a href="https://www.cnblogs.com/theRhyme/p/9399881.html" target="_blank" rel="noopener">JAVA内存模型，为啥线程要有自己的本地内存，CPU高速缓存
</a>**</p>
]]></content>
      <tags>
        <tag>lock</tag>
        <tag>synchronized</tag>
        <tag>CAS</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 使用</title>
    <url>/2022/03/25/tmux-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>只能说 tmux太香了…</p>
<a id="more"></a>

<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><ul>
<li>tmux：新建一个session和一个window</li>
<li>tmux a：打开挂起的session</li>
<li>tmux ls：显示所有挂起的session</li>
</ul>
<p>在tmux中的操作：</p>
<ul>
<li>按下 ctrl + b 后松开，再按 % 可将当前pane左右平分成两个pane</li>
<li>按下 ctrl + b 后松开，再按 “ 可将当前pane上下平分成两个pane</li>
<li>按下 ctrl + b 后松开，再按 d 可挂起当前的session</li>
<li>按下 ctrl + b 后松开，再按 z 可将当前pane全屏或取消全屏</li>
<li>按下 ctrl + b 后松开，再按 c 可在当前session中创建新的window</li>
<li>按下 ctrl + b 后松开，再按 s 可选择其他session，用方向键操作</li>
<li>按下 ctrl + b 后松开，再按 w 可选择其他window，同样用方向键操作</li>
<li>按下 ctrl + b 后松开，再按 PageUp 或 PageDown 可翻阅当前pane中的内容</li>
</ul>
<p>tmux中的复制粘贴</p>
<ul>
<li>按下 ctrl + b 后松开，再按 [</li>
<li>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</li>
<li>按下 ctrl + b 后松开，再按 ]，会将剪贴板的内容粘贴到光标处</li>
</ul>
<p><a href="https://developer.aliyun.com/article/789729" target="_blank" rel="noopener">tmux简介</a>、<br><a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">Tmux 使用教程</a>、<br><a href="https://developer.aliyun.com/article/789729" target="_blank" rel="noopener">Tmux 修改前缀快捷键</a></p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu 开机自动挂载其他盘</title>
    <url>/1970/01/01/ubuntu-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E5%85%B6%E4%BB%96%E7%9B%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p>
<a id="more"></a>

<p>1、查询挂载硬盘UUID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p>
<p>2、打开文件&#x2F;etc&#x2F;fstab文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<p>在文档末尾添加相应磁盘的信息。格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p>
<p>3、重启生效</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 开机启动管理</title>
    <url>/2021/03/21/ubuntu-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ubuntu自启服务管理命令</p>
<a id="more"></a>
<p>查看开机启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files --type&#x3D;service|grep enabled</span><br></pre></td></tr></table></figure>
<p>以蓝牙为例，查询蓝牙服务是否开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled bluetooth.service</span><br></pre></td></tr></table></figure>
<p>如果是enable开机自启动<br>如果是disable不开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable bluetooth.service #开机运行服务</span><br><span class="line"></span><br><span class="line">systemctl disable bluetooth.service #取消开机运行</span><br><span class="line"></span><br><span class="line">sudo systemctl disable  bluetooth.service#关闭蓝牙服务</span><br><span class="line"></span><br><span class="line">systemctl start bluetooth.service #启动服务</span><br><span class="line"></span><br><span class="line">systemctl stop bluetooth.service #停止服务</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth.service #重启服务</span><br><span class="line"></span><br><span class="line">systemctl reload bluetooth.service #重新加载服务配置文件</span><br><span class="line"></span><br><span class="line">systemctl status bluetooth.service #查询服务运行状态</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu terminal 打开后的默认位置和大小</title>
    <url>/2021/03/18/ubuntu-terminal-location/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常一边儿搜着浏览器，一边儿操作终端，这时候终端打开的默认位置大小就很重要，能节省不少步骤，下面介绍一下怎么设置。</p>
<a id="more"></a>
<p>网传的一般有两种，一种是自定义快捷键，一种是修改*&#x2F;usr&#x2F;share&#x2F;applications&#x2F;gnome-terminal.desktop<em>。第二种效果只是修改了“通过菜单栏或鼠标点击进入终端时的位置”，用</em>Ctrl+Alt+T*进入时，没有效果，所以本文选择第一种，步骤如下：</p>
<p>1、打开一个终端，把它调整到自己想要的大小和位置</p>
<p>2、在终端内执行xwininfo，鼠标变成十字，然后鼠标点击终端，出现终端窗口的信息，注意最后一行： -geometry 80x24-4+168</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p>3、依次进入Setting - Devices - keyboard，可以看到系统的所有快捷键设置，包括<em>Launch terminal Ctrl+Alt+T</em>。拉到最下面，点击+号</p>
<p><img src="/images/pasted-31.png" alt="upload successful"></p>
<p>Name自己取，主要是Command,输入步骤2的大小坐标信息，  <em>gnome-terminal –geometry&#x3D;80x24-4+168</em> ，Shortcut自定义即可，注意不要跟现存的快捷键冲突。我自己是用的Super+T。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 打开win10 txt中文乱码</title>
    <url>/2021/03/19/ubuntu-%E6%89%93%E5%BC%80win10-txt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双系统，ubuntu打开win10的文本文件，中文乱码，明显是编码问题，记录之。</p>
<a id="more"></a>

<p>1、原因<br>ubuntu系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件）则vim打开文档后，encoding&#x3D;utf-8（locale决定的），fileencoding&#x3D;latin1（自动编码判断机制不准导致的），termencoding&#x3D;空（默认无需转换term编码），最终显示文件为乱码。</p>
<p>2、解决办法<br>在*&#x2F;home&#x2F;user&#x2F;<em>下修改</em>.vimrc*文件（系统新装，默认情况下尚未创建）。 编辑 ~&#x2F;.vimrc 文件（ 添加如下几行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set fileencodings&#x3D;utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding&#x3D;utf-8</span><br><span class="line">set encoding&#x3D;utf-8</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 搜狗拼音 繁简切换快捷键冲突</title>
    <url>/2022/03/27/ubuntu-%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3-%E7%B9%81%E7%AE%80%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>在用idea（vscode）搜索时，按Ctlr +Shift +F ,没反应，后打字发现触发了搜狗拼音的繁简切换，盘它~</p>
<a id="more"></a>

<h4 id="修改搜狗拼音的配置文件"><a href="#修改搜狗拼音的配置文件" class="headerlink" title="修改搜狗拼音的配置文件"></a>修改搜狗拼音的配置文件</h4><p>首先打开搜狗拼音的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.config&#x2F;sogoupinyin&#x2F;conf&#x2F;env.ini</span><br></pre></td></tr></table></figure>

<p>然后找到下面这行，将后面的值改为0，保存文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ShortCutFanJian&#x3D;1</span><br></pre></td></tr></table></figure>

<p>完成这一步还没结束，还需要修改fcitx的配置文件</p>
<h4 id="修改-fcitx-的配置文件"><a href="#修改-fcitx-的配置文件" class="headerlink" title="修改 fcitx 的配置文件"></a>修改 fcitx 的配置文件</h4><p>打开 fcitx 的相关配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.config&#x2F;fcitx&#x2F;conf&#x2F;fcitx-chttrans.config</span><br></pre></td></tr></table></figure>
<p>然后找到下面这行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Hotkey&#x3D;CTRL_SHIFT_F</span><br></pre></td></tr></table></figure>
<p>将前面的注释取消，随便修改一个不常用的快捷键，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hotkey&#x3D;CTRL_SHIFT_]</span><br></pre></td></tr></table></figure>
<p>保存文件，重新登录一下账户即可。</p>
<p><a href="https://www.cnblogs.com/FengZeng666/p/15504636.html" target="_blank" rel="noopener">Ubuntu 禁用搜狗输入法Linux版的简繁切换快捷键</a></p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu 桌面死机(重启gnome-shell)</title>
    <url>/2021/04/19/ubuntu-%E6%A1%8C%E9%9D%A2%E6%AD%BB%E6%9C%BA/</url>
    <content><![CDATA[<p>ubuntu有时桌面会卡死，鼠标点击失灵，解决方法：重启gnome-shell。<br>建议以下两种二选一：</p>
<ul>
<li><span style="color:red">alt + F2</span>  弹出的输入框里输入小写<span style="color:red">r</span> ，回车，如此重启gnome-shell桌面环境。</li>
<li><span style="color:red">ctrl + alt + F3</span> 切换到其它虚拟终端tty3(Ubuntu18.04 默认tty1是选择用户登录界面，tty2往往就是对应卡死的桌面位置，我们选择tty3进行操作)，输入用户密码登录，输入<span style="color:red">ps -ef|grep gnome-shell</span> ，找到tty2对应的gnome-shell pid（一般有两个，一个是tty1的，一个是tty2的），<span style="color:red">kill -9 pidNum</span> ，系统自动重启gnome-shell,最后<span style="color:red">crl + alt +F2</span> 切换至tty2,这种方法的优点是不会干扰其他正在运行的程序。 <a id="more"></a>
 其他方法还有（未验证）：</li>
</ul>
<h3 id="How-to-restart-GUI-on-Ubuntu-20-04-step-by-step-instructions"><a href="#How-to-restart-GUI-on-Ubuntu-20-04-step-by-step-instructions" class="headerlink" title="How to restart GUI on Ubuntu 20.04 step by step instructions"></a>How to restart GUI on Ubuntu 20.04 step by step instructions</h3><p>Sometimes you many need to restart&#x2F;reload GUI because you may have done some changes which require it. However, occasionally you are forced to restart GUI because it froze and you do not wish to restart the entire system. In any case you might find some of the bellow information helpful.</p>
<h4 id="The-first-method-is-the-least-destructing-however-it-might-not-provide-the-expected-result"><a href="#The-first-method-is-the-least-destructing-however-it-might-not-provide-the-expected-result" class="headerlink" title="The first method is the least destructing, however, it might not provide the expected result."></a>The first method is the least destructing, however, it might not provide the expected result.</h4><p>Enter a restart gui Command</p>
<p><img src="/images/pasted-36.png" alt="upload successful"></p>
<p>While logged in to your GNOME desktop press <span style="color:red">ALT + F2</span> key combination. Into the Enter a Command box type <span style="color:red">r </span> and press <span style="color:red">Enter</span> .</p>
<h4 id="Another-alternative-to-do-the-GUI-restart-trick-might-be-the-most-obvious-to-simply-re-login"><a href="#Another-alternative-to-do-the-GUI-restart-trick-might-be-the-most-obvious-to-simply-re-login" class="headerlink" title="Another alternative to do the GUI restart trick might be the most obvious to simply re-login."></a>Another alternative to do the GUI restart trick might be the most obvious to simply re-login.</h4><p><img src="/images/pasted-37.png" alt="upload successful"><br>Restart GUI by first Log Out and consequently Log In to your GUI desktop</p>
<h4 id="In-this-scenario-we-simply-restart-the-gnome-shell-as-non-privileged-user"><a href="#In-this-scenario-we-simply-restart-the-gnome-shell-as-non-privileged-user" class="headerlink" title="In this scenario we simply restart the gnome-shell as non-privileged user."></a>In this scenario we simply restart the gnome-shell as non-privileged user.</h4><p><img src="/images/pasted-38.png" alt="upload successful"><br>Open up terminal and enter the <span style="color:red">gnome-shell –replace </span>command.</p>
<h4 id="The-following-restart-GUI-solution-is-guaranteed-to-restart-your-desktop-even-if-your-GUI-froze-while-the-system-is-still-functioning-However-it-needs-administrative-sudo-privileges"><a href="#The-following-restart-GUI-solution-is-guaranteed-to-restart-your-desktop-even-if-your-GUI-froze-while-the-system-is-still-functioning-However-it-needs-administrative-sudo-privileges" class="headerlink" title="The following restart GUI solution is guaranteed to restart your desktop even if your GUI froze while the system is still functioning. However, it needs administrative sudo privileges."></a>The following restart GUI solution is guaranteed to restart your desktop even if your GUI froze while the system is still functioning. However, it needs administrative sudo privileges.</h4><p><img src="/images/pasted-39.png" alt="upload successful"><br>Either enter the <span style="color:red">sudo systemctl restart systemd-logind.service </span>command directly into the terminal while in GUI. However, if your GUI is frozen you may need to first change to TTY console using <span style="color:red">CTRL + ALT + F2</span>, login and execute command from there.</p>
<h4 id="In-this-method-we-will-restart-the-Display-Manager-which-will-consequently-also-restart-GNOME-shell"><a href="#In-this-method-we-will-restart-the-Display-Manager-which-will-consequently-also-restart-GNOME-shell" class="headerlink" title="In this method we will restart the Display Manager which will consequently also restart GNOME shell."></a>In this method we will restart the Display Manager which will consequently also restart GNOME shell.</h4><p><img src="/images/pasted-40.png" alt="upload successful"><br>Either from GUI and TTY console <span style="color:red">CTRL + ALT + F2</span> execute <span style="color:red">sudo systemctl restart gdm</span> command. However, if you have deployed LightDM display manager in that case execute<span style="color:red"> sudo systemctl restart lightdm</span> command.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>gnome-shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu登录界面美化</title>
    <url>/2021/04/14/ubuntu%E5%BC%80%E6%9C%BA%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>**<a href="https://blog.csdn.net/vselfdom/article/details/88546349" target="_blank" rel="noopener">Ubuntu 18.04 用户登录界面优化</a>**，备用。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 自动挂载其他盘</title>
    <url>/1970/01/01/ubuntu-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E5%85%B6%E4%BB%96%E7%9B%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双系统，ubuntu和win10装在同一个固态盘，还有另外一个机械盘，平时放些资料啥的，设置给ubuntu开机自动挂载另一个机械盘。</p>
<a id="more"></a>

<p>1、查询挂载硬盘UUID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo blkid &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-32.png" alt="upload successful"><br>Secert和WorkSpace盘信息如上，下面用到两个盘的UUID。</p>
<p>2、打开文件&#x2F;etc&#x2F;fstab文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<p>在文档末尾添加相应磁盘的信息。格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UUID&#x3D;************] [挂载磁盘分区]  [挂载磁盘格式]  0  2</span><br><span class="line"></span><br><span class="line">UUID&#x3D;4D55CFC14D016D60 &#x2F;mnt&#x2F;workspace ntfs defaults  0  2</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-33.png" alt="upload successful"><br>第一个数字：0表示开机不检查磁盘，1表示开机检查磁盘；<br>第二个数字：0表示交换分区，1代表启动分区（Linux），2表示普通分区</p>
<p>3、重启生效</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>java类加载</title>
    <url>/2020/03/03/va-class/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里贴一个介绍类加载的介绍链接：<a href="https://juejin.im/post/5dac4edff265da5b5f7588d1#heading-0" target="_blank" rel="noopener">java 的类加载</a></p>
]]></content>
  </entry>
  <entry>
    <title>vim常用命令、快捷键</title>
    <url>/2020/01/17/vim-hotkey/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vim的常用命令以及快捷键，记录一下，方便以后查询。详细链接：<a href="https://linux.cn/article-8144-1.html" target="_blank" rel="noopener">Vim 快捷键速查表</a></p>
<a id="more"></a>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Esc</td>
<td>从当前模式转换到“普通模式”。所有的键对应到命令。</td>
</tr>
<tr>
<td>i</td>
<td>“插入模式”用于插入文字。回归按键的本职工作。</td>
</tr>
<tr>
<td>:</td>
<td>“命令行模式” Vim 希望你输入类似于保存该文档命令的地方。</td>
</tr>
</tbody></table>
<h3 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 Ctrl + J</td>
<td>光标向下移动一行</td>
</tr>
<tr>
<td>k 或 Ctrl + P</td>
<td>光标向上移动一行</td>
</tr>
<tr>
<td>l</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>0</td>
<td>（数字 0）移动光标至本行开头</td>
</tr>
<tr>
<td>$</td>
<td>移动光标至本行末尾</td>
</tr>
<tr>
<td>^</td>
<td>移动光标至本行第一个非空字符处</td>
</tr>
<tr>
<td>w</td>
<td>向前移动一个词 （上一个字母和数字组成的词之后）</td>
</tr>
<tr>
<td>W</td>
<td>向前移动一个词 （以空格分隔的词）</td>
</tr>
<tr>
<td>5w</td>
<td>向前移动五个词</td>
</tr>
<tr>
<td>b</td>
<td>向后移动一个词 （下一个字母和数字组成的词之前）</td>
</tr>
<tr>
<td>B</td>
<td>向后移动一个词 （以空格分隔的词）</td>
</tr>
<tr>
<td>5b</td>
<td>向后移动五个词</td>
</tr>
<tr>
<td>G</td>
<td>移动至文件末尾</td>
</tr>
<tr>
<td>gg</td>
<td>移动至文件开头</td>
</tr>
</tbody></table>
<h3 id="浏览文档"><a href="#浏览文档" class="headerlink" title="浏览文档"></a>浏览文档</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>跳转到上一句</td>
</tr>
<tr>
<td>)</td>
<td>跳转到下一句</td>
</tr>
<tr>
<td>{</td>
<td>跳转到上一段</td>
</tr>
<tr>
<td>}</td>
<td>跳转到下一段</td>
</tr>
<tr>
<td>[[</td>
<td>跳转到上一部分</td>
</tr>
<tr>
<td>]]</td>
<td>跳转到下一部分</td>
</tr>
<tr>
<td>[]</td>
<td>跳转到上一部分的末尾</td>
</tr>
<tr>
<td>][</td>
<td>跳转到上一部分的开头</td>
</tr>
</tbody></table>
<h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>在光标后插入文本</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入文本</td>
</tr>
<tr>
<td>i</td>
<td>在光标前插入文本</td>
</tr>
<tr>
<td>o</td>
<td>（小写字母 o）在光标下方新开一行</td>
</tr>
<tr>
<td>O</td>
<td>（大写字母 O）在光标上方新开一行</td>
</tr>
</tbody></table>
<h3 id="特殊插入"><a href="#特殊插入" class="headerlink" title="特殊插入"></a>特殊插入</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:r [filename]</td>
<td>在光标下方插入文件 [filename] 的内容</td>
</tr>
<tr>
<td>:r ![command]</td>
<td>执行命令 [command] ，并将输出插入至光标下方</td>
</tr>
</tbody></table>
<h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除光标处字符</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个词</td>
</tr>
<tr>
<td>d0</td>
<td>删至行首</td>
</tr>
<tr>
<td>d$</td>
<td>删至行末</td>
</tr>
<tr>
<td>d)</td>
<td>删至句末</td>
</tr>
<tr>
<td>dgg</td>
<td>删至文件开头</td>
</tr>
<tr>
<td>dG</td>
<td>删至文件末尾</td>
</tr>
<tr>
<td>dd</td>
<td>删除该行</td>
</tr>
<tr>
<td>3dd</td>
<td>删除三行</td>
</tr>
</tbody></table>
<h3 id="简单替换文本"><a href="#简单替换文本" class="headerlink" title="简单替换文本"></a>简单替换文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>r{text}</td>
<td>将光标处的字符替换成 {text}</td>
</tr>
<tr>
<td>R</td>
<td>进入覆写模式，输入的字符将替换原有的字符</td>
</tr>
</tbody></table>
<h3 id="复制-x2F-粘贴文本"><a href="#复制-x2F-粘贴文本" class="headerlink" title="复制&#x2F;粘贴文本"></a>复制&#x2F;粘贴文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制当前行至存储缓冲区</td>
</tr>
<tr>
<td>[“x]yy</td>
<td>复制当前行至寄存器 x</td>
</tr>
<tr>
<td>p</td>
<td>在当前行之后粘贴存储缓冲区中的内容</td>
</tr>
<tr>
<td>P</td>
<td>在当前行之前粘贴存储缓冲区中的内容</td>
</tr>
<tr>
<td>[“x]p</td>
<td>在当前行之后粘贴寄存器 x 中的内容</td>
</tr>
<tr>
<td>[“x]P</td>
<td>在当前行之前粘贴寄存器 x 中的内容</td>
</tr>
</tbody></table>
<h3 id="撤销-x2F-重做操作"><a href="#撤销-x2F-重做操作" class="headerlink" title="撤销&#x2F;重做操作"></a>撤销&#x2F;重做操作</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>撤销最后的操作</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做最后撤销的操作</td>
</tr>
</tbody></table>
<h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;search_text</td>
<td>检索文档，在文档后面的部分搜索 search_text</td>
</tr>
<tr>
<td>?search_text</td>
<td>检索文档，在文档前面的部分搜索 search_text</td>
</tr>
<tr>
<td>n</td>
<td>移动到后一个检索结果</td>
</tr>
<tr>
<td>N</td>
<td>移动到前一个检索结果</td>
</tr>
<tr>
<td>:%s&#x2F;original&#x2F;replacement</td>
<td>检索第一个 “original” 字符串并将其替换成“replacement”</td>
</tr>
<tr>
<td>:%s&#x2F;original&#x2F;replacement&#x2F;g</td>
<td>检索并将所有的 “original” 替换为“replacement”</td>
</tr>
<tr>
<td>:%s&#x2F;original&#x2F;replacement&#x2F;gc</td>
<td>检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换</td>
</tr>
</tbody></table>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>m {a-zA-Z}</td>
<td>在当前光标位置设置书签，书签名可用一个大小写字母（{a-zA-Z}）</td>
</tr>
<tr>
<td>:marks</td>
<td>列出所有书签</td>
</tr>
<tr>
<td>{a-zA-Z}</td>
<td>跳转到书签 {a-zA-Z}</td>
</tr>
</tbody></table>
<h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>进入逐字可视模式</td>
</tr>
<tr>
<td>V</td>
<td>进入逐行可视模式</td>
</tr>
<tr>
<td>Esc</td>
<td>退出可视模式</td>
</tr>
</tbody></table>
<h3 id="改动选中文本"><a href="#改动选中文本" class="headerlink" title="改动选中文本"></a>改动选中文本</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>切换大小写</td>
</tr>
<tr>
<td>d</td>
<td>删除一个词</td>
</tr>
<tr>
<td>c</td>
<td>变更</td>
</tr>
<tr>
<td>y</td>
<td>复制</td>
</tr>
<tr>
<td>&gt;</td>
<td>右移</td>
</tr>
<tr>
<td>&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>!</td>
<td>通过外部命令进行过滤</td>
</tr>
</tbody></table>
<h3 id="保存并退出"><a href="#保存并退出" class="headerlink" title="保存并退出"></a>保存并退出</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:q</td>
<td>退出 Vim，如果文件已被修改，将退出失败</td>
</tr>
<tr>
<td>:w</td>
<td>保存文件</td>
</tr>
<tr>
<td>:w new_name</td>
<td>用 new_name 作为文件名保存文件</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件并退出 Vim</td>
</tr>
<tr>
<td>:q!</td>
<td>退出 Vim，不保存文件改动</td>
</tr>
<tr>
<td>ZZ</td>
<td>退出 Vim，如果文件被改动过，保存改动内容</td>
</tr>
<tr>
<td>ZQ</td>
<td>与 :q! 相同，退出 Vim，不保存文件改动</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim hotkey</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中vim的粘帖复制</title>
    <url>/2021/03/17/vim-%E7%B2%98%E5%B8%96%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要从浏览器中把Ctrl+c的内容复制到Vim中，要搞懂Ubuntu18中vim的复制粘帖原理及使用。</p>
<a id="more"></a>

<h3 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h3><h4 id="默认剪贴板"><a href="#默认剪贴板" class="headerlink" title="默认剪贴板"></a>默认剪贴板</h4><p>vim会有一些存储空间来暂存内容，vim中将这些存储空间叫寄存器。此寄存器非我们硬件所说的寄存器，可以理解为是一种cache。例如我们在vim中y操作复制的内容，实际就是暂存到寄存器中。</p>
<p>如下，在vim中执使用:reg命令，可以查看各个寄存器的内容。<br><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>其中有两个特殊的寄存器: “* 和 “+。前者关联系统选择缓冲区(Buffer)，后者关联系统剪切板(Clipboard)，关于系统剪切板的使用见下文。</p>
<h4 id="复制和粘贴到指定剪贴板"><a href="#复制和粘贴到指定剪贴板" class="headerlink" title="复制和粘贴到指定剪贴板"></a>复制和粘贴到指定剪贴板</h4><p>要把vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后（按Esc），按 <em>“Ny</em> 完成复制，其中N表示特定寄存器编号（注意是按一下双引号然后按粘贴板号最后按y），例如要把内容复制到系统剪切板，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;+y</span><br></pre></td></tr></table></figure>
<p>就可以了。注意的是，上面是 双引号 + 加号寄存器 + y。通过这命令copy后就可以去浏览器Ctrl+v了。</p>
<p>如果从浏览器Ctrl+c后，要粘贴到vim中，则需要执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;+p</span><br></pre></td></tr></table></figure>

<h3 id="系统剪切板及使用"><a href="#系统剪切板及使用" class="headerlink" title="系统剪切板及使用"></a>系统剪切板及使用</h3><h4 id="查看-Vim-是否支持系统剪切板"><a href="#查看-Vim-是否支持系统剪切板" class="headerlink" title="查看 Vim 是否支持系统剪切板"></a>查看 Vim 是否支持系统剪切板</h4><p>刚重装了系统，命令按了半天，跑到其他地方Ctrl+v，什么也没有，原来是系统剪切板不支持的锅。<br>在终端输入 <em>vim –version | grep clipboard</em>回车：<br><img src="/images/pasted-28.png" alt="upload successful"><br>如果 clipboard 前面都是 - 号，说目前还不支持系统剪切板功能，请继续看下一节，如果都是 + 号，略过此节。</p>
<h4 id="开启系统剪切板功能"><a href="#开启系统剪切板功能" class="headerlink" title="开启系统剪切板功能"></a>开启系统剪切板功能</h4><p>开启系统剪切板功能的方法也有很多，比较正统的应该是重新编译安装 Vim 源码，因为我怕麻烦（水平渣），所以选择简单的方法，即安装 vim-gnome。<br>一行指令即可搞定，在终端输入 <em>sudo apt install vim-gnome -y</em>回车。<br>此时再次使用上述的两个方法验证，发现 Vim 已经支持系统剪切板功能。</p>
<h3 id="vim内部复制、粘贴、剪切"><a href="#vim内部复制、粘贴、剪切" class="headerlink" title="vim内部复制、粘贴、剪切"></a>vim内部复制、粘贴、剪切</h3><h4 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h4><p>在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v+光标移动 （按字符选择）高亮选中所要的文本，然后进行各种操作（比如粘帖到系统剪切板“+y）。</span><br><span class="line">V （按行选择）</span><br><span class="line">v+选中的内容+c 更改选中的文字</span><br></pre></td></tr></table></figure>
<h4 id="复制：y-ank"><a href="#复制：y-ank" class="headerlink" title="复制：y(ank)"></a>复制：y(ank)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y 用v命令选中文本后，用y进行复制</span><br><span class="line">yy 复制当前行，然后用p进行粘贴</span><br><span class="line">5yy 复制从当前行开始的5行</span><br><span class="line">y_ 等同于yy</span><br><span class="line">Y 等同于yy</span><br><span class="line">yw 复制当前单词</span><br><span class="line">y$ 从当前位置复制到行尾</span><br><span class="line">y0 从当前位置复制到行首</span><br><span class="line">y^ 从当前位置复制到第一个非空白字符</span><br><span class="line">yG 从当前行复制到文件结束</span><br><span class="line">y20G 从当前行复制到第20行</span><br><span class="line">y?bar 复制至上一个出现bar的位置</span><br></pre></td></tr></table></figure>
<h4 id="粘贴：p-aste"><a href="#粘贴：p-aste" class="headerlink" title="粘贴：p(aste)"></a>粘贴：p(aste)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p(小写) 在光标位置之后粘贴</span><br><span class="line">P(大写) 在光标位置之前粘贴</span><br></pre></td></tr></table></figure>
<h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v + 方向键(hjkl)选中内容 + d 剪切 + p粘贴</span><br></pre></td></tr></table></figure>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="vim复制到系统剪贴板"><a href="#vim复制到系统剪贴板" class="headerlink" title="vim复制到系统剪贴板"></a>vim复制到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;*y</span><br><span class="line">&quot;+y</span><br><span class="line">&quot;+2yy – 复制两行</span><br><span class="line">&#123;Visual&#125;&quot;+y - copy the selected text into the system clipboard</span><br><span class="line">&quot;+y&#123;motion&#125; - copy the text specified by &#123;motion&#125; into the system clipboard</span><br><span class="line">:[range]yank + - copy the text specified by [range] into the system clipboard</span><br></pre></td></tr></table></figure>
<h5 id="vim剪切到系统剪贴板"><a href="#vim剪切到系统剪贴板" class="headerlink" title="vim剪切到系统剪贴板"></a>vim剪切到系统剪贴板</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;+dd – 剪切一行</span><br><span class="line">从系统剪贴板粘贴到vim</span><br><span class="line">&quot;*p</span><br><span class="line">&quot;+p</span><br><span class="line">Shift+Insert</span><br><span class="line">:put + - Ex command puts contents of system clipboard on a new line</span><br><span class="line">&lt;C-r&gt;+ - From insert mode (or commandline mode)</span><br><span class="line">&quot;+p比 Ctrl-v 命令更好，它可以更快更可靠地处理大块文本的粘贴，也能够避免粘贴大量文本时，发生每行行首的自动缩进累积，因为Ctrl-v是通过系统缓存的stream处理，一行一行地处理粘贴的文本。</span><br></pre></td></tr></table></figure>
<p>参考：**<a href="https://liushiming.cn/article/copy-and-paste-in-vim.html" target="_blank" rel="noopener">一文搞懂vim复制粘贴</a><strong>、</strong><a href="https://blog.csdn.net/jpch89/article/details/93915710" target="_blank" rel="noopener">打开 Ubuntu 18 中 Vim 的系统剪切板功能</a>**</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vue cli 前端跨域设置</title>
    <url>/2021/11/27/vue-cli-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前后分离的前端开发时,一般都缺少后端的支持,开发阶段可以用mock模拟后端的返回请求, 但后续总要访问后端联调, 此时就涉及到前端的跨越了(只有开发阶段,部署的时候统一部署). 本质上就是在前端开一个代理服务,服务器访问服务器就没有浏览器访问后端的跨域限制了.</p>
<a id="more"></a>
<p><strong><a href="https://blog.csdn.net/qq_34450741/article/details/107444815?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link" target="_blank" rel="noopener">[vue] vue cli 4.0+ 解决前端跨域问题</a></strong> &amp;nbsp;&amp;nbsp;<strong><a href="https://blog.csdn.net/weixin_39553363/article/details/104152142" target="_blank" rel="noopener">图解vue3.0&#x2F;vueCli4解决跨域问题</a></strong></p>
]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-invokeinterface</title>
    <url>/2020/03/09/vm-invokeinterface/</url>
    <content><![CDATA[<p>转载：<a href="https://blog.csdn.net/kang389110772/article/details/50723127" target="_blank" rel="noopener">Spring为什么Autowired注入的是接口
</a>、</p>
<p><a href="https://github.com/1993hzh/thoughts/issues/5" target="_blank" rel="noopener">浅析JVM中invokevirtual与invokeinterface的区别 #5
</a>、</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.3" target="_blank" rel="noopener">Java Virtual Machine Specification</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>vue nginx 压缩</title>
    <url>/2022/02/10/vue-nginx-%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p><strong><a href="https://blog.csdn.net/qq_43363884/article/details/108195408" target="_blank" rel="noopener">vue打包时gzip压缩的两种方案</a></strong>  ,   &amp;nbsp;&amp;nbsp;<strong><a href="https://blog.csdn.net/github_38924695/article/details/108773173" target="_blank" rel="noopener">nginx中配置gzip_static on</a></strong></p>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket --Token Authentication</title>
    <url>/2020/06/07/websocket-Token-Authentication/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>链接：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication" target="_blank" rel="noopener">STOMP–Token Authentication</a></p>
]]></content>
  </entry>
  <entry>
    <title>websocket data transfer</title>
    <url>/1970/01/01/websocket-data-transfer/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>websocket message type： text or binary byte. And for binary data, we can choose between Blob and ArrayBuffer formats.</p>
<a id="more"></a>
<h3 id="Receiving-Text-and-Binary-Data"><a href="#Receiving-Text-and-Binary-Data" class="headerlink" title="Receiving Text and Binary Data"></a>Receiving Text and Binary Data</h3><p><strong>参考：<a href="https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch17.html" target="_blank" rel="noopener">websocket receiving Text and Binary Data</a></strong></p>
<p>WebSocket communication consists of messages and application code and does not need to worry about buffering, parsing, and reconstructing received data. For example, if the server sends a 1 MB payload, the application’s onmessage callback will be called only when the entire message is available on the client.</p>
<p>Further, the WebSocket protocol makes no assumptions and places no constraints on the application payload: both text and binary data are fair game. Internally, the protocol tracks only two pieces of information about the message: the length of payload as a variable-length field and the type of payload to distinguish UTF-8 from binary transfers.</p>
<p>When a new message is received by the browser, it is automatically converted to a DOMString object for text-based data, or a Blob object for binary data, and then passed directly to the application. The only other option, which acts as performance hint and optimization for the client, is to tell the browser to convert the received binary data to an ArrayBuffer instead of Blob:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&#39;wss:&#x2F;&#x2F;example.com&#x2F;socket&#39;);</span><br><span class="line">ws.binaryType &#x3D; &quot;arraybuffer&quot;; 1</span><br><span class="line"></span><br><span class="line">ws.onmessage &#x3D; function(msg) &#123;</span><br><span class="line">  if(msg.data instanceof ArrayBuffer) &#123;</span><br><span class="line">    processArrayBuffer(msg.data);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    processText(msg.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-transfer"><a href="#Data-transfer" class="headerlink" title="Data transfer"></a>Data transfer</h3><p><strong>参考：<a href="https://javascript.info/websocket#data-transfer" target="_blank" rel="noopener">websocket data transfer</a></strong></p>
<p>WebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:</p>
<ul>
<li>“text frames” – contain text data that parties send to each other.</li>
<li>“binary data frames” – contain binary data that parties send to each other.</li>
<li>“ping&#x2F;pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.</li>
<li>there’s also “connection close frame” and a few other service frames.<br>In the browser, we directly work only with text or binary frames.</li>
</ul>
<p><em>WebSocket .send()</em> method can send either text or binary data.</p>
<p>A call <em>socket.send(body)</em> allows body in string or a binary format, including Blob, ArrayBuffer, etc. No settings required: just send it out in any format.</p>
<p>When we receive the data, text always comes as string. And for binary data, we can choose between Blob and ArrayBuffer formats.</p>
<p>That’s set by <em>socket.binaryType</em> property, it’s “blob” by default, so binary data comes as Blob objects.</p>
<p>Blob is a high-level binary object, it directly integrates with <a>, <img> and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to “arraybuffer”:</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ws.binaryType &#x3D; &quot;arraybuffer&quot;;</span><br><span class="line">  ws.onmessage &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; event.data is either a string (if text) or arraybuffer (if binary)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>websocket</category>
      </categories>
  </entry>
  <entry>
    <title>websocket data transfer </title>
    <url>/2021/05/05/websocket-msg-type/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>websocket message type： text or binary byte. And for binary data, we can choose between Blob and ArrayBuffer formats.</p>
<a id="more"></a>
<h3 id="Receiving-Text-and-Binary-Data"><a href="#Receiving-Text-and-Binary-Data" class="headerlink" title="Receiving Text and Binary Data"></a>Receiving Text and Binary Data</h3><p><strong>参考：<a href="https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch17.html" target="_blank" rel="noopener">websocket receiving Text and Binary Data</a></strong></p>
<p>WebSocket communication consists of messages and application code and does not need to worry about buffering, parsing, and reconstructing received data. For example, if the server sends a 1 MB payload, the application’s onmessage callback will be called only when the entire message is available on the client.</p>
<p>Further, the WebSocket protocol makes no assumptions and places no constraints on the application payload: both text and binary data are fair game. Internally, the protocol tracks only two pieces of information about the message: the length of payload as a variable-length field and the type of payload to distinguish UTF-8 from binary transfers.</p>
<p>When a new message is received by the browser, it is automatically converted to a DOMString object for text-based data, or a Blob object for binary data, and then passed directly to the application. The only other option, which acts as performance hint and optimization for the client, is to tell the browser to convert the received binary data to an ArrayBuffer instead of Blob:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&#39;wss:&#x2F;&#x2F;example.com&#x2F;socket&#39;);</span><br><span class="line">ws.binaryType &#x3D; &quot;arraybuffer&quot;; 1</span><br><span class="line"></span><br><span class="line">ws.onmessage &#x3D; function(msg) &#123;</span><br><span class="line">  if(msg.data instanceof ArrayBuffer) &#123;</span><br><span class="line">    processArrayBuffer(msg.data);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    processText(msg.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-transfer"><a href="#Data-transfer" class="headerlink" title="Data transfer"></a>Data transfer</h3><p><strong>参考：<a href="https://javascript.info/websocket#data-transfer" target="_blank" rel="noopener">websocket data transfer</a></strong></p>
<p>WebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:</p>
<ul>
<li>“text frames” – contain text data that parties send to each other.</li>
<li>“binary data frames” – contain binary data that parties send to each other.</li>
<li>“ping&#x2F;pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.</li>
<li>there’s also “connection close frame” and a few other service frames.<br>In the browser, we directly work only with text or binary frames.</li>
</ul>
<p><em>WebSocket .send()</em> method can send either text or binary data.</p>
<p>A call <em>socket.send(body)</em> allows body in string or a binary format, including Blob, ArrayBuffer, etc. No settings required: just send it out in any format.</p>
<p>When we receive the data, text always comes as string. And for binary data, we can choose between Blob and ArrayBuffer formats.</p>
<p>That’s set by <em>socket.binaryType</em> property, it’s “blob” by default, so binary data comes as Blob objects.</p>
<p>Blob is a high-level binary object, it directly integrates with <a>, <img> and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to “arraybuffer”:</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ws.binaryType &#x3D; &quot;arraybuffer&quot;;</span><br><span class="line">  ws.onmessage &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; event.data is either a string (if text) or arraybuffer (if binary)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava --学习链接</title>
    <url>/2020/02/18/xJava/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Rx（Reactive Extensions）是一个使用<code>可观察数据流</code>进行<code>异步编程</code>的编程接口，ReactiveX结合了<code>观察者模式</code>、<code>迭代器模式</code>和<code>函数式编程</code>的精华。Rx的语言库比较流行的有RxJava&#x2F;RxJS&#x2F;Rx.NET，这里贴一些有关RxJava的链接，以便后续查找。</p>
<a id="more"></a>
<p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">Rx中文文档</a><br><a href="https://www.jianshu.com/p/03a72a5a2049" target="_blank" rel="noopener">RxJava心得</a><br><a href="https://blog.lixplor.com/2016/10/16/rxjava/" target="_blank" rel="noopener">RxJava操作符</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用Gson吗?Gson使用指南（一）</title>
    <url>/2021/12/23/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8Gson%E5%90%97-Gson%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong><a href="https://www.jianshu.com/p/e740196225a4" target="_blank" rel="noopener">你真的会用Gson吗?Gson使用指南（一）</a></strong>&amp;nbsp;&amp;nbsp;<strong><a href="https://blog.csdn.net/majalis_c/article/details/79801863?utm_term=gsonjsonobject%E8%BD%ACstring&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-79801863&spm=3001.4430" target="_blank" rel="noopener">Gson基本操作，JsonObject，JsonArray，String，JavaBean，List互转</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/02/04/%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="https://www.kukuxiaai.com/blog/2019-07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/" target="_blank" rel="noopener">数据结构与算法-树</a></p>
]]></content>
  </entry>
  <entry>
    <title>图解--函数调用过程及栈帧分析</title>
    <url>/2022/02/11/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%A0%88%E5%B8%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/yishizuofei/article/details/78282958" target="_blank" rel="noopener">函数调用过程原理及函数栈帧分析</a></p>
]]></content>
  </entry>
  <entry>
    <title>微信内置浏览器缓存清理</title>
    <url>/2022/03/30/%E5%BE%AE%E4%BF%A1%E5%86%85%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>单页面应用在微信浏览器里是个巨坑，它会缓存你的index.html，导致版本更新失效…</p>
<a id="more"></a>



<p> 调试时，可以手动清除微信缓存， 在安卓版微信内打开链接  <em><a href="http://debugtbs.qq.com/" target="_blank" rel="noopener">http://debugtbs.qq.com</a></em><br> 按照它提示的再打开<em>debugmm.qq.com&#x2F;?forcex5&#x3D;true</em>，再重新打开<em><a href="http://debugtbs.qq.com/" target="_blank" rel="noopener">http://debugtbs.qq.com</a></em>，点击清楚本地缓存….</p>
<p><a href="https://blog.csdn.net/weixin_40136189/article/details/81485171" target="_blank" rel="noopener">微信内置浏览器缓存清理</a></p>
]]></content>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/02/23/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/yw09041432/p/5908444.html" target="_blank" rel="noopener">七大查找算法</a></p>
]]></content>
  </entry>
  <entry>
    <title>补码原理的个人理解</title>
    <url>/2020/03/20/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载：**<a href="https://blog.csdn.net/jiaobuchong/article/details/83188674" target="_blank" rel="noopener">补码原理的个人理解</a>**</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>巧记linux常用命令中的递归参数-r(R)和-p</title>
    <url>/2021/03/09/%E5%B7%A7%E8%AE%B0linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%8F%82%E6%95%B0-r-R-%E5%92%8C-p/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/longyamiao/article/details/79782254" target="_blank" rel="noopener">巧记linux常用命令中的递归参数-r(R)和-p</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之IP、MAC</title>
    <url>/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BIP%E3%80%81MAC/</url>
    <content><![CDATA[<p>转载：**<a href="https://www.wmathor.com/index.php/archives/1124/" target="_blank" rel="noopener">MAC 地址与 IP 地址</a><strong>、</strong><a href="https://zhuanlan.zhihu.com/p/82184208" target="_blank" rel="noopener">物理层 和 MAC 层</a><strong>、</strong><a href="https://www.jianshu.com/p/63fd0faa47da" target="_blank" rel="noopener">网络传输中的三张表，MAC地址表、ARP缓存表以及路由表详解</a>**</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>MAC</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>重装ubuntu及win10引导修复</title>
    <url>/2022/04/08/%E9%87%8D%E8%A3%85ubuntu%E5%8F%8Awin10%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>人被杀就会死，ubuntu20果然崩溃了，起因似乎是重装搜狗输入法，卸载时autoremove不知删了哪个依赖，桌面死活进不去（oh,no,something went wrong警告），<a id="more"></a> 后面<em>Ctrl+Alt+F3</em>通过tty3登录，进去翻日志，一通装一通删，试了N次，发现把gnome-session删了，倒是能进桌面了，算了，直接转移数据，重装。切到win10系统，下载镜像、刻盘一气呵成，隐约记得以前用EasyBCD添加引导，下了个进去手贱，把WIN10的引导给删了,这时候才想起ubuntu新版本不用自己添加引导了~~. 幸亏U盘已经刻好，索性先重装ubuntu，再在ubuntu下，看看有什么方法恢复引导文件。装系统网上很多教程，倒是在ubuntu下刻盘，恢复win10引导值得记录一下（毕竟两个晚上的青春）。</p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>度娘说，可以通过winPE，修复引导，所以第一步：下载镜像文件。国内镜像多坑爹，问问我那逝去的青春就知道了，直接谷歌救我命<a href="https://archive.org/details/wpe-64" target="_blank" rel="noopener">WinPE.iso</a>–!</p>
<h3 id="刻盘"><a href="#刻盘" class="headerlink" title="刻盘"></a>刻盘</h3><p>ubuntu下刻盘，看大部分推荐dd命令，用国内坑爹的镜像试了几次，不确定是哪儿的原因，反正开机进不去WinPE, 包括救我命的镜像，用该命令失败。后面还是用WoeUSB（采用命令行方式，GUI失败）成功</p>
<h4 id="安装WoeUSB"><a href="#安装WoeUSB" class="headerlink" title="安装WoeUSB"></a>安装WoeUSB</h4><p>在github上下载最新版本：<a href="https://github.com/WoeUSB/WoeUSB/releases/download/v5.2.4/woeusb-5.2.4.bash" target="_blank" rel="noopener">WoeUSB github</a></p>
<p>安装 WoeUSB-ng 的依赖项，和第一种方法要安装的依赖项是一样的！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x woeusb-5.2.4.bash</span><br></pre></td></tr></table></figure>
<p>然后还需要安装一些依赖项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install git p7zip-full python3-pip python3-wxgtk4.0 grub2-common grub-pc-bin wimtools</span><br></pre></td></tr></table></figure>
<p>现在就可以执行这个文件了 .&#x2F;woeusb-5.2.4.bash 可以看到命令提示，只需要制定一个windows镜像文件地址 和 u盘的位置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l #查看U盘</span><br><span class="line">umount &#x2F;dev&#x2F;sdb  #卸载u盘</span><br><span class="line">sudo mkfs.ntfs -F &#x2F;dev&#x2F;sdb #格式化U盘</span><br><span class="line">sudo .&#x2F;woeusb-5.2.4.bash --device &#39;WinPE.iso&#39;  &#x2F;dev&#x2F;sdb  --tgt-fs  NTFS #刻盘</span><br></pre></td></tr></table></figure>
<h3 id="WIN10-引导修复"><a href="#WIN10-引导修复" class="headerlink" title="WIN10 引导修复"></a>WIN10 引导修复</h3><p>拿着刻好的U盘，重新开机，狂按F12,进入WINPE，接来下的修复过程，严格参照下面的链接（C盘和D盘，我的也是反着的）<br><a href="https://blog.csdn.net/A_Sen_A/article/details/89545311" target="_blank" rel="noopener">win10 UEFI引导恢复</a></p>
]]></content>
  </entry>
</search>
